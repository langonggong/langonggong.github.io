<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>武汉旭神</title>
  
  <subtitle>路漫漫其修远兮，吾将上下而求索</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://langonggong.com/"/>
  <updated>2020-06-22T16:46:30.308Z</updated>
  <id>http://langonggong.com/</id>
  
  <author>
    <name>lanxu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>spark简介</title>
    <link href="http://langonggong.com/2020/06/22/spark%E7%AE%80%E4%BB%8B/"/>
    <id>http://langonggong.com/2020/06/22/spark简介/</id>
    <published>2020-06-22T15:10:25.000Z</published>
    <updated>2020-06-22T16:46:30.308Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Spark 是使用 scala 实现的基于内存计算的大数据开源集群计算环境。提供了 java,scala, python,R 等语言的调用接口</p><h2 id="Hadoop-和-Spark-的关系"><a href="#Hadoop-和-Spark-的关系" class="headerlink" title="Hadoop 和 Spark 的关系"></a>Hadoop 和 Spark 的关系</h2><p>Google 在 2003 年和 2004 年先后发表了 Google 文件系统 GFS 和 MapReduce 编程模型两篇文章。 基于这两篇开源文档,06 年 Nutch 项目子项目之一的 Hadoop 实现了两个强有力的开源产品:HDFS 和 MapReduce. Hadoop 成为了典型的大数据批量处理架构,由 HDFS 负责静态数据的存储,并通过 MapReduce 将计算逻辑分配到各数据节点进行数据计算和价值发现。之后以 HDFS 和 MapReduce 为基础建立了很多项目，形成了 Hadoop 生态圈。<br>　　而 Spark 则是UC Berkeley AMP lab (加州大学伯克利分校AMP实验室)所开源的类Hadoop MapReduce的通用并行框架, 专门用于大数据量下的迭代式计算。是为了跟 Hadoop 配合而开发出来的，不是为了取代 Hadoop。Spark 运算比 Hadoop 的 MapReduce 框架快的原因是因为 Hadoop 在一次 MapReduce 运算之后，会将数据的运算结果从内存写入到磁盘中，第二次 Mapredue 运算时在从磁盘中读取数据，所以其瓶颈在2次运算间的多余 IO 消耗.。Spark 则是将数据一直缓存在内存中,直到计算得到最后的结果,再将结果写入到磁盘，所以多次运算的情况下，Spark 是比较快的。其优化了迭代式工作负载<br>　　<br><img src="/images/hadoop-vs-spark.png"></p><h2 id="基本模块"><a href="#基本模块" class="headerlink" title="基本模块"></a>基本模块</h2><p><img src="/images/spark-module.png"></p><ul><li>Spark Core：包含Spark的基本功能；尤其是定义RDD的API、操作以及这两者上的动作。其他Spark的库都是构建在RDD和Spark Core之上的</li><li>Spark SQL：提供通过Apache Hive的SQL变体Hive查询语言（HiveQL）与Spark进行交互的API。每个数据库表被当做一个RDD，Spark SQL查询被转换为Spark操作。</li><li>Spark Streaming：对实时数据流进行处理和控制。Spark Streaming允许程序能够像普通RDD一样处理实时数据</li><li>MLlib：一个常用机器学习算法库，算法被实现为对RDD的Spark操作。这个库包含可扩展的学习算法，比如分类、回归等需要对大量数据集进行迭代的操作。</li><li>GraphX：控制图、并行图操作和计算的一组算法和工具的集合。GraphX扩展了RDD API，包含控制图、创建子图、访问路径上所有顶点的操作</li></ul><p>Spark 的主要特点还包括:</p><ul><li>提供 Cache 机制来支持需要反复迭代计算或者多次数据共享,减少数据读取的 IO 开销;</li><li>提供了一套支持 DAG 图的分布式并行计算的编程框架,减少多次计算之间中间结果写到 Hdfs 的开销;</li><li>使用多线程池模型减少 Task 启动开稍, shuffle 过程中避免不必要的 sort 操作并减少磁盘 IO 操作。(Hadoop 的 Map 和 reduce 之间的 shuffle 需要 sort)</li></ul><h1 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h1><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><p>Spark 集群由集群管理器 Cluster Manager、工作节点 Worker、执行器 Executor、驱动器 Driver、应用程序 Application 等部分组成。</p><p><img src="/images/spark-framework.png"></p><p><strong>Cluter Manager</strong></p><p>Spark 的集群管理器，主要负责对整个集群资源的分配和管理。根据部署模式的不同，可以分为如下：</p><ul><li>Hadoop YARN: 主要是指 YARN 中的 ResourceManager。YARN 是 Hadoop2.0 中引入的集群管理器，可以让多种数据处理框架运行在一个共享的资源池上，让 Spark 运行在配置了 YARN 的集群上是一个非常好的选择，可以利用 YARN 来管理资源。</li><li>Apache Mesos：主要是指 Mesos Master。Mesos 起源于Berkeley AMP实验室，是一个通用的集群管理器。能够将CPU、内存、存储以及其它计算资源由设备（物理或虚拟）中抽象出来，形成一个池的逻辑概念，从而实现高容错与弹性分布式系统的轻松构建与高效运行。</li><li>Standalone：主要是指 Standalone Master。Standalone Master 是 spark 原生的资源管理，由Master负责资源的分配。</li></ul><p><strong>Worker</strong></p><p>Spark 的工作节点，用于执行提交的作业。在 YARN 部署模式下 Worker 由 NodeManager 代替。<br>Worker 有如下作用：</p><ul><li>通过注册机制向 Cluster Master 汇报自身的 cpu 和 memory 等资源</li><li>在 Master 的指示下创建启动 Executor，Executor 是执行真正计算的苦力</li><li>将资源和任务进一步分配给 Executor</li><li>同步资源信息、Executor 状态信息给 Cluster Master</li></ul><p><strong>Executor</strong><br>真正执行计算任务的组件。<br>Executor 是某个 Application 运行在 Worker 节点上的一个进程，该进程负责运行某些 Task， 并且负责将数据存到内存或磁盘上，每个 Application 都有各自独立的一批 Executor， 在 Spark on Yarn 模式下，其进程名称为 CoarseGrainedExecutor Backend。一个 CoarseGrainedExecutor Backend 有且仅有一个 Executor 对象， 负责将 Task 包装成 taskRunner，并从线程池中抽取一个空闲线程运行 Task， 每个 CoarseGrainedExecutorBackend 能并行运行 Task 的数量取决于分配给它的 CPU 的个数。</p><p><strong>Driver</strong><br>Application 的驱动程序。可以理解为使程序运行中的 main 函数，它会创建 SparkContext。Application 通过 Driver 与 Cluster Master 和 Executor 进行通信。Driver 可以运行在 Application 中，也可以由 Application 提交给 Cluster Master，由 Cluster Master 安排 Worker 运行。<br>Driver 的作用：</p><ul><li>运行应用程序的 main 函数</li><li>创建 Spark 的上下文</li><li>划分 RDD 并生成有向无环图（DAGScheduler）</li><li>与 Spark 中的其他组进行协调，协调资源等等（SchedulerBackend）</li><li>生成并发送 task 到 executor（taskScheduler）</li></ul><p><strong>Application</strong><br>用户使用 Spark API 编写的的应用程序，其中包括一个 Driver 功能的代码和分布在集群中多个节点上运行的 Executor 代码。<br>Application 通过 Spark API 创建 RDD，对 RDD 进行转换，创建 DAG，并通过 Driver 将 Application 注册到 Cluster Master。</p><h1 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h1><p><img src="/images/spark-run.png"></p><ul><li>构建Spark Application的运行环境，启动SparkContext</li><li>SparkContext向资源管理器（可以是Standalone，Mesos，Yarn）申请运行Executor资源，并启动StandaloneExecutorbackend，</li><li>Executor向SparkContext申请Task</li><li>SparkContext将应用程序分发给Executor</li><li>SparkContext构建成DAG图，将DAG图分解成Stage、将Taskset发送给Task Scheduler，最后由Task Scheduler将Task发送给Executor运行</li><li>Task在Executor上运行，运行完释放所有资源</li></ul><p>Spark运行特点：</p><ul><li>每个Application获取专属的executor进程，该进程在Application期间一直驻留，并以多线程方式运行Task。这种Application隔离机制是有优势的，无论是从调度角度看（每个Driver调度他自己的任务），还是从运行角度看（来自不同Application的Task运行在不同JVM中），当然这样意味着Spark Application不能跨应用程序共享数据，除非将数据写入外部存储系统</li><li>Spark与资源管理器无关，只要能够获取executor进程，并能保持相互通信就可以了</li><li>提交SparkContext的Client应该靠近Worker节点（运行Executor的节点），最好是在同一个Rack里，因为Spark Application运行过程中SparkContext和Executor之间有大量的信息交换</li><li>Task采用了数据本地性和推测执行的优化机制</li></ul><h1 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>RDD 是 Spark 提供的最重要的抽象概念，它是一种有容错机制的特殊数据集合，可以分布在集群的结点上，以函数式操作集合的方式进行各种并行操作。</p><p>通俗点来讲，可以将 RDD 理解为一个分布式对象集合，本质上是一个只读的分区记录集合。每个 RDD 可以分成多个分区，每个分区就是一个数据集片段。一个 RDD 的不同分区可以保存到集群中的不同结点上，从而可以在集群中的不同结点上进行并行计算。</p><p>如图展示了 RDD 的分区及分区与工作结点（Worker Node）的分布关系。</p><p><img src="/images/rdd-worknode.png"></p><p>RDD 具有容错机制，并且只读不能修改，可以执行确定的转换操作创建新的 RDD。具体来讲，RDD 具有以下几个属性。</p><ul><li>只读：不能修改，只能通过转换操作生成新的 RDD。</li><li>分布式：可以分布在多台机器上进行并行处理。</li><li>弹性：计算过程中内存不够时它会和磁盘进行数据交换。</li><li>基于内存：可以全部或部分缓存在内存中，在多次计算间重用。</li></ul><p>RDD 实质上是一种更为通用的迭代并行计算框架，用户可以显示控制计算的中间结果，然后将其自由运用于之后的计算。</p><p>在大数据实际应用开发中存在许多迭代算法，如机器学习、图算法等，和交互式数据挖掘工具。这些应用场景的共同之处是在不同计算阶段之间会重用中间结果，即一个阶段的输出结果会作为下一个阶段的输入。</p><p>RDD 正是为了满足这种需求而设计的。虽然 MapReduce 具有自动容错、负载平衡和可拓展性的优点，但是其最大的缺点是采用非循环式的数据流模型，使得在迭代计算时要进行大量的磁盘 I/O 操作。</p><p>通过使用 RDD，用户不必担心底层数据的分布式特性，只需要将具体的应用逻辑表达为一系列转换处理，就可以实现管道化，从而避免了中间结果的存储，大大降低了数据复制、磁盘 I/O 和数据序列化的开销。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>RDD 的操作分为转化（Transformation）操作和行动（Action）操作。转化操作就是从一个 RDD 产生一个新的 RDD，而行动操作就是进行实际的计算。</p><p>RDD 的操作是惰性的，当 RDD 执行转化操作的时候，实际计算并没有被执行，只有当 RDD 执行行动操作时才会促发计算任务提交，从而执行相应的计算操作。</p><h3 id="构建操作"><a href="#构建操作" class="headerlink" title="构建操作"></a>构建操作</h3><p>Spark 里的计算都是通过操作 RDD 完成的，学习 RDD 的第一个问题就是如何构建 RDD，构建 RDD 的方式从数据来源角度分为以下两类。</p><ul><li>从内存里直接读取数据。</li><li>从文件系统里读取数据，文件系统的种类很多，常见的就是 HDFS 及本地文件系统。</li></ul><p>第一类方式是从内存里构造 RDD，需要使用 makeRDD 方法，代码如下所示。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val rdd01 = sc.makeRDD(List(l,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br></pre></td></tr></table></figure><p>这个语句创建了一个由“1,2,3,4,5,6”六个元素组成的 RDD。</p><p>第二类方式是通过文件系统构造 RDD，代码如下所示。</p><p>val rdd:RDD[String] == sc.textFile(“file:///D:/sparkdata.txt”,1)</p><p>这里例子使用的是本地文件系统，所以文件路径协议前缀是 file://。</p><h3 id="转换操作"><a href="#转换操作" class="headerlink" title="转换操作"></a>转换操作</h3><p>RDD 的转换操作是返回新的 RDD 的操作。转换出来的 RDD 是惰性求值的，只有在行动操作中用到这些 RDD 时才会被计算。</p><p>许多转换操作都是针对各个元素的，也就是说，这些转换操作每次只会操作 RDD 中的一个元素，不过并不是所有的转换操作都是这样的。表 1 描述了常用的 RDD 转换操作。</p><center>表 1 RDD转换操作（rdd1={1, 2, 3, 3}，rdd2={3,4,5})</center><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">说明</th><th style="text-align:center">表达式</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">map()</td><td style="text-align:center">将函数应用于 RDD 的每个元素，返回值是新的 RDD</td><td style="text-align:center">rdd1.map(x=&gt;x+l)</td><td style="text-align:center">{2,3,4,4}</td></tr><tr><td style="text-align:center">flatMap()</td><td style="text-align:center">将函数应用于 RDD 的每个元素，将元素数据进行拆分，变成迭代器，返回值是新的 RDD</td><td style="text-align:center">rdd1.flatMap(x=&gt;x.to(3))</td><td style="text-align:center">{1,2,3,2,3,3,3}</td></tr><tr><td style="text-align:center">filter()</td><td style="text-align:center">函数会过滤掉不符合条件的元素，返回值是新的 RDD</td><td style="text-align:center">rdd1.filter(x=&gt;x!=1)</td><td style="text-align:center">{2,3,3}</td></tr><tr><td style="text-align:center">distinct()</td><td style="text-align:center">将 RDD 里的元素进行去重操作</td><td style="text-align:center">rdd1.distinct()</td><td style="text-align:center">(1,2,3)</td></tr><tr><td style="text-align:center">union()</td><td style="text-align:center">生成包含两个 RDD 所有元素的新的 RDD</td><td style="text-align:center">rdd1.union(rdd2)</td><td style="text-align:center">{1,2,3,3,3,4,5}</td></tr><tr><td style="text-align:center">intersection()</td><td style="text-align:center">求出两个 RDD 的共同元素</td><td style="text-align:center">rdd1.intersection(rdd2)</td><td style="text-align:center">{3}</td></tr><tr><td style="text-align:center">subtract()</td><td style="text-align:center">将原 RDD 里和参数 RDD 里相同的元素去掉</td><td style="text-align:center">rdd1.subtract(rdd2)</td><td style="text-align:center">{1,2}</td></tr><tr><td style="text-align:center">cartesian()</td><td style="text-align:center">求两个 RDD 的笛卡儿积</td><td style="text-align:center">rdd1.cartesian(rdd2)</td><td style="text-align:center">{(1,3),(1,4)……(3,5)}</td></tr></tbody></table></div><h3 id="行动操作"><a href="#行动操作" class="headerlink" title="行动操作"></a>行动操作</h3><p>行动操作用于执行计算并按指定的方式输出结果。行动操作接受 RDD，但是返回非 RDD，即输出一个值或者结果。在 RDD 执行过程中，真正的计算发生在行动操作。表 2 描述了常用的 RDD 行动操作。</p><center>表 2 RDD 行动操作（rdd={1,2,3,3}）</center><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">说明</th><th style="text-align:center">表达式</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">collect()</td><td style="text-align:center">返回 RDD 的所有元素</td><td style="text-align:center">rdd.collect()</td><td style="text-align:center">{1,2,3,3}</td></tr><tr><td style="text-align:center">count()</td><td style="text-align:center">RDD 里元素的个数</td><td style="text-align:center">rdd.count()</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">countByValue()</td><td style="text-align:center">各元素在 RDD 中的出现次数</td><td style="text-align:center">rdd.countByValue()</td><td style="text-align:center">{(1,1),(2,1),(3,2})}</td></tr><tr><td style="text-align:center">take(num)</td><td style="text-align:center">从 RDD 中返回 num 个元素</td><td style="text-align:center">rdd.take(2)</td><td style="text-align:center">{1,2}</td></tr><tr><td style="text-align:center">top(num)</td><td style="text-align:center">从 RDD 中，按照默认（降序）或者指定的排序返回最前面的 num 个元素</td><td style="text-align:center">rdd.top(2)</td><td style="text-align:center">{3,3}</td></tr><tr><td style="text-align:center">reduce()</td><td style="text-align:center">并行整合所有 RDD 数据，如求和操作</td><td style="text-align:center">rdd.reduce((x,y)=&gt;x+y)</td><td style="text-align:center">9</td></tr><tr><td style="text-align:center">fold(zero)(func)</td><td style="text-align:center">和 reduce() 功能一样，但需要提供初始值</td><td style="text-align:center">rdd.fold(0)((x,y)=&gt;x+y)</td><td style="text-align:center">9</td></tr><tr><td style="text-align:center">foreach(func)</td><td style="text-align:center">对 RDD 的每个元素都使用特定函数</td><td style="text-align:center">rdd1.foreach(x=&gt;printIn(x))</td><td style="text-align:center">打印每一个元素</td></tr><tr><td style="text-align:center">saveAsTextFile(path)</td><td style="text-align:center">将数据集的元素，以文本的形式保存到文件系统中</td><td style="text-align:center">rdd1.saveAsTextFile(file://home/test)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">saveAsSequenceFile(path)</td><td style="text-align:center">将数据集的元素，以顺序文件格式保存到指 定的目录下</td><td style="text-align:center">saveAsSequenceFile(hdfs://home/test)</td></tr></tbody></table></div><p> aggregate() 函数的返回类型不需要和 RDD 中的元素类型一致，所以在使用时，需要提供所期待的返回类型的初始值，然后通过一个函数把 RDD 中的元素累加起来放入累加器。</p><p>考虑到每个结点都是在本地进行累加的，所以最终还需要提供第二个函数来将累加器两两合并。</p><p>aggregate(zero)(seqOp,combOp) 函数首先使用 seqOp 操作聚合各分区中的元素，然后再使用 combOp 操作把所有分区的聚合结果再次聚合，两个操作的初始值都是 zero。</p><p>seqOp 的操作是遍历分区中的所有元素 T，第一个 T 跟 zero 做操作，结果再作为与第二个 T 做操作的 zero，直到遍历完整个分区。</p><p>combOp 操作是把各分区聚合的结果再聚合。aggregate() 函数会返回一个跟 RDD 不同类型的值。因此，需要 seqOp 操作来把分区中的元素 T 合并成一个 U，以及 combOp 操作把所有 U 聚合。</p><p>下面举一个利用 aggreated() 函数求平均数的例子。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val rdd = List (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">val input = sc.parallelize(rdd)</span><br><span class="line">val result = input.aggregate((<span class="number">0</span>,<span class="number">0</span>))(</span><br><span class="line">    (acc,value) =&gt; (acc<span class="meta">._1</span> + value,acc<span class="meta">._2</span> + <span class="number">1</span>),</span><br><span class="line">    (acc1,acc2) =&gt; (acc1<span class="meta">._1</span> + acc2<span class="meta">._1</span>,acc1<span class="meta">._2</span> + acc2<span class="meta">._2</span>)</span><br><span class="line">)</span><br><span class="line"><span class="symbol">result:</span>(<span class="keyword">Int</span>,<span class="keyword">Int</span>) = (<span class="number">10</span>,<span class="number">4</span>)</span><br><span class="line">val avg = result<span class="meta">._1</span> / result<span class="meta">._2</span></span><br><span class="line"><span class="symbol">avg:</span><span class="keyword">Int</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure><p>程序的详细过程大概如下。</p><p>定义一个初始值 (0,0)，即所期待的返回类型的初始值。代码 (acc,value) =&gt; (acc._1 + value,acc._2 + 1) 中的 value 是函数定义里面的 T，这里是 List 里面的元素。acc._1 + value，acc._2 + 1 的过程如下。<br>(0+1,0+1)→(1+2,1+1)→(3+3,2+1)→(6+4,3+1)，结果为(10,4)。</p><p>实际的 Spark 执行过程是分布式计算，可能会把 List 分成多个分区，假如是两个：p1(1,2) 和 p2(3,4)。</p><p>经过计算，各分区的结果分别为 (3,2) 和 (7,2)。这样，执行 (acc1,acc2) =&gt; (acc1._1 + acc2._2,acc1._2 + acc2._2) 的结果就是 (3+7,2+2)，即 (10,4)，然后可计算平均值。</p><h2 id="血缘关系"><a href="#血缘关系" class="headerlink" title="血缘关系"></a>血缘关系</h2><p>RDD 的最重要的特性之一就是血缘关系（Lineage )，它描述了一个 RDD 是如何从父 RDD 计算得来的。如果某个 RDD 丢失了，则可以根据血缘关系，从父 RDD 计算得来。</p><p>如图给出了一个 RDD 执行过程的实例。系统从输入中逻辑上生成了 A 和 C 两个 RDD， 经过一系列转换操作，逻辑上生成了 F 这个 RDD。</p><p>Spark 记录了 RDD 之间的生成和依赖关系。当 F 进行行动操作时，Spark 才会根据 RDD 的依赖关系生成 DAG，并从起点开始真正的计算。</p><p><img src="/images/spark-lineage.png"></p><p>上述一系列处理称为一个血缘关系（Lineage），即 DAG 拓扑排序的结果。在血缘关系中，下一代的 RDD 依赖于上一代的 RDD。例如，在图 2 中，B 依赖于 A，D 依赖于 C，而 E 依赖于 B 和 D。</p><h2 id="依赖类型"><a href="#依赖类型" class="headerlink" title="依赖类型"></a>依赖类型</h2><p>根据不同的转换操作，RDD 血缘关系的依赖分为窄依赖和宽依赖。窄依赖是指父 RDD 的每个分区都只被子 RDD 的一个分区所使用。宽依赖是指父 RDD 的每个分区都被多个子 RDD 的分区所依赖。</p><p>map、filter、union 等操作是窄依赖，而 groupByKey、reduceByKey 等操作是宽依赖，如图  所示。</p><p><img src="/images/spark-dependency.png"></p><p>join 操作有两种情况，如果 join 操作中使用的每个 Partition 仅仅和固定个 Partition 进行 join，则该 join 操作是窄依赖，其他情况下的 join 操作是宽依赖。</p><p>所以可得出一个结论，窄依赖不仅包含一对一的窄依赖，还包含一对固定个数的窄依赖，也就是说，对父 RDD 依赖的 Partition 不会随着 RDD 数据规模的改变而改变。</p><h3 id="窄依赖"><a href="#窄依赖" class="headerlink" title="窄依赖"></a>窄依赖</h3><ul><li>子 RDD 的每个分区依赖于常数个父分区（即与数据规模无关)。</li><li>输入输出一对一的算子，且结果 RDD 的分区结构不变，如 map、flatMap。</li><li>输入输出一对一的算子，但结果 RDD 的分区结构发生了变化，如 union。</li><li>从输入中选择部分元素的算子，如 filter、distinct、subtract、sample。</li></ul><h3 id="宽依赖"><a href="#宽依赖" class="headerlink" title="宽依赖"></a>宽依赖</h3><ul><li>子 RDD 的每个分区依赖于所有父 RDD 分区。</li><li>对单个 RDD 基于 Key 进行重组和 reduce，如 groupByKey、reduceByKey。</li><li>对两个 RDD 基于 Key 进行 join 和重组，如 join。</li></ul><p>Spark 的这种依赖关系设计，使其具有了天生的容错性，大大加快了 Spark 的执行速度。RDD 通过血缘关系记住了它是如何从其他 RDD 中演变过来的。当这个 RDD 的部分分区数据丢失时，它可以通过血缘关系获取足够的信息来重新运算和恢复丢失的数据分区，从而带来性能的提升。</p><p>相对而言，窄依赖的失败恢复更为高效，它只需要根据父 RDD 分区重新计算丢失的分区即可，而不需要重新计算父 RDD 的所有分区。而对于宽依赖来讲，单个结点失效，即使只是 RDD 的一个分区失效，也需要重新计算父 RDD 的所有分区，开销较大。</p><p>宽依赖操作就像是将父 RDD 中所有分区的记录进行了“洗牌”，数据被打散，然后在子 RDD 中进行重组。</p><h2 id="阶段划分"><a href="#阶段划分" class="headerlink" title="阶段划分"></a>阶段划分</h2><p>用户提交的计算任务是一个由 RDD 构成的 DAG，如果 RDD 的转换是宽依赖，那么这个宽依赖转换就将这个 DAG 分为了不同的阶段（Stage)。由于宽依赖会带来“洗牌”，所以不同的 Stage 是不能并行计算的，后面 Stage 的 RDD 的计算需要等待前面 Stage 的 RDD 的所有分区全部计算完毕以后才能进行。</p><p>这点就类似于在 MapReduce 中，Reduce 阶段的计算必须等待所有 Map 任务完成后才能开始一样。</p><p>在对 Job 中的所有操作划分 Stage 时，一般会按照倒序进行，即从 Action 开始，遇到窄依赖操作，则划分到同一个执行阶段，遇到宽依赖操作，则划分一个新的执行阶段。后面的 Stage 需要等待所有的前面的 Stage 执行完之后才可以执行，这样 Stage 之间根据依赖关系就构成了一个大粒度的 DAG。</p><p>下面如图详细解释一下阶段划分。</p><p>假设从 HDFS 中读入数据生成 3 个不同的 RDD(A、C 和 E)，通过一系列转换操作后得到新的 RDD(G)，并把结果保存到 HDFS 中。可以看到这幅 DAG 中只有 join 操作是一个宽依赖，Spark 会以此为边界将其前后划分成不同的阶段。</p><p>同时可以注意到，在 Stage2 中，从 map 到 union 都是窄依赖，这两步操作可以形成一个流水线操作，通过 map 操作生成的分区可以不用等待整个 RDD 计算结束，而是继续进行 union 操作，这样大大提高了计算的效率。</p><p><img src="/images/spark-stage.png"></p><p>把一个 DAG 图划分成多个 Stage 以后，每个 Stage 都代表了一组由关联的、相互之间没有宽依赖关系的任务组成的任务集合。在运行的时候，Spark 会把每个任务集合提交给任务调度器进行处理。</p>]]></content>
    
    <summary type="html">
    
      spark简介
    
    </summary>
    
      <category term="大数据" scheme="http://langonggong.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://langonggong.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="spark" scheme="http://langonggong.com/tags/spark/"/>
    
      <category term="hadoop" scheme="http://langonggong.com/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Damerau–Levenshtein distance</title>
    <link href="http://langonggong.com/2019/11/16/Damerau%E2%80%93Levenshtein-distance/"/>
    <id>http://langonggong.com/2019/11/16/Damerau–Levenshtein-distance/</id>
    <published>2019-11-16T10:06:22.000Z</published>
    <updated>2020-06-22T16:40:36.954Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h1><p>Damerau–Levenshtein distance（D氏距离）对比L氏距离，还新增了交换操作（响铃两个字符的交换），一共包含了新增、删除、替换、交换四种编辑操作。计算公式如下</p><p><img src="/images/Damerau–Levenshtein distance公式.png"></p><p>该公式的最后一步，表示a字符串前i个字符序列可以通过相邻两个</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>将abc转换为acb<br>Levenshtein Distance算法解决方法如下：<br>方法一：</p><p><img src="/images/Damerau–Levenshtein distance示例步骤1.png"></p><p>abc-&gt;acc（将字符b替换成字符c）<br>acc-&gt;acb（将字符c替换成字符b）<br>一共进行两次字符替换操作<br>方法二：</p><p><img src="/images/Damerau–Levenshtein distance示例步骤2.png"></p><p>abc-&gt;ac（删除字符b）<br>ac-&gt;acb（新增字符b）<br>先删除中间的字符b，再在末尾添加字符b<br>方法三：</p><p><img src="/images/Damerau–Levenshtein distance示例步骤3.png"></p><p>abc-&gt;acbc（新增字符c）<br>acbc-&gt;acb（删除字符c）<br>先新增字符c，再删除末尾的字符c</p><p>Damerau–Levenshtein distance算法解决过程如下：</p><p><img src="/images/Damerau–Levenshtein distance示例结果图.png"></p><p>将b字符和c字符替换即可，满足条件</p><p><img src="/images/Damerau–Levenshtein distance交换.png"></p>]]></content>
    
    <summary type="html">
    
      Damerau–Levenshtein distance
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://langonggong.com/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://langonggong.com/tags/Elasticsearch/"/>
    
      <category term="Lucune" scheme="http://langonggong.com/tags/Lucune/"/>
    
      <category term="编辑距离" scheme="http://langonggong.com/tags/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>Levenshtein Distance</title>
    <link href="http://langonggong.com/2019/11/16/Levenshtein-Distance/"/>
    <id>http://langonggong.com/2019/11/16/Levenshtein-Distance/</id>
    <published>2019-11-16T09:46:00.000Z</published>
    <updated>2020-06-22T16:40:36.957Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h1><p>Levenshtein Distance（L氏距离）是一个度量两个字符序列之间差异的字符串度量标准，两个单词之间的Levenshtein Distance是将一个单词转换为另一个单词所需的单字符编辑（插入、删除或替换）的最小数量</p><p>例如：将单词abroad转换为aboarc</p><ul><li>abroad-&gt;aboad（删除字符r）</li><li>aboad-&gt;aboard（插入字符r）</li><li>aboard-&gt;aboarc（将字符d替换为字符c）</li></ul><p>编辑距离为3</p><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><p>对于两个字符串a、b，长度分别为|a|、|b|，i、j分别为a、b的下标值，它们的Levenshtein Distance 为：</p><p><img src="/images/Levenshtein Distance公式.png"></p><p>表示字符串a的前i个字符序列转换为字符串b的前j个字符序列所需要的最短的编辑距离</p><p>1、空字符串与任意非空字符串的编剧距离等于非空字符串的长度</p><p><img src="/images/Levenshtein Distance空字符.png"></p><p><img src="/images/Levenshtein Distance空字符矩阵.png"></p><p>如图第二行，将空字符串转换为k需要插入一个字符，编辑距离为1；<br>将空字符串转化为kf，需要插入两个字符，编辑距离为2；<br>如图第二列，将k转换为空字符串，需要删除一个字符，编辑距离为1；<br>将kc转换为空字符串，需要删除两个字符，编辑距离为2</p><p>2、删除一个字符</p><p><img src="/images/Levenshtein Distance删除.png"></p><p><img src="/images/Levenshtein Distance删除矩阵.png"></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">"kfc"</span>,b=<span class="string">"kc"</span>,i=<span class="number">2</span>,j=<span class="number">1</span>,</span><br><span class="line">lev(<span class="number">1</span>,<span class="number">1</span>)等同于将字符串a中的<span class="string">"k"</span>转换为字符串b中的<span class="string">"k"</span>，编辑距离为<span class="number">0</span></span><br><span class="line">lev(<span class="number">2</span>,<span class="number">1</span>)等同于将字符串a中的<span class="string">"kf"</span>转换为字符串b中的<span class="string">"k"</span>，编辑距离为<span class="number">1</span>，需要一步删除操作</span><br><span class="line">lev(i,j)=lev(<span class="number">2</span>,<span class="number">1</span>)=lev(<span class="number">1</span>,<span class="number">1</span>)+<span class="number">1</span>=<span class="number">0</span>+<span class="number">1</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>由图像可知：在前一行的编辑距离上加一</p><p>3、新增一个字符</p><p><img src="/images/Levenshtein Distance新增.png"></p><p><img src="/images/Levenshtein Distance新增矩阵.png"></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">"kc"</span>,b=<span class="string">"kfc"</span>,i=<span class="number">1</span>,j=<span class="number">2</span></span><br><span class="line">lev(<span class="number">1</span>,<span class="number">1</span>)等同于将字符串a中的<span class="string">"k"</span>转换为字符串b中的<span class="string">"k"</span>，编辑距离为<span class="number">0</span></span><br><span class="line">lev(<span class="number">1</span>,<span class="number">2</span>)等同于将字符串a中的<span class="string">"k"</span>转换为字符串b中的<span class="string">"kf"</span>，编辑距离为<span class="number">1</span>，需要一步新增操作</span><br><span class="line">lev(i,j)=lev(<span class="number">1</span>,<span class="number">2</span>)=lev(<span class="number">1</span>,<span class="number">1</span>)+<span class="number">1</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>由图像可知：在前一列的编辑距离上加一</p><p>4、当前两个字符相同，编辑距离不变</p><p><img src="/images/Levenshtein Distance不变.png"></p><p><img src="/images/Levenshtein Distance不变矩阵.png"></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">"kc"</span>,b=<span class="string">"kfc"</span>,i=<span class="number">2</span>,j=<span class="number">3</span></span><br><span class="line">lev(<span class="number">1</span>,<span class="number">2</span>)等同于将字符串a中的<span class="string">"k"</span>转换为字符串b中的<span class="string">"kf"</span>，编辑距离为<span class="number">1</span>，需要一步新增操作</span><br><span class="line">lev(<span class="number">2</span>,<span class="number">3</span>)等同于将字符串a中的<span class="string">"kc"</span>转换为字符串b中的<span class="string">"kfc"</span>，编辑距离为<span class="number">1</span></span><br><span class="line">因为字符串a中的c字符等于字符串b中的c字符，所以lev(i,j)=lev(<span class="number">2</span>,<span class="number">3</span>)=lev(<span class="number">1</span>,<span class="number">2</span>)+<span class="number">0</span></span><br></pre></td></tr></table></figure><p>由图像可知：与左上角坐标所示编辑距离相同</p><p>5、当前两个字符不同，替换操作</p><p><img src="/images/Levenshtein Distance替换.png"></p><p><img src="/images/Levenshtein Distance替换矩阵.png"></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">"kc"</span>,b=<span class="string">"kb"</span>,i=j=<span class="number">2</span></span><br><span class="line">lev(<span class="number">1</span>,<span class="number">1</span>)等同于将字符串a中的<span class="string">"k"</span>转换为字符串b中的<span class="string">"k"</span>，编辑距离为<span class="number">0</span></span><br><span class="line">lev(<span class="number">2</span>,<span class="number">2</span>)等同于将字符串a中的<span class="string">"kc"</span>转换为字符串b中的<span class="string">"kb"</span>，编辑距离为<span class="number">1</span>，需要替换一个字符串</span><br></pre></td></tr></table></figure><p>由图像可知：将左上角坐标所示编辑距离加一</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>求最优编辑距离示例：将单词abroad转换为aboarc<br>1、将abr转换为ab，删除字符r</p><p><img src="/images/Levenshtein Distance示例步骤1.png"></p><p>2、将aboa（之前已删除字符r）转换为aboar，新增字符r</p><p><img src="/images/Levenshtein Distance示例步骤2.png"></p><p>3、将aboard转换为aboarc，将字符d替换为字符c</p><p><img src="/images/Levenshtein Distance示例步骤3.png"></p><h1 id="字符串的相似度"><a href="#字符串的相似度" class="headerlink" title="字符串的相似度"></a>字符串的相似度</h1><p><img src="/images/Levenshtein Distance字符串相似度.png"></p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>DNA序列分析、拼写检查、语音辨识、抄袭侦测</p>]]></content>
    
    <summary type="html">
    
      Levenshtein Distance
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://langonggong.com/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://langonggong.com/tags/Elasticsearch/"/>
    
      <category term="Lucune" scheme="http://langonggong.com/tags/Lucune/"/>
    
      <category term="编辑距离" scheme="http://langonggong.com/tags/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>AC自动机</title>
    <link href="http://langonggong.com/2019/11/16/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <id>http://langonggong.com/2019/11/16/AC自动机/</id>
    <published>2019-11-16T09:36:46.000Z</published>
    <updated>2020-06-22T16:40:36.952Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="应用背景"><a href="#应用背景" class="headerlink" title="应用背景"></a>应用背景</h1><p>在互联网应用中，通常会用到关键词检测功能，以防止用户发表包括了指定关键词的内容。如游戏的聊天系统、角色名称检测，论坛发帖、直播弹幕等，都需要对用户发布的内容进行检测，以检测是否包含敏感的关键字。</p><p>通常需要检测的关键词，会有很多很多，比如侮辱人的关键词，政治敏感的关键词，系统相关的特定关键词等。毫不夸张的说，通常要检测的关键词会有几千个，甚至过万。这时效率都变得尤为突出，如果检测关键词的效率低下，对大型互联网应用来说，很可能有是致命的。</p><p>以8000个关键词为例，如果使用正则表达式，则需要对用户发布的内容遍历8000遍。如果同一秒中，有100位，1000位，10000位…用户发布内容，可想而知仅仅在关键词检测方面服务器上CPU的开销。</p><p>AC多模式匹配算法，可以有效的解决关键词检测的效率问题。时间复杂度为O(n),n为用户发布内容的长度n。基本与关键词的数量无关。</p><h1 id="AC算法介绍"><a href="#AC算法介绍" class="headerlink" title="AC算法介绍"></a>AC算法介绍</h1><p>AC算法是一个经典的多模式匹配算法，可以保证对于给定的长度为n的文本，和模式集合P{p1,p2,…pm}，在O(n)时间复杂度内，找到文本中的所有目标模式，而与模式集合的规模m无关。</p><p>AC算法实现原理：<br>ac自动机,就是在tire树的基础上,增加一个fail指针,如果当前点匹配失败,则将指针转移到fail指针指向的地方,这样就不用回溯,而可以路匹配下去了</p><p>举例：<br>如要查找abce和bcd是否在abcd中出现,我们找到c发现下一个要找的不是e,就跳到bcd中的c处,看看此处的下一个字符(d)是不是应该找的那一个<br>因为abc部分的后缀与bcd的部分前缀相同，便能构造fail指针</p><p><img src="/images/fail示例.png"></p><p>完整流程：</p><ul><li>构建敏感词树型结构，并标注结束节点（即是否是一个敏感词的结束）；</li><li>为树上的结点，构建匹配失败时的跳转-失败结点（即匹配失败时，跳转到哪个结点继续匹配）；</li><li>对用户内容进行一次遍历，对于每个字符（字节）都去敏感词树型结构中，从当前结点位置开始匹配。</li></ul><h1 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h1><p>以模式串he,she,him,hers,shit为例，先构造一颗字典树</p><p><img src="/images/AC树.png"></p><p>图像说明</p><ul><li>图中根节点为空节点</li><li>红色节点表示该节点是一个存在的字符串</li><li>蓝色实线连接父子节点</li><li>黄色虚线表示fail指针</li><li>没有标注黄色虚线的节点，fail指针默认都指向根节点</li></ul><p>fail指针构造过程</p><ul><li>第三行的h节点，找到父节点的fail节点的子节点中，与当前节点相同的点，将h的fail指针指向该节点</li><li>第四行的i节点，找他i节点的父节点的fail节点的子节点中是否有i节点</li><li>依次类推</li></ul><h1 id="匹配示例"><a href="#匹配示例" class="headerlink" title="匹配示例"></a>匹配示例</h1><p>拿主串ashers上去匹配</p><p><img src="/images/AC匹配过程.png"></p><ul><li>第三步确定找到she，接续沿着线头则匹配失败，根据fail指针跳转</li><li>第四步找到he，继续往下找</li><li>第六步找到hers，匹配结束</li></ul>]]></content>
    
    <summary type="html">
    
      AC自动机
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://langonggong.com/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://langonggong.com/tags/Elasticsearch/"/>
    
      <category term="树" scheme="http://langonggong.com/tags/%E6%A0%91/"/>
    
      <category term="Lucune" scheme="http://langonggong.com/tags/Lucune/"/>
    
  </entry>
  
  <entry>
    <title>Double Array Trie</title>
    <link href="http://langonggong.com/2019/11/16/Double-Array-Trie/"/>
    <id>http://langonggong.com/2019/11/16/Double-Array-Trie/</id>
    <published>2019-11-16T09:20:56.000Z</published>
    <updated>2020-06-22T16:40:36.955Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>Trie树的创建要考虑的是父节点如何保存孩子节点，主要有链表和数组两种方式：</p><ul><li>使用节点数组，因为是英文字符，可以用Node[26]来保存孩子节点(如果是数字我们可以用Node[10])，这种方式最快，但是并不是所有节点都会有很多孩子，所以这种方式浪费的空间太多</li><li>用一个链表根据需要动态添加节点。这样我们就可以省下不小的空间，但是缺点是搜索的时候需要遍历这个链表，增加了时间复杂度。</li><li>Trie也可以按照DFA的方式存储，即表示为转移矩阵。行表示状态，列表示输入字符，(行, 列)位置表示转移状态。这种方式的查询效率很高，但由于稀疏的现象严重，空间利用效率很低。</li></ul><p>如果是中文词典，子节点的数目范围跨度更大，问题将会更加严重</p><p><img src="/images/字典树父子节点.png"></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>双数组Trie树（Double-array Trie, DAT）是一种Trie树的高效实现，兼顾了查询效率与空间存储</p><p>Double-Array Trie包含base和check两个数组。base数组的每个元素表示一个Trie节点，即一个状态；check数组表示某个状态的前驱状态。<br>其中，s是当前状态的下标，t是转移状态的下标，c是输入字符的数值。如图所示：<br>base和check的关系满足下述条件：<br>base[s] + c = t<br>check[t] = s</p><p><img src="/images/双数组.png"></p><p>以bachelor, baby, badge, jar为例</p><p><img src="/images/双数组示例.png"></p><p>其中，字符的编码表为{‘#’=1, ‘a’=2, ‘b’=3, ‘c’=4, etc. }。为了对Trie做进一步的压缩，用tail数组存储无公共前缀的尾字符串，且满足如下的特点：<br>p = -base[m], tail[p] = b1, tail[p+1] = b2, …, tail[p+h-1] = bh；<br>h为该尾字符串的长度</p><h1 id="检索示例"><a href="#检索示例" class="headerlink" title="检索示例"></a>检索示例</h1><p>检索词badge的过程如下：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// root -&gt; b</span></span><br><span class="line">base[<span class="number">1</span>] + 'b' = <span class="number">4</span> + <span class="number">3</span> = <span class="number">7</span></span><br><span class="line">check[<span class="number">7</span>]=<span class="number">1</span></span><br><span class="line"><span class="comment">// root -&gt; b -&gt; a</span></span><br><span class="line">base[<span class="number">7</span>] + 'a' = <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span></span><br><span class="line">check[<span class="number">3</span>]=<span class="number">7</span></span><br><span class="line"><span class="comment">// root -&gt; b -&gt; a -&gt; d</span></span><br><span class="line">base[<span class="number">3</span>] + 'd' = <span class="number">1</span> + <span class="number">5</span> = <span class="number">6</span></span><br><span class="line">check[<span class="number">6</span>]=<span class="number">3</span></span><br><span class="line"><span class="comment">// badge#</span></span><br><span class="line">base[<span class="number">6</span>] = <span class="number">-12</span></span><br><span class="line">tail[<span class="number">12.</span><span class="number">.14</span>] = 'ge#'</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Double Array Trie
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://langonggong.com/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://langonggong.com/tags/Elasticsearch/"/>
    
      <category term="树" scheme="http://langonggong.com/tags/%E6%A0%91/"/>
    
      <category term="Lucune" scheme="http://langonggong.com/tags/Lucune/"/>
    
  </entry>
  
  <entry>
    <title>字典树</title>
    <link href="http://langonggong.com/2019/11/16/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    <id>http://langonggong.com/2019/11/16/字典树/</id>
    <published>2019-11-16T08:59:24.000Z</published>
    <updated>2020-06-22T16:40:36.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>如果现在有b，abc，abd，bcd，abcd，efg，hii 这7个单词，我们可以构建一棵如下图所示的树：</p><p><img src="/images/字典树.png"></p><p>如上图所示，对于每一个节点，从根遍历到他的过程就是一个单词，如果这个节点被标记为红色，就表示这个单词存在，否则不存在。 </p><p>Trie树，又称字典树，单词查找树或者前缀树，是一种用于快速检索的多叉树结构，如英文字母的字典树是一个26叉树，数字的字典树是一个10叉树。<br>与二叉查找树不同，Trie树的键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p><h2 id="基本性质："><a href="#基本性质：" class="headerlink" title="基本性质："></a>基本性质：</h2><ul><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li><li>每个节点的所有子节点包含的字符都不相同。</li></ul><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>Trie树优点是最大限度地减少无谓的字符串比较，查询效率比较高。核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p><ul><li>插入、查找的时间复杂度均为O(N)，其中N为字符串长度。</li><li>空间复杂度是26^n级别的，非常庞大（可采用双数组实现改善）。</li></ul><h1 id="Trie树的实现"><a href="#Trie树的实现" class="headerlink" title="Trie树的实现"></a>Trie树的实现</h1><p>trie树实际上是一个DFA，通常用转移矩阵表示。行表示状态，列表示输入字符，（行，列）位置表示转移状态。这种方式的查询效率很高，但由于稀疏的现象严重，空间利用效率很低。也可以采用压缩的存储方式即链表来表示状态转移，但由于要线性查询，会造成效率低下。</p><p>Trie树的创建要考虑的是父节点如何保存孩子节点，主要有链表和数组两种方式：</p><ul><li>使用节点数组，因为是英文字符，可以用Node[26]来保存孩子节点(如果是数字我们可以用Node[10])，这种方式最快，但是并不是所有节点都会有很多孩子，所以这种方式浪费的空间太多</li><li>用一个链表根据需要动态添加节点。这样我们就可以省下不小的空间，但是缺点是搜索的时候需要遍历这个链表，增加了时间复杂度。</li></ul><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>字符串检索<br>  事先将已知的一些字符串（字典）的有关信息保存到trie树里，查找另外一些未知字符串是否出现过或者出现频率。<br>例如：给出一个词典，其中的单词为不良单词。单词均为小写字母。再给出一段文本，文本的每一行也由小写字母构成。判断文本中是否含有任何不良单词</li><li>字符串最长公共前缀<br>  Trie树利用多个字符串的公共前缀来节省存储空间，反之，当我们把大量字符串存储到一棵trie树上时，我们可以快速得到某些字符串的公共前缀。</li><li>排序<br>  Trie树是一棵多叉树，只要先序遍历整棵树，输出相应的字符串便是按字典序排序的结果。<br>也可以快速获得最小、最大字符串（举出数据地图分页查看分区、求最大最小分区的例子）</li><li>词频统计<br>  统计每个单词出现的次数，以及找到出现频率最高的n个单词</li><li>字符串搜索的前缀匹配<br>  trie树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</li><li>作为其他数据结构和算法的辅助结构<br>  如后缀树，AC自动机等</li></ul><h1 id="数据结构的比较"><a href="#数据结构的比较" class="headerlink" title="数据结构的比较"></a>数据结构的比较</h1><h2 id="二叉搜索树（binary-search-tree）"><a href="#二叉搜索树（binary-search-tree）" class="headerlink" title="二叉搜索树（binary search tree）"></a>二叉搜索树（binary search tree）</h2><p>二叉搜索树又叫做二叉排序树，它满足：</p><ul><li>任意节点如果左子树不为空，左子树所有节点的值都小于根节点的值；</li><li>任意节点如果右子树不为空，右子树所有节点的值都大于根节点的值；</li><li>左右子树也都是二叉搜索树；</li><li>所有节点的值都不相同。</li></ul><p>其实二叉搜索树的优势已经在与查找、插入的时间复杂度上了，通常只有 O(log n)，很多集合都是通过它来实现的。在进行插入的时候，实质上是给树添加新的叶子节点，避免了节点移动，搜索、插入和删除的复杂度等于树的高度，属于 O(log n)，最坏情况下整棵树所有的节点都只有一个子节点，完全变成一个线性表，复杂度是 O(n)。<br>Trie 树在最坏情况下查找要快过二叉搜索树，如果搜索字符串长度用 m 来表示的话，它只有 O(m)，通常情况（树的节点个数要远大于搜索字符串的长度）下要远小于 O(n)。<br>我们给 Trie 树举例子都是拿字符串举例的，其实它本身对 key 的适宜性是有严格要求的，如果 key 是浮点数的话，就可能导致整个 Trie 树巨长无比，节点可读性也非常差，这种情况下是不适宜用 Trie 树来保存数据的；而二叉搜索树就不存在这个问题。</p><h2 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h2><p>Trie 树可以比较方便地按照 key 的字母序来排序（整棵树先序遍历一次就好了），这是绝大多数 Hash 表是不同的（Hash 表一般对于不同的 key 来说是无序的）。<br>考虑一下 Hash 表键冲突的问题。Hash 表通常我们说它的复杂度是 O(1)，其实严格说起来这是接近完美的 Hash 表的复杂度，另外还需要考虑到 hash 函数本身需要遍历搜索字符串，复杂度是 O(m)。在不同键被映射到 “同一个位置”（考虑 closed hashing，这 “同一个位置” 可以由一个普通链表来取代）的时候，需要进行查找的复杂度取决于这 “同一个位置” 下节点的数目，因此，在最坏情况下，Hash 表也是可以成为一张单向链表的。<br>在较理想的情况下，Hash 表可以以 O(1) 的速度迅速命中目标，如果这张表非常大，需要放到磁盘上的话，Hash 表的查找访问在理想情况下只需要一次即可；但是 Trie 树访问磁盘的数目需要等于节点深度。<br>很多时候 Trie 树比 Hash 表需要更多的空间，我们考虑这种一个节点存放一个字符的情况的话，在保存一个字符串的时候，没有办法把它保存成一个单独的块。Trie 树的节点压缩可以明显缓解这个问题，后面会讲到。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p><a href="https://www.cnblogs.com/binyue/p/3771040.html" target="_blank" rel="noopener">字典树(Trie树)的实现及应用</a><br><a href="https://www.cnblogs.com/justinh/p/7716421.html" target="_blank" rel="noopener">Trie（前缀树/字典树）及其应用</a><br><a href="https://www.raychase.net/1783" target="_blank" rel="noopener">Trie 树和其它数据结构的比较</a><br><a href="https://www.shenyanchao.cn/blog/2018/12/04/lucene-numberic/" target="_blank" rel="noopener">Lucene数字类型处理</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      字典树
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://langonggong.com/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://langonggong.com/tags/Elasticsearch/"/>
    
      <category term="树" scheme="http://langonggong.com/tags/%E6%A0%91/"/>
    
      <category term="Lucune" scheme="http://langonggong.com/tags/Lucune/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://langonggong.com/2019/10/03/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://langonggong.com/2019/10/03/线程池/</id>
    <published>2019-10-03T08:12:49.000Z</published>
    <updated>2020-06-22T16:40:36.965Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="ThreadPoolExecutor构造参数"><a href="#ThreadPoolExecutor构造参数" class="headerlink" title="ThreadPoolExecutor构造参数"></a>ThreadPoolExecutor构造参数</h1><ul><li>corePoolSize<br>  线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；<br>如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；<br>如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</li><li>maximumPoolSize<br>  线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize</li><li>keepAliveTime<br>  线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间。默认情况下，该参数只在线程数大于corePoolSize时才有用</li><li>workQueue<br>  workQueue必须是BlockingQueue阻塞队列。当线程池中的线程数超过它的corePoolSize的时候，线程会进入阻塞队列进行阻塞等待。通过workQueue，线程池实现了阻塞功能</li><li>threadFactory<br>  创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名</li></ul><h2 id="几种排队的策略："><a href="#几种排队的策略：" class="headerlink" title="几种排队的策略："></a>几种排队的策略：</h2><h3 id="不排队，直接提交"><a href="#不排队，直接提交" class="headerlink" title="不排队，直接提交"></a>不排队，直接提交</h3><p>将任务直接交给线程处理而不保持它们，可使用SynchronousQueue<br>如果不存在可用于立即运行任务的线程（即线程池中的线程都在工作），则试图把任务加入缓冲队列将会失败，因此会构造一个新的线程来处理新添加的任务，并将其加入到线程池中（corePoolSize—&gt;maximumPoolSize扩容）<br>Executors.newCachedThreadPool()采用的便是这种策略</p><h3 id="无界队列"><a href="#无界队列" class="headerlink" title="无界队列"></a>无界队列</h3><p>可以使用LinkedBlockingQueue（基于链表的有界队列，FIFO），理论上是该队列可以对无限多的任务排队</p><p>将导致在所有corePoolSize线程都工作的情况下将新任务加入到队列中。这样，创建的线程就不会超过corePoolSize，也因此，maximumPoolSize的值也就无效了</p><h3 id="有界队列"><a href="#有界队列" class="headerlink" title="有界队列"></a>有界队列</h3><p>可以使用ArrayBlockingQueue（基于数组结构的有界队列，FIFO），并指定队列的最大长度</p><p>使用有界队列可以防止资源耗尽，但也会造成超过队列大小和maximumPoolSize后，提交的任务被拒绝的问题，比较难调整和控制。</p><h2 id="RejectedExecutionHandler（饱和策略）"><a href="#RejectedExecutionHandler（饱和策略）" class="headerlink" title="RejectedExecutionHandler（饱和策略）"></a>RejectedExecutionHandler（饱和策略）</h2><p>线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：</p><ul><li>AbortPolicy：直接抛出异常，默认策略；</li><li>CallerRunsPolicy：用调用者所在的线程来执行任务；</li><li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li><li>DiscardPolicy：直接丢弃任务；</li></ul><p>当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p><h1 id="线程池的执行流程"><a href="#线程池的执行流程" class="headerlink" title="线程池的执行流程"></a>线程池的执行流程</h1><ul><li>如果线程池中的线程数量少于corePoolSize，就创建新的线程来执行新添加的任务</li><li>如果线程池中的线程数量大于等于corePoolSize，但队列workQueue未满，则将新添加的任务放到workQueue中</li><li>如果线程池中的线程数量大于等于corePoolSize，且队列workQueue已满，但线程池中的线程数量小于maximumPoolSize，则会创建新的线程来处理被添加的任务</li><li>如果线程池中的线程数量等于了maximumPoolSize，就用RejectedExecutionHandler来执行拒绝策略</li></ul><h1 id="Executors静态工厂创建几种常用线程池"><a href="#Executors静态工厂创建几种常用线程池" class="headerlink" title="Executors静态工厂创建几种常用线程池"></a>Executors静态工厂创建几种常用线程池</h1><h2 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h2><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">FixedThreadPool</span>(int nThreads) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">FixedThreadPool</span>(int nThreads, ThreadFactory threadFactory) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个指定工作线程数的线程池，其中参数 corePoolSize 和 maximumPoolSize 相等，阻塞队列基于LinkedBlockingQueue</p><p>它是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是在线程池空闲时，即线程池中没有可运行任务时，它也不会释放工作线程，还会占用一定的系统资源</p><h2 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h2><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">SingleThreadExecutor</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">FinalizableDelegatedExecutorService</span></span><br><span class="line"><span class="type"></span>        (<span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">SingleThreadExecutor</span>(ThreadFactory threadFactory) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">FinalizableDelegatedExecutorService</span></span><br><span class="line"><span class="type"></span>        (<span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化的线程池中只有一个线程，如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行，内部使用LinkedBlockingQueue作为阻塞队列</p><h2 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h2><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">CachedThreadPool</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60</span>L, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="type">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">CachedThreadPool</span>(ThreadFactory threadFactory) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60</span>L, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="type">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个可缓存工作线程的线程池，默认存活时间60秒，线程池的线程数可达到Integer.MAX_VALUE，即2147483647，内部使用SynchronousQueue作为阻塞队列；</p><p>在没有任务执行时，当线程的空闲时间超过keepAliveTime，则工作线程将会终止，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销</p><h2 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h2><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="keyword">new</span><span class="type">ScheduledThreadPool</span>(int corePoolSize) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="keyword">new</span><span class="type">ScheduledThreadPool</span>(</span><br><span class="line">        int corePoolSize, ThreadFactory threadFactory) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ScheduledThreadPoolExecutor</span>(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p><a href="https://www.cnblogs.com/trust-freedom/p/6594270.html" target="_blank" rel="noopener">Java线程池ThreadPoolExecutor使用和分析</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      线程池
    
    </summary>
    
      <category term="java" scheme="http://langonggong.com/categories/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://langonggong.com/tags/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>词干提取器</title>
    <link href="http://langonggong.com/2019/09/21/%E8%AF%8D%E5%B9%B2%E6%8F%90%E5%8F%96%E5%99%A8/"/>
    <id>http://langonggong.com/2019/09/21/词干提取器/</id>
    <published>2019-09-21T10:07:16.000Z</published>
    <updated>2020-06-22T16:40:36.966Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大多数语言的单词都可以 词形变化 ，意味着 下列单词可以改变它们的形态用来表达不同的意思：</p><ul><li>单复数变化 ： fox 、foxes</li><li>时态变化 ： pay 、 paid 、 paying</li><li>性别变化 ： waiter 、 waitress</li><li>动词人称变化 ： hear 、 hears</li><li>代词变化 ： I 、 me 、 my</li><li>不规则变化 ： ate 、 eaten</li><li>情景变化 ： so be it 、 were it so</li></ul><h1 id="提取程度"><a href="#提取程度" class="headerlink" title="提取程度"></a>提取程度</h1><p>词干提取是一种遭受两种困扰的模糊的技术：词干弱提取和词干过度提取。</p><ul><li>词干弱提取<br>  就是无法将同样意思的单词缩减为同一个词根。例如， jumped和jumps可能被提取为 jump ， 但是 jumping 可能被提取为 jumpi 。弱词干提取会导致搜索时无法返回相关文档。</li><li>词干过度提取<br>  就是无法将不同含义的单词分开。例如，general和generate可能都被提取为 gener 。 词干过度提取会降低精准度：不相干的文档会在不需要他们返回的时候返回。</li></ul><h1 id="提取方式"><a href="#提取方式" class="headerlink" title="提取方式"></a>提取方式</h1><h2 id="基于算法"><a href="#基于算法" class="headerlink" title="基于算法"></a>基于算法</h2><p>Elasticsearch 中的大部分 stemmers （词干提取器）是基于算法的，它们提供了一系列规则用于将一个词提取为它的词根形式，例如剥离复数词末尾的 s 或 es 。提取单词词干时并不需要知道该词的任何信息。</p><ul><li>优点<br>  可以作为插件使用，速度快，占用内存少，有规律的单词处理效果好</li><li>缺点<br>  没规律的单词例如 be 、 are 、和 am ，或 mice 和 mouse 效果不好</li></ul><h2 id="基于字典"><a href="#基于字典" class="headerlink" title="基于字典"></a>基于字典</h2><p>字典词干提取器在工作机制上与算法化词干提取器完全不同。 不同于应用一系列标准规则到每个词上，字典词干提取器只是简单地在字典里查找词。理论上可以给出比算法化词干提取器更好的结果。一个字典词干提取器应当可以：</p><ul><li>返回不规则形式如feet和mice的正确词干</li><li>区分出词形相似但词义不同的情形，比如organ and organization</li></ul><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>实践中一个好的算法化词干提取器一般优于一个字典词干提取器。应该有以下两大原因：</p><ul><li>字典质量<br>  字典需要保持最新，这是一项很耗时的任务。通常等到一个字典变得好用后，其中的部分内容已经过时。字典词干提取器对于字典中不存在的词无能为力。而一个基于算法的词干提取器，则会继续应用之前的相同规则，结果可能正确或错误。</li><li>大小与性能<br>  字典词干提取器需要加载所有词汇、 所有前缀，以及所有后缀到内存中。这会显著地消耗内存。找到一个词的正确词干，一般比算法化词干提取器的相同过程更加复杂。依赖于不同的字典质量，去除前后缀的过程可能会更加高效或低效。低效的情形可能会明显地拖慢整个词干提取过程。</li></ul><h1 id="提取器种类"><a href="#提取器种类" class="headerlink" title="提取器种类"></a>提取器种类</h1><ul><li>Porter Stem Token Filter<br>  porter_stem语汇单元过滤器（token filter）。<br>  最早的一个基于算法 的英文词干提取器，提取程度较为激进。</li><li>KStem Token Filter<br>  kstem语汇单元过滤器（token filter）。<br>  是一款合并了词干提取算法和内置词典的英语分词过滤器。为了避免模糊词不正确提取，这个词典包含一系列根词单词和特例单词。 kstem分词过滤器相较于Porter词干提取器而言不那么激进。</li><li>Hunspell 词干提取器<br>  基于词典提取词干的hunspell语汇单元过滤器（token filter）. Hunspell hunspell.github.io 是一个 Open Office、LibreOffice、Chrome、Firefox、Thunderbird 等众多其它开源项目都在使用的拼写检查器。Hunspell词典会占用几兆的内存，它不仅能移除前缀还能移除后缀。<br>  一个 Hunspell 词典由两个文件组成 — 具有相同的文件名和两个不同的后缀 — 如 en_US—和下面的两个后缀的其中一个：<ul><li>.dic<br>  包含所有词根，采用字母顺序，再加上一个代表所有可能前缀和后缀的代码表 【集体称之为词缀( affixes 】</li><li>.aff<br>  包含实际 .dic 文件每一行代码表对应的前缀和后缀转换</li></ul></li><li>其他<br>  Lovins 提取器、Porter 提取器、Porter2 提取器等</li></ul><h1 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h1><p>推荐的词干提取器也许不适用所有场景。 关于哪个是最好的词干提取器，不存在一个唯一的正确答案 — 它要看你具体的需求。 这里有3个方面的因素需要考虑在内： 性能、质量、程度。</p><h2 id="提取性能"><a href="#提取性能" class="headerlink" title="提取性能"></a>提取性能</h2><p>算法提取器一般来说比Hunspell提取器快4到5倍。Hunspell 提取器需要加载所有的词典、前缀和后缀表到内存，可能需要消耗几兆的内存。而算法提取器，由一点点代码组成，只需要使用很少内存。</p><h2 id="提取质量"><a href="#提取质量" class="headerlink" title="提取质量"></a>提取质量</h2><p>最日常用语使用的词往往不规则。一个基于词典的提取器往往取决于词典的好坏。如果 Hunspell 碰到的这个词不在词典里，那它什么也不能做。 Hunspell 需要一个广泛的、高质量的、最新的词典以产生好的结果；这样级别的词典可谓少之又少。 另一方面，一个算法提取器，将愉快的处理新词而不用为新词重新设计算法。<br>如果一个好的算法词干提取器可用于你的语言，那明智的使用它而不是 Hunspell。它会更快并且消耗更少内存，并且会产生和通常一样好或者比 Hunspell 等价的结果.<br>如果精度和可定制性对你很重要，那么你需要（和有精力）来维护一个自定义的词典，那么 Hunspell 会给你比算法提取器更大的灵活性</p><h2 id="提取程度-1"><a href="#提取程度-1" class="headerlink" title="提取程度"></a>提取程度</h2><p>是否想要积极提取还是轻量提取取决于你的场景。如果你的搜索结果是要用于聚类算法，你可能会希望匹配的更广泛一点（因此，提取力度要更大一点）。 如果你的搜索结果是面向最终用户，轻量的提取一般会产生更好的结果。对搜索来说，将名称和形容词提干比动词提干更重要，当然这也取决于语言。</p><p>另外一个要考虑的因素就是你的文档集的大小。 一个只有 10,000 个产品的小集合，你可能要更激进的提干来确保至少匹配到一些文档。 如果你的文档集很大，使用轻量的弱提取可能会得到更好的匹配结果。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/stemming.html" target="_blank" rel="noopener">将单词还原为词根</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      词干提取器
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://langonggong.com/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://langonggong.com/tags/Elasticsearch/"/>
    
      <category term="分析器" scheme="http://langonggong.com/tags/%E5%88%86%E6%9E%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>ES分析器</title>
    <link href="http://langonggong.com/2019/09/15/ES%E5%88%86%E6%9E%90%E5%99%A8/"/>
    <id>http://langonggong.com/2019/09/15/ES分析器/</id>
    <published>2019-09-14T17:09:03.000Z</published>
    <updated>2020-06-22T16:40:36.956Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h1><h1 id="CharFilter"><a href="#CharFilter" class="headerlink" title="CharFilter"></a>CharFilter</h1><h1 id="Tokenizer"><a href="#Tokenizer" class="headerlink" title="Tokenizer"></a>Tokenizer</h1><h1 id="Tokenizer-Filter"><a href="#Tokenizer-Filter" class="headerlink" title="Tokenizer Filter"></a>Tokenizer Filter</h1><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><h3 id="Lowercase-Token-Filter"><a href="#Lowercase-Token-Filter" class="headerlink" title="Lowercase Token Filter"></a>Lowercase Token Filter</h3><p>小写过滤器。将标记token规范化为小写</p><h3 id="Uppercase-Token-Filter"><a href="#Uppercase-Token-Filter" class="headerlink" title="Uppercase Token Filter"></a>Uppercase Token Filter</h3><p>大写过滤器。将术语转写成大写</p><h3 id="Synonym-Token-Filter"><a href="#Synonym-Token-Filter" class="headerlink" title="Synonym Token Filter"></a>Synonym Token Filter</h3><p>同义词过滤器</p><h3 id="ASCII-Folding-Token-Filter"><a href="#ASCII-Folding-Token-Filter" class="headerlink" title="ASCII Folding Token Filter"></a>ASCII Folding Token Filter</h3><p>ASCII码折叠过滤器。asciifolding过滤器将ASCII码不在ASCII表前127内的字母、数字和Unicode符号转换为ASCII等效字符(如果存在的话)</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//新建索引</span><br><span class="line">PUT asciifold_example</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"settings"</span>: &#123;</span><br><span class="line">        <span class="string">"analysis"</span>: &#123;</span><br><span class="line">            <span class="string">"analyzer"</span>: &#123;</span><br><span class="line">                <span class="string">"my_analyzer"</span>: &#123;</span><br><span class="line">                    <span class="string">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">                    <span class="string">"filter"</span>: [</span><br><span class="line">                        <span class="string">"my_ascii_folding"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"filter"</span>: &#123;</span><br><span class="line">                <span class="string">"my_ascii_folding"</span>: &#123;</span><br><span class="line">                    <span class="string">"type"</span>: <span class="string">"asciifolding"</span>,</span><br><span class="line">                    <span class="string">"preserve_original"</span>: false</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提交文本</span></span><br><span class="line">POST asciifold_example/_analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"analyzer"</span>: <span class="string">"my_analyzer"</span>,</span><br><span class="line">    <span class="string">"text"</span>: <span class="string">"Êê Ẑẑ Ĉĉ Ŝŝ Ŋŋ Öö"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取结果</span></span><br><span class="line">[<span class="meta">Ee,Zz,Cc,Ss,Nn,Oo</span>]</span><br></pre></td></tr></table></figure><h3 id="词干提取器"><a href="#词干提取器" class="headerlink" title="词干提取器"></a>词干提取器</h3><p><a href="http://langonggong.com/2019/09/21/%E8%AF%8D%E5%B9%B2%E6%8F%90%E5%8F%96%E5%99%A8/">词干提取器</a>将一个词提取为它的词根形式</p><ul><li>Porter Stem Token Filter</li><li>Stemmer Token Filter：包含了大多数词干提取器</li><li>KStem Token Filter</li><li>Snowball Token Filter<h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2></li></ul><h3 id="Length-Token-Filter"><a href="#Length-Token-Filter" class="headerlink" title="Length Token Filter"></a>Length Token Filter</h3><p>长度过滤器，会移除token流中太长或太短的标记</p><h3 id="Stop-Token-Filter"><a href="#Stop-Token-Filter" class="headerlink" title="Stop Token Filter"></a>Stop Token Filter</h3><p>停用词过滤器，会移除自定义或指定文件中的停用词</p><h3 id="Predicate-Token-Filter"><a href="#Predicate-Token-Filter" class="headerlink" title="Predicate Token Filter"></a>Predicate Token Filter</h3><p>根据脚本里面的表达式来判断是否过滤掉某个词条，例如使用standard分析器后的”What Flapdoodle”分隔成两个词条，只保留长度大于5的词条，则”What”将被删除</p><h2 id="切割"><a href="#切割" class="headerlink" title="切割"></a>切割</h2><h3 id="Word-Delimiter-Token-Filter"><a href="#Word-Delimiter-Token-Filter" class="headerlink" title="Word Delimiter Token Filter"></a>Word Delimiter Token Filter</h3><p>分隔符过滤器，根据一定的规则将单词分割为多个子字符串，或者删除单词中的分隔符。例如：</p><ul><li>generate_word_parts<br>  “Power-Shot”, “(Power,Shot)” -&gt; “Power” “Shot”</li><li>generate_number_parts<br>  将数字拆出来：”500-42” -&gt; “500” “42”</li><li>catenate_words<br>  将单词去掉分隔符后合并：”wi-fi” -&gt; “wifi”</li><li>其他</li></ul><h3 id="Edge-NGram-Token-Filter"><a href="#Edge-NGram-Token-Filter" class="headerlink" title="Edge NGram Token Filter"></a>Edge NGram Token Filter</h3><p>n-gram 看成一个在词语上 滑动窗口 ， n 代表这个 “窗口” 的长度。如果我们要 n-gram quick 这个词 —— 它的结果取决于 n 的选择长度：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">长度 <span class="number">1</span>（unigram）： <span class="string">[ q, u, i, c, k ]</span></span><br><span class="line">长度 <span class="number">2</span>（bigram）： <span class="string">[ qu, ui, ic, ck ]</span></span><br><span class="line">长度 <span class="number">3</span>（trigram）： <span class="string">[ qui, uic, ick ]</span></span><br><span class="line">长度 <span class="number">4</span>（four-gram）：<span class="string">[ quic, uick ]</span></span><br><span class="line">长度 <span class="number">5</span>（five-gram）：<span class="string">[ quick ]</span></span><br></pre></td></tr></table></figure><p>朴素的n-gram对词语内部的匹配非常有用，即在 <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/ngrams-compound-words.html" target="_blank" rel="noopener">Ngram匹配复合词</a> 介绍的那样。但对于输入即搜索（search-as-you-type）这种应用场景，我们会使用一种特殊的n-gram称为边界n-grams（edge n-grams）。所谓的边界n-gram是说它会固定词语开始的一边，以单词quick为例，它的边界n-gram的结果为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[q,qu,qui,quic,quick]</span><br></pre></td></tr></table></figure><p>创建索引、实例化 token 过滤器和分析器的完整示例如下</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"settings"</span>: &#123;</span><br><span class="line">        <span class="string">"number_of_shards"</span>: <span class="number">1</span>, </span><br><span class="line">        <span class="string">"analysis"</span>: &#123;</span><br><span class="line">            <span class="string">"filter"</span>: &#123;</span><br><span class="line">                <span class="string">"autocomplete_filter"</span>: &#123; </span><br><span class="line">                    <span class="string">"type"</span>:     <span class="string">"edge_ngram"</span>,</span><br><span class="line">                    <span class="string">"min_gram"</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="string">"max_gram"</span>: <span class="number">20</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"analyzer"</span>: &#123;</span><br><span class="line">                <span class="string">"autocomplete"</span>: &#123;</span><br><span class="line">                    <span class="string">"type"</span>:      <span class="string">"custom"</span>,</span><br><span class="line">                    <span class="string">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">                    <span class="string">"filter"</span>: [</span><br><span class="line">                        <span class="string">"lowercase"</span>,</span><br><span class="line">                        <span class="string">"autocomplete_filter"</span> </span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以拿 analyze API 测试这个新的分析器确保它行为正确：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /my_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"text"</span>: <span class="string">"quick brown"</span>,</span><br><span class="line">  <span class="string">"analyzer"</span>: <span class="string">"autocomplete"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果表明分析器能正确工作，并返回以下词：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[q,qu,qui,quic,quick,b,br,bro,brow,brown]</span><br></pre></td></tr></table></figure><p>可以用 update-mapping API 将这个分析器应用到具体字段并添加数据</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/_mapping/</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"properties"</span>: &#123;</span><br><span class="line">    <span class="string">"name"</span>: &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">      <span class="string">"analyzer"</span>: <span class="string">"autocomplete"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST /my_index/_bulk</span><br><span class="line">&#123;<span class="string">"index"</span>:&#123;<span class="string">"_id"</span>:<span class="number">1</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"Brown foxes"</span>&#125;</span><br><span class="line">&#123;<span class="string">"index"</span>:&#123;<span class="string">"_id"</span>:<span class="number">2</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"Yellow furballs"</span>&#125;</span><br></pre></td></tr></table></figure><p>如果使用简单 match 查询测试查询 “brown fo” ,可以看到两个文档同时都能匹配，尽管 Yellow furballs 这个文档并不包含 brown 和 fo</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_validate/query?explain</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span>: &#123;</span><br><span class="line">        <span class="string">"match"</span>: &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"brown fo"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用validate-query API 分析：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_validate/query?explain</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"match"</span>: &#123;</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"brown fo"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>explanation 表明查询会查找边界 n-grams 里的每个词：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">name</span>:b <span class="built_in">name</span>:br <span class="built_in">name</span>:bro <span class="built_in">name</span>:brow <span class="built_in">name</span>:brown <span class="built_in">name</span>:f <span class="built_in">name</span>:fo</span><br></pre></td></tr></table></figure><p>name:f 条件可以满足第二个文档</p><p>我们需要保证倒排索引表中包含边界 n-grams 的每个词，但是我们只想匹配用户输入的完整词组（ brown 和 fo ）， 可以通过在索引时使用 autocomplete 分析器，并在搜索时使用 standard 标准分析器来实现这种想法，只要改变查询使用的搜索分析器 analyzer 参数即可：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"match"</span>: &#123;</span><br><span class="line">      <span class="string">"name"</span>: &#123;</span><br><span class="line">        <span class="string">"query"</span>: <span class="string">"brown fo"</span>,</span><br><span class="line">        <span class="string">"analyzer"</span>: <span class="string">"standard"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>换种方式，我们可以在映射中，为name字段分别指定index_analyzer和 earch_analyzer。因为我们只想改变 search_analyzer，这里只要更新现有的映射而不用对数据重新创建索引：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/_mapping</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"properties"</span>: &#123;</span><br><span class="line">    <span class="string">"name"</span>: &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">      <span class="string">"analyzer"</span>: <span class="string">"autocomplete"</span>,</span><br><span class="line">      <span class="string">"search_analyzer"</span>: <span class="string">"standard"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果再次请求 validate-query API ，当前的解释为：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">name</span>:brown <span class="built_in">name</span>:fo</span><br></pre></td></tr></table></figure><p>再次执行查询就能正确返回 Brown foxes 这个文档。</p><h3 id="Shingle-Token-Filter（滑动窗口）"><a href="#Shingle-Token-Filter（滑动窗口）" class="headerlink" title="Shingle Token Filter（滑动窗口）"></a>Shingle Token Filter（滑动窗口）</h3><p>使用 TF/IDF 的标准全文检索将文档或者文档中的字段作一大袋的词语处理。 match 查询可以告知我们这大袋子中是否包含查询的词条，但却无法告知词语之间的关系。</p><p>思考下面这几个句子的不同：</p><ul><li>Sue ate the alligator.</li><li>The alligator ate Sue.</li><li>Sue never goes anywhere without her alligator-skin purse.</li></ul><p>用match搜索sue alligator上面的三个文档都会得到匹配，但它却不能确定这两个词是否只来自于一种语境，甚至都不能确定是否来自于同一个段落。</p><p>理解分词之间的关系是一个复杂的难题，我们也无法通过换一种查询方式去解决。但我们至少可以通过出现在彼此附近或者仅仅是彼此相邻的分词来判断一些似乎相关的分词。</p><p>对句子Sue ate the alligator ，不仅要将每一个单词（或者 unigram ）作为词项索引<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"sue"</span>, <span class="string">"ate"</span>, <span class="string">"the"</span>, <span class="string">"alligator"</span>]</span><br></pre></td></tr></table></figure></p><p>也要将每个单词以及它的邻近词作为单个词项索引：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"sue ate"</span>, <span class="string">"ate the"</span>, <span class="string">"the alligator"</span>]</span><br></pre></td></tr></table></figure></p><p>这些单词对（或者 bigrams ）被称为 shingles 。<br>你也可以索引三个单词（ trigrams ）。Trigrams 提供了更高的精度，但是也大大增加了索引中唯一词项的数量。在大多数情况下，Bigrams 就够了。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"sue ate the"</span>, <span class="string">"ate the alligator"</span>]</span><br></pre></td></tr></table></figure></p><p>只有当用户输入的查询内容和在原始文档中顺序相同时，shingles 才是有用的；对 sue alligator 的查询可能会匹配到单个单词，但是不会匹配任何 shingles 。只是索引 bigrams 是不够的；我们仍然需要 unigrams ，但可以将匹配 bigrams 作为增加相关度评分的信号。</p><p>将它们分开保存在能被独立查询的字段会更清晰：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">PUT /shingle_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"settings"</span>: &#123;</span><br><span class="line">    <span class="string">"number_of_shards"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"analysis"</span>: &#123;</span><br><span class="line">      <span class="string">"filter"</span>: &#123;</span><br><span class="line">        <span class="string">"my_shingle_filter"</span>: &#123;</span><br><span class="line">          <span class="string">"type"</span>: <span class="string">"shingle"</span>,</span><br><span class="line">          <span class="string">"min_shingle_size"</span>: <span class="number">2</span>,</span><br><span class="line">          <span class="string">"max_shingle_size"</span>: <span class="number">2</span>,</span><br><span class="line">          <span class="string">"output_unigrams"</span>: false</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="string">"my_shingle_analyzer"</span>: &#123;</span><br><span class="line">          <span class="string">"type"</span>: <span class="string">"custom"</span>,</span><br><span class="line">          <span class="string">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">          <span class="string">"filter"</span>: [</span><br><span class="line">            <span class="string">"lowercase"</span>,</span><br><span class="line">            <span class="string">"my_shingle_filter"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用 analyze API 测试下分析器：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /shingle_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"analyzer"</span>: <span class="string">"my_shingle_analyzer"</span>,</span><br><span class="line">  <span class="string">"text"</span>: <span class="string">"Sue ate the alligator"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>得到了 3 个词项：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"sue ate"</span>, <span class="string">"ate the"</span>, <span class="string">"the alligator"</span>]</span><br></pre></td></tr></table></figure></p><p>将unigrams和bigrams分开索引更清晰，所以title字段将创建成一个多字段：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PUT /shingle_index/_mapping/</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"properties"</span>: &#123;</span><br><span class="line">    <span class="string">"title"</span>: &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">      <span class="string">"fields"</span>: &#123;</span><br><span class="line">        <span class="string">"shingles"</span>: &#123;</span><br><span class="line">          <span class="string">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">          <span class="string">"analyzer"</span>: <span class="string">"my_shingle_analyzer"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>索引以下示例文档：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /shingle_index/_doc/_bulk</span><br><span class="line">&#123;<span class="string">"index"</span>:&#123;<span class="string">"_id"</span>:<span class="number">1</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">"title"</span>:<span class="string">"Sue ate the alligator"</span>&#125;</span><br><span class="line">&#123;<span class="string">"index"</span>:&#123;<span class="string">"_id"</span>:<span class="number">2</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">"title"</span>:<span class="string">"The alligator ate Sue"</span>&#125;</span><br><span class="line">&#123;<span class="string">"index"</span>:&#123;<span class="string">"_id"</span>:<span class="number">3</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">"title"</span>:<span class="string">"Sue never goes anywhere without her alligator skin purse"</span>&#125;</span><br></pre></td></tr></table></figure></p><p>使用The hungry alligator ate Sue 进行简单 match 查询：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GET /shingle_index/_doc/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"match"</span>: &#123;</span><br><span class="line">      <span class="string">"title"</span>: <span class="string">"the hungry alligator ate sue"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个查询返回了所有的三个文档， 但是注意文档 1 和 2 有相同的相关度评分因为他们包含了相同的单词：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"total"</span>: &#123;</span><br><span class="line">        <span class="attr">"value"</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">"relation"</span>: <span class="string">"eq"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"max_score"</span>: <span class="number">1.3721708</span>,</span><br><span class="line">    <span class="attr">"hits"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"_index"</span>: <span class="string">"shingle_index"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">            <span class="attr">"_score"</span>: <span class="number">1.3721708</span>,</span><br><span class="line">            <span class="attr">"_source"</span>: &#123;</span><br><span class="line">                <span class="attr">"title"</span>: <span class="string">"Sue ate the alligator"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"_index"</span>: <span class="string">"shingle_index"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>: <span class="string">"2"</span>,</span><br><span class="line">            <span class="attr">"_score"</span>: <span class="number">1.3721708</span>,</span><br><span class="line">            <span class="attr">"_source"</span>: &#123;</span><br><span class="line">                <span class="attr">"title"</span>: <span class="string">"The alligator ate Sue"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"_index"</span>: <span class="string">"shingle_index"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>: <span class="string">"3"</span>,</span><br><span class="line">            <span class="attr">"_score"</span>: <span class="number">0.2152618</span>,</span><br><span class="line">            <span class="attr">"_source"</span>: &#123;</span><br><span class="line">                <span class="attr">"title"</span>: <span class="string">"Sue never goes anywhere without her alligator skin purse"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在在查询里添加 shingles 字段，为了提高相关度评分，我们仍然需要将基本title字段包含到查询中：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET /shingle_index/_doc/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"bool"</span>: &#123;</span><br><span class="line">      <span class="string">"must"</span>: &#123;</span><br><span class="line">        <span class="string">"match"</span>: &#123;</span><br><span class="line">          <span class="string">"title"</span>: <span class="string">"the hungry alligator ate sue"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"should"</span>: &#123;</span><br><span class="line">        <span class="string">"match"</span>: &#123;</span><br><span class="line">          <span class="string">"title.shingles"</span>: <span class="string">"the hungry alligator ate sue"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>仍然匹配到了所有的 3 个文档， 但是文档 2 现在排到了第一名因为它匹配了 shingled 词项 ate sue：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"total"</span>: &#123;</span><br><span class="line">        <span class="attr">"value"</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">"relation"</span>: <span class="string">"eq"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"max_score"</span>: <span class="number">3.6694741</span>,</span><br><span class="line">    <span class="attr">"hits"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"_index"</span>: <span class="string">"shingle_index"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>: <span class="string">"2"</span>,</span><br><span class="line">            <span class="attr">"_score"</span>: <span class="number">3.6694741</span>,</span><br><span class="line">            <span class="attr">"_source"</span>: &#123;</span><br><span class="line">                <span class="attr">"title"</span>: <span class="string">"The alligator ate Sue"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"_index"</span>: <span class="string">"shingle_index"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">            <span class="attr">"_score"</span>: <span class="number">1.3721708</span>,</span><br><span class="line">            <span class="attr">"_source"</span>: &#123;</span><br><span class="line">                <span class="attr">"title"</span>: <span class="string">"Sue ate the alligator"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"_index"</span>: <span class="string">"shingle_index"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>: <span class="string">"3"</span>,</span><br><span class="line">            <span class="attr">"_score"</span>: <span class="number">0.2152618</span>,</span><br><span class="line">            <span class="attr">"_source"</span>: &#123;</span><br><span class="line">                <span class="attr">"title"</span>: <span class="string">"Sue never goes anywhere without her alligator skin purse"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="Conditional-Token-Filter"><a href="#Conditional-Token-Filter" class="headerlink" title="Conditional Token Filter"></a>Conditional Token Filter</h3><p>根据表达式条件决定是否使用某个其他的过滤器，例如根据一个词条中字符的个数来判断是否要使用Lowercase Token Filter过滤器</p><h3 id="Keyword-Marker-Token-Filter"><a href="#Keyword-Marker-Token-Filter" class="headerlink" title="Keyword Marker Token Filter"></a>Keyword Marker Token Filter</h3><p>保护某些单词不被stemmers（词干提取器）处理，可以自定义单词列表或者指定文件路径</p><h3 id="Keyword-Repeat-Token-Filter"><a href="#Keyword-Repeat-Token-Filter" class="headerlink" title="Keyword Repeat Token Filter"></a>Keyword Repeat Token Filter</h3><p>将每个输入的token复制，生成keyword和non-keyword两个。一般用于交给词干提取器处理，然后去重处理</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PUT /keyword_repeat_example</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"settings"</span>: &#123;</span><br><span class="line">    <span class="string">"analysis"</span>: &#123;</span><br><span class="line">      <span class="string">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="string">"stemmed_and_unstemmed"</span>: &#123;</span><br><span class="line">          <span class="string">"type"</span>: <span class="string">"custom"</span>,</span><br><span class="line">          <span class="string">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">          <span class="string">"filter"</span>: [</span><br><span class="line">            <span class="string">"lowercase"</span>,</span><br><span class="line">            <span class="string">"keyword_repeat"</span>,</span><br><span class="line">            <span class="string">"porter_stem"</span>,</span><br><span class="line">            <span class="string">"unique_stem"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"filter"</span>: &#123;</span><br><span class="line">        <span class="string">"unique_stem"</span>: &#123;</span><br><span class="line">          <span class="string">"type"</span>: <span class="string">"unique"</span>,</span><br><span class="line">          <span class="string">"only_on_same_position"</span>: true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例如下：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST <span class="regexp">/keyword_repeat_example/</span>_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"analyzer"</span>: <span class="string">"stemmed_and_unstemmed"</span>,</span><br><span class="line">  <span class="string">"text"</span>: <span class="string">"I like cats"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"tokens"</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"token"</span> : <span class="string">"i"</span>,</span><br><span class="line">      <span class="attr">"start_offset"</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"end_offset"</span> : <span class="number">1</span>,</span><br><span class="line">      <span class="attr">"type"</span> : <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">      <span class="attr">"position"</span> : <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"token"</span> : <span class="string">"like"</span>,</span><br><span class="line">      <span class="attr">"start_offset"</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"end_offset"</span> : <span class="number">6</span>,</span><br><span class="line">      <span class="attr">"type"</span> : <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">      <span class="attr">"position"</span> : <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"token"</span> : <span class="string">"cats"</span>,</span><br><span class="line">      <span class="attr">"start_offset"</span> : <span class="number">7</span>,</span><br><span class="line">      <span class="attr">"end_offset"</span> : <span class="number">11</span>,</span><br><span class="line">      <span class="attr">"type"</span> : <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">      <span class="attr">"position"</span> : <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"token"</span> : <span class="string">"cat"</span>,</span><br><span class="line">      <span class="attr">"start_offset"</span> : <span class="number">7</span>,</span><br><span class="line">      <span class="attr">"end_offset"</span> : <span class="number">11</span>,</span><br><span class="line">      <span class="attr">"type"</span> : <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">      <span class="attr">"position"</span> : <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      ES分析器，由字符过滤器、分词器、分词过滤器组成
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://langonggong.com/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://langonggong.com/tags/Elasticsearch/"/>
    
      <category term="分析器" scheme="http://langonggong.com/tags/%E5%88%86%E6%9E%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>synchronized的内存语义</title>
    <link href="http://langonggong.com/2019/07/01/synchronized%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89/"/>
    <id>http://langonggong.com/2019/07/01/synchronized的内存语义/</id>
    <published>2019-07-01T15:51:37.000Z</published>
    <updated>2020-06-22T16:40:36.961Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中<br>而线程获取锁，JMM会把其对应内存置为无效，从而使被监视器保护的临界区代码必须要从主内存去读取共享变量</p>]]></content>
    
    <summary type="html">
    
      synchronized的内存语义
    
    </summary>
    
      <category term="java" scheme="http://langonggong.com/categories/java/"/>
    
      <category term="内存模型" scheme="http://langonggong.com/categories/java/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
    
      <category term="java" scheme="http://langonggong.com/tags/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java内存模型" scheme="http://langonggong.com/tags/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="synchronized" scheme="http://langonggong.com/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>SQL优化</title>
    <link href="http://langonggong.com/2018/12/02/SQL%E4%BC%98%E5%8C%96/"/>
    <id>http://langonggong.com/2018/12/02/SQL优化/</id>
    <published>2018-12-02T12:21:43.000Z</published>
    <updated>2020-06-22T16:40:36.957Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><ul><li>字段类型转换导致不用索引，如字符串类型的不用引号，数字类型的用引号等，这有可能会用不到索引导致全表扫描；</li><li>mysql 不支持函数转换，所以字段前面不能加函数，否则这将用不到索引；</li><li>不要在字段前面加减运算；</li><li>字符串比较长的可以考虑索引一部份减少索引文件大小，提高写入效率；</li><li>like % 在前面用不到索引；</li><li>根据联合索引的第二个及以后的字段单独查询用不到索引；</li><li>不要使用 select *；</li><li>排序请尽量使用升序 ;</li><li>or 的查询尽量用 union 代替 （Innodb）；</li><li>复合索引高选择性的字段排在前面；</li><li>order by / group by 字段包括在索引当中减少排序，效率会更高。</li></ul>]]></content>
    
    <summary type="html">
    
      SQL优化
    
    </summary>
    
      <category term="mysql" scheme="http://langonggong.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://langonggong.com/tags/mysql/"/>
    
      <category term="DB" scheme="http://langonggong.com/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB锁</title>
    <link href="http://langonggong.com/2018/11/27/InnoDB%E9%94%81/"/>
    <id>http://langonggong.com/2018/11/27/InnoDB锁/</id>
    <published>2018-11-26T16:00:41.000Z</published>
    <updated>2020-06-22T16:40:36.956Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><p>事务是由一组SQL语句组成的逻辑处理单元，事务具有以下4个属性，通常简称为事务的ACID属性。</p><ul><li>原子性（Atomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行</li><li>一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的</li><li>隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然</li><li>持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持</li></ul><h2 id="事务并发带来的问题"><a href="#事务并发带来的问题" class="headerlink" title="事务并发带来的问题"></a>事务并发带来的问题</h2><ul><li>更新丢失（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题－－最后的更 新覆盖了由其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文 档。最后保存其更改副本的编辑人员覆盖另一个编辑人员所做的更改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题</li><li>脏读（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加 控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做”脏读”</li><li>不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”</li><li>幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”</li></ul><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。“脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。</p><p>数据库实现事务隔离的方式，基本上可分为以下两种</p><ul><li>在读取数据前，对其加锁，阻止其他事务对数据进行修改。</li><li>不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot)，并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度来看，好像是数据库可以提供同一数据的多个版本，因此，这种技术叫做数据多版本并发控制（MultiVersion Concurrency Control，简称MVCC或MCC），也经常称为多版本数据库</li></ul><p>4种隔离级别比较</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">读数据一致性</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">未提交读（Read uncommitted）</td><td style="text-align:center">最低级别，只能保证不读取物理上损坏的数据</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">已提交度（Read committed）</td><td style="text-align:center">语句级</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">可重复读（Repeatable read</td><td style="text-align:center">事务级</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">序列化（Serializable）</td><td style="text-align:center">最高级别，事务级</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">否</td></tr></tbody></table></div><p>各具体数据库并不一定完全实现了上述4个隔离级别，MySQL 支持全部4个隔离级别，但在具体实现时，有一些特点，比如在一些隔离级别下是采用MVCC一致性读，但某些情况下又不是。</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h2><p>按锁的粒度划分</p><ul><li>行级锁：行级锁分为共享锁和排它锁。行级锁是Mysql中锁定粒度最细的锁。InnoDB引擎支持行级锁和表级锁，只有在通过索引条件检索数据的时候，才使用行级锁，否就使用表级锁。行级锁开销大，加锁慢，锁定粒度最小，发生锁冲突概率最低，并发度最高</li><li>表级锁：表级锁分为表共享锁和表独占锁。表级锁开销小，加锁快，锁定粒度大、发生锁冲突最高，并发度最低</li><li>页级锁：页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁。 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li><li>间隙锁（Next-Key）：对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓 的间隙锁（Next-Key锁）</li></ul><p>按锁级别划分</p><p>InnoDB实现了以下两种类型的行锁</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li><li>排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li></ul><p>另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。</p><ul><li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li><li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</li></ul><p>InnoDB行锁模式兼容性列表</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">X</th><th style="text-align:center">IX</th><th style="text-align:center">S</th><th style="text-align:center">IS</th></tr></thead><tbody><tr><td style="text-align:center">X</td><td style="text-align:center">冲突</td><td style="text-align:center">冲突</td><td style="text-align:center">冲突</td><td style="text-align:center">冲突</td></tr><tr><td style="text-align:center">IX</td><td style="text-align:center">冲突</td><td style="text-align:center">兼容</td><td style="text-align:center">冲突</td><td style="text-align:center">兼容</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">冲突</td><td style="text-align:center">冲突</td><td style="text-align:center">兼容</td><td style="text-align:center">兼容</td></tr><tr><td style="text-align:center">IS</td><td style="text-align:center">冲突</td><td style="text-align:center">兼容</td><td style="text-align:center">兼容</td><td style="text-align:center">兼容</td></tr></tbody></table></div><p>如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。</p><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><ul><li>在不通过索引条件查询的时候，InnoDB使用的是表锁，而不是行锁</li><li>由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的</li><li>当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁</li><li>即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比 如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁</li><li>检索值的数据类型与索引字段不同，虽然MySQL能够进行数据类型转换，但却不会使用索引，从而导致InnoDB使用表锁</li></ul><h2 id="间隙锁（Next-Key）"><a href="#间隙锁（Next-Key）" class="headerlink" title="间隙锁（Next-Key）"></a>间隙锁（Next-Key）</h2><p>当用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件 的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，或者叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁。</p><p>InnoDB 使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求；另外一方面，是为了满足其恢复和复制的需要</p><p>举例：</p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span>  emp <span class="keyword">where</span> <span class="keyword">id</span> &gt; <span class="number">100</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>是一个范围条件的检索，InnoDB不仅会对符合条件的记录加锁，也会对id大于101（这些记录并不存在）的“间隙”加锁.要是不使用间隙锁，如果其他事务插入了id大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读</p><h3 id="恢复和复制"><a href="#恢复和复制" class="headerlink" title="恢复和复制"></a>恢复和复制</h3><p>对于“insert  into target_tab select * from source_tab where …”和“create  table target_tab …select … From  source_tab where …(CTAS)”这种SQL语句，MySQL对这种SQL语句做了特别处理。<br>因为不加锁的话，如果在上述语句执行过程中，其他事务对source_tab做了更新操作，造成不符合target_tab的数据在source_tab中变成了符合target_tab，就可能导致数据恢复的结果错误</p><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p>对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择InnoDB表的理由。但在个别特殊事务中，也可以考虑使用表级锁。</p><ul><li>事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。</li><li>事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。</li></ul><h2 id="锁在不同条件的差异"><a href="#锁在不同条件的差异" class="headerlink" title="锁在不同条件的差异"></a>锁在不同条件的差异</h2><p>InnoDB在不同隔离级别下的一致性读及锁的差异</p><table style="text-align:center">   <tr>      <td> SQL </td>      <td>条件</td>      <td>Read Uncommited</td>      <td>Read Commited</td>      <td>Repeatable Read</td>      <td> Serializable</td>   </tr>   <tr>      <td rowspan="2"> select </td>      <td>相等</td>      <td>None locks</td>      <td>Consisten read/None lock</td>      <td>Consisten read/None lock</td>      <td> Share locks</td>   </tr>   <tr>      <td>范围</td>      <td>None locks</td>      <td>Consisten read/None lock</td>      <td>Consisten read/None lock</td>      <td> Share Next-Key</td>   </tr>   <tr>      <td rowspan="2"> update </td>      <td>相等</td>      <td>exclusive locks</td>      <td>exclusive locks</td>      <td>exclusive locks</td>      <td>exclusive locks</td>   </tr>   <tr>      <td>范围</td>      <td>exclusive next-key</td>      <td>exclusive next-key</td>      <td>exclusive next-key</td>      <td>exclusive next-key</td>   </tr>   <tr>      <td> Insert </td>      <td>N/A</td>      <td>exclusive locks</td>      <td>exclusive locks</td>      <td>exclusive locks</td>      <td>exclusive locks</td>   </tr>   <tr>      <td rowspan="2">replace</td>      <td>无键冲突</td>      <td>exclusive locks</td>      <td>exclusive locks</td>      <td>exclusive locks</td>      <td>exclusive locks</td>   </tr>   <tr>      <td>键冲突</td>      <td>exclusive next-key</td>      <td>exclusive next-key</td>      <td>exclusive next-key</td>      <td>exclusive next-key</td>   </tr>   <tr>      <td rowspan="2"> delete </td>      <td>相等</td>      <td>exclusive locks</td>      <td>exclusive locks</td>      <td>exclusive locks</td>      <td>exclusive locks</td>   </tr>   <tr>      <td>范围</td>      <td>exclusive next-key</td>      <td>exclusive next-key</td>      <td>exclusive next-key</td>      <td>exclusive next-key</td>   </tr>   <tr>      <td rowspan="2"> Select ... from ... Lock in share mode </td>      <td>相等</td>      <td>Share locks</td>      <td>Share locks</td>      <td>Share locks</td>      <td>Share locks</td>   </tr>   <tr>      <td>范围</td>      <td>Share locks</td>      <td>Share locks</td>      <td>Share Next-Key</td>      <td>Share Next-Key</td>   </tr>   <tr>      <td rowspan="2">Select * from ... For update</td>      <td>相等</td>      <td>exclusive locks</td>      <td>exclusive locks</td>      <td>exclusive locks</td>      <td>exclusive locks</td>   </tr>   <tr>      <td>范围</td>      <td>exclusive locks</td>      <td>Share locks</td>      <td>exclusive next-key</td>      <td>exclusive next-key</td>   </tr>   </table><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>MyISAM表锁是deadlock free的，这是因为MyISAM总是一次获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。但在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，这就决定了在InnoDB中发生死锁是可能的</p><p>发生死锁后，InnoDB一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB并不能完全自动检测到死锁，这需要通过设置锁等待超时参数 innodb_lock_wait_timeout来解决。在并发访问比较高的情况下，如果大量事务因无法立即获得所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖跨数据库。</p><p>死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。通常来说，死锁都是应用设计的问题，通过调整业务流程、数据库对象设计、事务大小，以及访问数据库的SQL语句，绝大部分死锁都可以避免。</p><p>避免死锁的常用方法</p><ul><li>在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会。在下面的例子中，由于两个session访问两个表的顺序不同，发生死锁的机会就非常高！但如果以相同的顺序来访问，死锁就可以避免。</li><li>在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能。</li><li>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁，更新时再申请排他锁，因为当用户申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁。</li></ul>]]></content>
    
    <summary type="html">
    
      InnoDB锁
    
    </summary>
    
      <category term="mysql" scheme="http://langonggong.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://langonggong.com/tags/mysql/"/>
    
      <category term="DB" scheme="http://langonggong.com/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>mysql索引</title>
    <link href="http://langonggong.com/2018/11/20/mysql%E7%B4%A2%E5%BC%95/"/>
    <id>http://langonggong.com/2018/11/20/mysql索引/</id>
    <published>2018-11-19T16:27:37.000Z</published>
    <updated>2020-06-22T16:40:36.959Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><img src="/images/RBTree.jpg"></p><p>红黑树的特性:</p><ul><li>每个节点或者是黑色，或者是红色</li><li>根节点是黑色</li><li>每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</li><li>如果一个节点是红色的，则它的子节点必须是黑色的</li><li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点</li></ul><p>红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。<br>例如，Java集合中的TreeSet和TreeMap，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。</p><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p><img src="/images/BTree.jpg"></p><p>B 树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点</p><ul><li>根节点至少有两个子节点</li><li>每个节点有M-1个key，并且以升序排列</li><li>位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间</li><li>其它节点至少有M/2个子节点</li></ul><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p><img src="/images/B+Tree.jpg"></p><p>B+树是对B树的一种变形树，它与B树的差异在于</p><ul><li>有k个子结点的结点必然有k个关键码；</li><li>非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。</li><li>树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。</li></ul><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>结构上</p><ul><li>B树中关键字集合分布在整棵树中，叶节点中不包含任何关键字信息，而B+树关键字集合分布在叶子结点中，非叶节点只是叶子结点中关键字的索引</li><li>B树中任何一个关键字只出现在一个结点中，而B+树中的关键字必须出现在叶节点中，也可能在非叶结点中重复出现</li></ul><p>性能上</p><ul><li>不同于B树只适合随机检索，B+树同时支持随机检索和顺序检索；</li><li>B+树的磁盘读写代价更低。B+树的内部结点并没有指向关键字具体信息的指针，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素。</li><li>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</li><li>（数据库索引采用B+树的主要原因是）B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）</li></ul><h1 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h1><p>从数据结构角度</p><ul><li>B+树索引</li><li>hash索引</li></ul><p>从物理存储角度</p><ul><li>聚集索引（聚簇索引）（clustered index）</li><li>非聚集索引（non-clustered index）</li></ul><p>从逻辑角度</p><ul><li>普通索引或者单列索引</li><li>唯一索引</li><li>主键索引：主键索引是一种特殊的唯一索引，不允许有空值</li><li>多列索引（复合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合</li><li>全文索引</li></ul><p>从存储引擎的角度</p><ul><li>主键索引</li><li>辅助索引(二级索引)</li></ul><p>B+树索引和哈希索引的明显区别是</p><ul><li>如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据</li><li>哈希索引无法完成范围查询检索</li><li>哈希索引无法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）</li><li>哈希索引也不支持多列联合索引的最左匹配规则</li><li>B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题</li></ul><h1 id="不同引擎的索引"><a href="#不同引擎的索引" class="headerlink" title="不同引擎的索引"></a>不同引擎的索引</h1><h2 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址</p><p><img src="/images/MyISAMPK.png"></p><h3 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h3><p>在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复</p><p><img src="/images/MyISAMSK.png"></p><h2 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h2><h3 id="主键索引-1"><a href="#主键索引-1" class="headerlink" title="主键索引"></a>主键索引</h3><p>MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引</p><p><img src="/images/InnoDBPK.png"></p><p>(图inndb主键索引）是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键</p><h3 id="辅助索引-1"><a href="#辅助索引-1" class="headerlink" title="辅助索引"></a>辅助索引</h3><p>InnoDB的所有辅助索引都引用主键作为data域</p><p><img src="/images/InnoDBSK.png"></p><p>InnoDB 表是基于聚簇索引建立的。因此InnoDB 的索引能提供一种非常快速的主键查找性能。不过，它的辅助索引（Secondary Index， 也就是非主键索引）也会包含主键列，所以，如果主键定义的比较大，其他索引也将很大。如果想在表上定义 、很多索引，则争取尽量把主键定义得小一些</p><p>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录</p><h2 id="InnoDB和MyISAM的区别"><a href="#InnoDB和MyISAM的区别" class="headerlink" title="InnoDB和MyISAM的区别"></a>InnoDB和MyISAM的区别</h2><ul><li>一是主索引的区别，InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。</li><li>二是辅助索引的区别：InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。</li></ul><h1 id="索引详解"><a href="#索引详解" class="headerlink" title="索引详解"></a>索引详解</h1><h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><p>有时候需要索引很长的字符列，这会让索引变得大且慢。通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。<br>对于BLOB，TEXT，或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。<br>要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间）。前缀应该足够长，以使得前缀索引的选择性接近于索引的整个列。<br>mysql无法使用其前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。</p><h2 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h2><p>多列索引并不是指建立多个单列索引，而是指在多个字段建立一个索引。</p><ul><li>又叫联合索引、复合索引。符合最左前缀规则</li><li>多列建索引比对每个列分别建索引更有优势，因为索引建立得越多就越占磁盘空间，在更新数据的时候速度会更慢。那如果我们分别在a和b上创建两个列索引，mysql的处理方式就不一样了，它会选择一个最严格的索引来进行检索，可以理解为检索能力最强的那个索引来检索，另外一个利用不上了，这样效果就不如多列索引了</li><li>将选择性最高的列放到索引的最前列</li></ul><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><ul><li>解释一： 就是select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。</li><li>解释二： 索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。</li><li>解释三：是非聚集组合索引的一种形式，它包括在查询里的Select、Join和Where子句用到的所有列（即建立索引的字段正好是覆盖查询语句[select子句]与查询条件[Where子句]中所涉及的字段，也即，索引包含了查询正在查找的所有数据）</li></ul><p>使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为using index,MySQL查询优化器在执行查询前会决定是否有索引覆盖查询。<br>覆盖索引也并不适用于任意的索引类型，索引必须存储列的值。Hash 和full-text索引不存储值，因此MySQL只能使用B-TREE</p><h2 id="空间索引"><a href="#空间索引" class="headerlink" title="空间索引"></a>空间索引</h2><p><a href="https://blog.csdn.net/MongChia1993/article/details/69941783#toc_16" target="_blank" rel="noopener">参考链接</a></p><h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><p><a href="https://www.cnblogs.com/itxiongwei/p/7064252.html" target="_blank" rel="noopener">参考链接</a></p><h1 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h1><p>优点</p><ul><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li><li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li><li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能</li></ul><p>缺点</p><ul><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li></ul><h1 id="索引建立原则"><a href="#索引建立原则" class="headerlink" title="索引建立原则"></a>索引建立原则</h1><p>一般来说，不应该创建索引的的这些列具有下列特点</p><ul><li>对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li><li>对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</li><li>对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</li><li>当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li></ul><p>常见规则</p><ul><li>最左前缀匹配原则<br>  mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整</li><li>=和in可以乱序<br>  比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li><li>尽量选择区分度高的列作为索引<br>  区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1</li><li>索引列不能参与计算<br>  比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大</li><li>尽量的扩展索引，不要新建索引<br>  比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可</li></ul>]]></content>
    
    <summary type="html">
    
      mysql索引
    
    </summary>
    
      <category term="mysql" scheme="http://langonggong.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://langonggong.com/tags/mysql/"/>
    
      <category term="DB" scheme="http://langonggong.com/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>生产者消费者</title>
    <link href="http://langonggong.com/2018/11/17/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <id>http://langonggong.com/2018/11/17/生产者消费者/</id>
    <published>2018-11-17T13:47:09.000Z</published>
    <updated>2020-06-22T16:40:36.965Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>注意：必须使用while循环，因为当前线程被唤醒之前，同时有消费者和生产线程都有执行过，导致当前的条件不满足。例如，size为0导致消费者线程thread1被阻塞，后来成产者线程thread2和消费者线程thread3都有执行，thread2唤醒了thread1，但是此时thread1发现size还是0，继续阻塞</p><h1 id="wait-notify-方法"><a href="#wait-notify-方法" class="headerlink" title="wait() / notify()方法"></a>wait() / notify()方法</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Storage1</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;Object&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    synchronized (<span class="built_in">list</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="built_in">list</span>.size() == MAX_SIZE) &#123;</span><br><span class="line">        System.out.println(<span class="string">"full,wait!"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="built_in">list</span>.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">list</span>.add(<span class="keyword">new</span> Object());</span><br><span class="line">      System.out.println(<span class="string">"produce,now size is:"</span> + <span class="built_in">list</span>.size());</span><br><span class="line">      <span class="built_in">list</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    synchronized (<span class="built_in">list</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="built_in">list</span>.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"empty,wait!"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="built_in">list</span>.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">list</span>.remove(<span class="number">0</span>);</span><br><span class="line">      System.out.println(<span class="string">"consume,new size is:"</span> + <span class="built_in">list</span>.size());</span><br><span class="line">      <span class="built_in">list</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Storage1 storage1 = <span class="keyword">new</span> Storage1();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">          storage1.consume();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">          storage1.produce();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="await-signal-方法"><a href="#await-signal-方法" class="headerlink" title="await() / signal()方法"></a>await() / signal()方法</h1><p>通过在Lock对象上调用newCondition()方法，将一个condition和一个约束条件进行绑定，进而控制并发程序访问竞争资源的安全</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Storage2</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Lock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Condition notEmpty = <span class="keyword">lock</span>.newCondition();</span><br><span class="line">  <span class="keyword">private</span> Condition notFull = <span class="keyword">lock</span>.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (list.size() == MAX_SIZE) &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"full,wait!"</span>);</span><br><span class="line">        notFull.<span class="keyword">await</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      list.<span class="keyword">add</span>(<span class="keyword">new</span> Object());</span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">"produce,now size is:"</span> + list.size());</span><br><span class="line">      notEmpty.signalAll();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (list.isEmpty()) &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"empty,wait!"</span>);</span><br><span class="line">        notEmpty.<span class="keyword">await</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      list.<span class="keyword">remove</span>(<span class="number">0</span>);</span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">"consume,now size is:"</span> + list.size());</span><br><span class="line">      notFull.signalAll();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">    Storage2 Storage2 = <span class="keyword">new</span> Storage2();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          Storage2.consume();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          Storage2.produce();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h1><ul><li>put()方法：容量达到最大时，自动阻塞。</li><li>take()方法：容量为0时，自动阻塞。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Storage3</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> LinkedBlockingDeque&lt;Object&gt; <span class="built_in">deque</span> = <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(MAX_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">deque</span>.size() == MAX_SIZE) &#123;</span><br><span class="line">      System.out.println(<span class="string">"full,wait!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">deque</span>.put(<span class="keyword">new</span> Object());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"produce,now size is:"</span> + <span class="built_in">deque</span>.size());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">deque</span>.isEmpty()) &#123;</span><br><span class="line">      System.out.println(<span class="string">"empty,wait!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">deque</span>.takeFirst();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"consume,now size is:"</span> + <span class="built_in">deque</span>.size());</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      生产者消费者
    
    </summary>
    
      <category term="java" scheme="http://langonggong.com/categories/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://langonggong.com/tags/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CyclicBarrier</title>
    <link href="http://langonggong.com/2018/11/17/CyclicBarrier/"/>
    <id>http://langonggong.com/2018/11/17/CyclicBarrier/</id>
    <published>2018-11-17T07:11:33.000Z</published>
    <updated>2020-06-22T16:40:36.954Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><code>回环栅栏</code>是一个同步工具类，它允许一组线程互相等待，直到到达某个公共屏障点。与CountDownLatch不同的是该barrier在释放等待线程后可以重用，所以称它为循环（Cyclic）的屏障（Barrier）</p><p>CyclicBarrier支持一个可选的Runnable命令，在一组线程中的最后一个线程到达之后（但在释放所有线程之前），该命令只在每个屏障点运行一次。若在继续所有参与线程之前更新共享状态，此屏障操作很有用</p><ul><li>CyclicBarrier(int parties)</li><li>CyclicBarrier(int parties, Runnable barrierAction)：参数parties指让多少个线程或者任务等待至barrier状态；参数barrierAction为当这些线程都达到barrier状态时会执行的内容</li><li>int await()：用来挂起当前线程，直至所有线程都到达barrier状态再同时执行后续任务</li><li>int await(long timeout, TimeUnit unit)：让这些线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务</li></ul><p>使用场景：多个子线程执行部分逻辑后进入就绪状态，停顿一下，然后等待某个关键线程执行，之后多个子线程再继续执行后面的逻辑</p>]]></content>
    
    <summary type="html">
    
      CyclicBarrier
    
    </summary>
    
      <category term="java" scheme="http://langonggong.com/categories/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://langonggong.com/tags/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数组中只出现了一次的数</title>
    <link href="http://langonggong.com/2018/11/08/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%BA%86%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0/"/>
    <id>http://langonggong.com/2018/11/08/数组中只出现了一次的数/</id>
    <published>2018-11-08T07:40:36.000Z</published>
    <updated>2020-06-22T16:40:36.964Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> FindNumsAppearOnce(<span class="keyword">int</span> [] <span class="keyword">array</span>,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[]) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">if</span> (<span class="keyword">array</span> == null || <span class="keyword">array</span>.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k0 = <span class="number">0</span>, k1 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//通过抑或运算，出现偶数次的元素消失</span></span><br><span class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> i : <span class="keyword">array</span>) &#123;</span><br><span class="line">      k0 = k0 ^ i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得该值二进制数字中的最右边的1</span></span><br><span class="line">    <span class="keyword">int</span> right = k0 &amp; (~k0 + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> i : <span class="keyword">array</span>) &#123;</span><br><span class="line">      <span class="built_in">if</span> ((right &amp; i) != <span class="number">0</span>) &#123;</span><br><span class="line">        k1 = k1 ^ i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    num1[<span class="number">0</span>] = Math.<span class="built_in">min</span>(k1, k1 ^ k0);</span><br><span class="line">    num2[<span class="number">0</span>] = Math.<span class="built_in">max</span>(k1, k1 ^ k0);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      数组中只出现了一次的数
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="位运算" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="位运算" scheme="http://langonggong.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>责任链模式</title>
    <link href="http://langonggong.com/2018/10/29/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://langonggong.com/2018/10/29/责任链模式/</id>
    <published>2018-10-29T14:55:07.000Z</published>
    <updated>2020-06-22T16:40:36.967Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>责任链模式是一种对象的行为模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。Tomcat中的Filter就是使用了责任链模式</p><p>Request<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> &#123;</span></span><br><span class="line">    String requestStr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> requestStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequest</span><span class="params">(String request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestStr = request;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Response<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span> &#123;</span></span><br><span class="line">    String responseStr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> responseStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResponse</span><span class="params">(String response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.responseStr = response;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Filter<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface Filter </span>&#123;</span><br><span class="line">    void doFilter(Request request,Response response,FilterChain chain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>HTMLFilter<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HTMLFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request request, Response response,FilterChain chain)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将字符串中出现的"&lt;&gt;"符号替换成"[]"</span></span><br><span class="line">        request.requestStr=request.requestStr</span><br><span class="line">                .replace(<span class="string">'&lt;'</span>, <span class="string">'['</span>).replace(<span class="string">'&gt;'</span>, <span class="string">']'</span>);</span><br><span class="line">        chain.doFilter(request, response,chain);</span><br><span class="line">        response.responseStr+=<span class="string">"---HTMLFilter()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SensitiveFilter<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SensitiveFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request request, Response response,FilterChain chain)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//处理字符串中的敏感信息，将被就业和谐成就业</span></span><br><span class="line">        request.requestStr=request.requestStr</span><br><span class="line">                .replace(<span class="string">"被就业"</span>, <span class="string">"就业"</span>).replace(<span class="string">"敏感"</span>, <span class="string">""</span>);</span><br><span class="line">        chain.doFilter(request, response,chain);</span><br><span class="line">        response.responseStr+=<span class="string">"---sensitiveFilter()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>FilterChain<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterChain</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">    <span class="comment">//用List集合来存储过滤规则</span></span><br><span class="line">    List&lt;Filter&gt; filters = <span class="keyword">new</span> ArrayList&lt;Filter&gt;();</span><br><span class="line">    <span class="comment">//用于标记规则的引用顺序</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">index</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//往规则链条中添加规则</span></span><br><span class="line">    <span class="keyword">public</span> FilterChain addFilter(Filter f) &#123;</span><br><span class="line">        filters.add(f);</span><br><span class="line">        <span class="comment">//代码的设计技巧:Chain链添加过滤规则结束后返回添加后的Chain，方便我们下面doFilter函数的操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> doFilter(Request request,Response response,FilterChain chain)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">index</span>==filters.size())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每添加一个过滤规则，index自增1</span></span><br><span class="line">        Filter f=filters.get(<span class="keyword">index</span>);</span><br><span class="line">        <span class="keyword">index</span>++;</span><br><span class="line">        <span class="comment">//根据索引值获取对应的规律规则对字符串进行处理</span></span><br><span class="line">        f.doFilter(request, response, chain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试用例<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span> args[]) &#123;</span><br><span class="line">        <span class="keyword">String</span> msg = <span class="string">":):,&lt;script&gt;,敏感,被就业,网络授课"</span>;</span><br><span class="line">        Request request=<span class="keyword">new</span> <span class="type">Request</span>();</span><br><span class="line">        request.setRequest(msg);</span><br><span class="line">        Response response=<span class="keyword">new</span> <span class="type">Response</span>();</span><br><span class="line">        response.setResponse(<span class="string">"response:"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//FilterChain,过滤规则形成的拦截链条</span></span><br><span class="line">        FilterChain fc=<span class="keyword">new</span> <span class="type">FilterChain</span>();</span><br><span class="line">        fc.addFilter(<span class="keyword">new</span> <span class="type">HTMLFilter</span>())</span><br><span class="line">        .addFilter(<span class="keyword">new</span> <span class="type">SensitiveFilter</span>())</span><br><span class="line">        .addFilter(<span class="keyword">new</span> <span class="type">FaceFilter</span>());</span><br><span class="line">        <span class="comment">//按照FilterChain的规则顺序，依次应用过滤规则</span></span><br><span class="line">        fc.doFilter(request, response,fc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      责任链模式
    
    </summary>
    
      <category term="设计模式" scheme="http://langonggong.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://langonggong.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>命令模式</title>
    <link href="http://langonggong.com/2018/10/29/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://langonggong.com/2018/10/29/命令模式/</id>
    <published>2018-10-29T09:22:57.000Z</published>
    <updated>2020-06-22T16:40:36.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><ul><li>更方便的对命令进行扩展（注意：这不是主要的优势，后面会提到）</li><li>对多个命令的统一控制（这种控制包括但不限于：队列、撤销/恢复、记录日志等等）</li></ul><h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><ul><li>Command：定义命令的统一接口</li><li>ConcreteCommand：Command接口的实现者，用来执行具体的命令，某些情况下可以直接用来充当Receiver</li><li>Receiver：命令的实际执行者</li><li>Invoker：命令的请求者，是命令模式中最重要的角色。这个角色用来对各个命令进行控制</li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>抽象角色<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>ICommand</span><br><span class="line">&#123;</span><br><span class="line">    void Execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>角色A<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConcreteCommandA</span> : <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommandA</span>(<span class="params">Receiver receiver</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver.DoA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>角色B<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConcreteCommandB</span> : <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommandB</span>(<span class="params">Receiver receiver</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver.DoB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Receiver<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//DoSomething</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//DoSomething</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Invoker<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Invoker</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ICommand command = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置命令</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetCommand</span>(<span class="params">ICommand command</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行命令</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RunCommand</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        command.Execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端调用<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Client()</span><br><span class="line">    &#123;</span><br><span class="line">        Receiver receiver = <span class="keyword">new</span> <span class="type">Receiver</span>();</span><br><span class="line">        Invoker invoker = <span class="keyword">new</span> <span class="type">Invoker</span>();</span><br><span class="line">        invoker.SetCommand(<span class="keyword">new</span> <span class="type">ConcreteCommandA</span>(receiver));</span><br><span class="line">        invoker.RunCommand();</span><br><span class="line">        invoker.SetCommand(<span class="keyword">new</span> <span class="type">ConcreteCommandB</span>(receiver));</span><br><span class="line">        invoker.RunCommand();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      命令模式
    
    </summary>
    
      <category term="设计模式" scheme="http://langonggong.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://langonggong.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="http://langonggong.com/2018/10/29/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://langonggong.com/2018/10/29/观察者模式/</id>
    <published>2018-10-29T06:29:27.000Z</published>
    <updated>2020-06-22T16:40:36.966Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><img src="/images/ObserverPattern.png"></p><ul><li>Subject（目标）：目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时它定义了通知方法notify()。目标类可以是接口，也可以是抽象类或具体类。 </li><li>ConcreteSubject（具体目标）：具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。如果无须扩展目标类，则具体目标类可以省略。 </li><li>Observer（观察者）：观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法update()，因此又称为抽象观察者。 </li><li>ConcreteObserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者Observer中定义的update()方法。通常在实现时，可以调用具体目标类的attach()方法将自己添加到目标类的集合中或通过detach()方法将自己从目标类的集合中删除</li></ul><p>定义一个抽象被观察者接口<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Observerable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span>(<span class="params">Observer o</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span>(<span class="params">Observer o</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span>(<span class="params"></span>)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义一个抽象观察者接口<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Observer &#123;</span><br><span class="line">    public void update(String message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义被观察者，实现了Observerable接口，对Observerable接口的三个方法进行了具体实现，同时有一个List集合，用以保存注册的观察者，等需要通知观察者时，遍历该集合即可<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WechatServer</span> <span class="title">implements</span> <span class="title">Observerable</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意到这个List集合的泛型参数为Observer接口，设计原则：面向接口编程而不是面向实现编程</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WechatServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">list</span>.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">list</span>.isEmpty())</span><br><span class="line">            <span class="built_in">list</span>.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.size(); i++) &#123;</span><br><span class="line">            Observer oserver = <span class="built_in">list</span>.get(i);</span><br><span class="line">            oserver.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfomation</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = s;</span><br><span class="line">        System.out.println(<span class="string">"微信服务更新消息： "</span> + s);</span><br><span class="line">        <span class="comment">//消息更新，通知所有观察者</span></span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义具体观察者，微信公众号的具体观察者为用户User<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        read();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">" 收到推送消息： "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试用例<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        WechatServer <span class="keyword">server</span> = <span class="keyword">new</span> WechatServer();</span><br><span class="line">        </span><br><span class="line">        Observer userZhang = <span class="keyword">new</span> User(<span class="string">"ZhangSan"</span>);</span><br><span class="line">        Observer userLi = <span class="keyword">new</span> User(<span class="string">"LiSi"</span>);</span><br><span class="line">        Observer userWang = <span class="keyword">new</span> User(<span class="string">"WangWu"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">server</span>. attach(userZhang);</span><br><span class="line">        <span class="keyword">server</span>. attach(userLi);</span><br><span class="line">        <span class="keyword">server</span>. attach(userWang);</span><br><span class="line">        <span class="keyword">server</span>.setInfomation(<span class="string">"PHP是世界上最好用的语言！"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">server</span>.removeObserver(userZhang);</span><br><span class="line">        <span class="keyword">server</span>.setInfomation(<span class="string">"JAVA是世界上最好用的语言！"</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      观察者模式
    
    </summary>
    
      <category term="设计模式" scheme="http://langonggong.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://langonggong.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>https</title>
    <link href="http://langonggong.com/2018/10/26/https/"/>
    <id>http://langonggong.com/2018/10/26/https/</id>
    <published>2018-10-26T09:44:29.000Z</published>
    <updated>2020-06-22T16:40:36.958Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><img src="/images/https-connect.png"></p><ul><li>客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</li><li>Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</li><li>客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</li><li>客户端的浏览器根据双方同意的安全等级，在本地生成一对对称密钥作为会话秘钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</li><li>Web服务器利用自己的私钥解密出会话密钥。</li><li>Web服务器利用会话密钥加密与客户端之间的通信</li></ul><p>为什么要同时用到对称秘钥和非对称秘钥?</p><ul><li>对称秘钥加密、解密效率高，涉及web页面和没提内容输出时更高效</li><li>对称秘钥不能以明文直接发给服务器，必须用非对称秘钥加密</li><li>对称秘钥是长度较短的随机字符，适合用非对称秘钥加密</li></ul>]]></content>
    
    <summary type="html">
    
      https
    
    </summary>
    
      <category term="计算机网络" scheme="http://langonggong.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="https" scheme="http://langonggong.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/https/"/>
    
    
      <category term="https" scheme="http://langonggong.com/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>求二进制数中的1的个数</title>
    <link href="http://langonggong.com/2018/10/25/%E6%B1%82%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B8%AD%E7%9A%841%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://langonggong.com/2018/10/25/求二进制数中的1的个数/</id>
    <published>2018-10-24T16:18:50.000Z</published>
    <updated>2020-06-22T16:40:36.964Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="built_in">int</span> NumberOf1(<span class="built_in">int</span> <span class="built_in">n</span>) &#123;</span><br><span class="line">  <span class="built_in">int</span> <span class="built_in">count</span> = <span class="number">0</span>;</span><br><span class="line">  while (<span class="built_in">n</span> != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">count</span>++;</span><br><span class="line">    <span class="built_in">n</span> = <span class="built_in">n</span> &amp; (<span class="built_in">n</span> - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  return <span class="built_in">count</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      求二进制数中的1的个数
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="位运算" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="位运算" scheme="http://langonggong.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>适配器模式</title>
    <link href="http://langonggong.com/2018/10/24/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://langonggong.com/2018/10/24/适配器模式/</id>
    <published>2018-10-24T15:07:28.000Z</published>
    <updated>2020-06-22T16:40:36.967Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>配器就是一种适配中间件，它存在于不匹配的二者之间，用于连接二者，将不匹配变得匹配，简单点理解就是平常所见的转接头，转换器之类的存在</p><p>类适配器</p><ul><li>想要使用一个已经存在的类，但是它却不符合现有的接口规范，导致无法直接去访问，这时创建一个适配器就能间接去访问这个类中的方法</li><li>我们有一个类，想将其设计为可重用的类（可被多处访问），我们可以创建适配器来将这个类来适配其他没有提供合适接口的类</li></ul><p>接口适配器</p><ul><li>想要使用接口中的某个或某些方法，但是接口中有太多方法，我们要使用时必须实现接口并实现其中的所有方法，可以使用抽象类来实现接口，并不对方法进行实现（仅置空），然后我们再继承这个抽象类来通过重写想用的方法的方式来实现。这个抽象类就是适配器</li></ul><p>Ps2<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Ps2 &#123;</span><br><span class="line">   void isPs2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Usb<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Usb &#123;</span><br><span class="line">  void isUsb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Usber<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Usber</span> <span class="keyword">implements</span> <span class="title">Usb</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isUsb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"USB口"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Adapter<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Usber</span> <span class="title">implements</span> <span class="title">Ps2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void isPs2() &#123;</span><br><span class="line">        isUsb();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      适配器模式
    
    </summary>
    
      <category term="设计模式" scheme="http://langonggong.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://langonggong.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="适配器模式" scheme="http://langonggong.com/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>前序、中序序列构建二叉树</title>
    <link href="http://langonggong.com/2018/10/22/%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E5%BA%8F%E5%88%97%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://langonggong.com/2018/10/22/前序、中序序列构建二叉树/</id>
    <published>2018-10-22T14:12:56.000Z</published>
    <updated>2020-06-22T16:40:36.962Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>使用递归，在当前处理中获取前序和中序遍历中的头结点、左子树、右子树，递归处理左右子树，返回构建好的树结构</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode reConstructBinaryTree(<span class="type">int</span> [] pre,<span class="type">int</span> [] <span class="keyword">in</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> solve(pre, <span class="number">0</span>, pre.<span class="built_in">length</span> - <span class="number">1</span>, <span class="keyword">in</span>, <span class="number">0</span>, <span class="keyword">in</span>.<span class="built_in">length</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public TreeNode solve(<span class="type">int</span>[] pre, <span class="type">int</span> preStart, <span class="type">int</span> preEnd, <span class="type">int</span>[] <span class="keyword">in</span>, <span class="type">int</span> inStart, <span class="type">int</span> inEnd) &#123;</span><br><span class="line">  <span class="keyword">if</span> (preStart &gt; preEnd) &#123;</span><br><span class="line">    <span class="keyword">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (preStart == preEnd) &#123;</span><br><span class="line">    <span class="keyword">return</span> new TreeNode(pre[preStart]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> cur = pre[preStart];</span><br><span class="line">  <span class="type">int</span> <span class="keyword">index</span> = inStart;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">index</span> &lt;= inEnd &amp;&amp; cur != <span class="keyword">in</span>[<span class="keyword">index</span>]) &#123;</span><br><span class="line">    <span class="keyword">index</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//左子树的长度</span></span><br><span class="line">  <span class="type">int</span> leftLength = <span class="keyword">index</span> - inStart;</span><br><span class="line">  TreeNode head = new TreeNode(pre[preStart]);</span><br><span class="line">  TreeNode left = solve(pre, preStart + <span class="number">1</span>, preStart + leftLength, <span class="keyword">in</span>, inStart, <span class="keyword">index</span> - <span class="number">1</span>);</span><br><span class="line">  TreeNode right = solve(pre, preStart + leftLength + <span class="number">1</span>, preEnd, <span class="keyword">in</span>, <span class="keyword">index</span> + <span class="number">1</span>, inEnd);</span><br><span class="line">  head.left = left;</span><br><span class="line">  head.right = right;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      根据前序、中序遍历的序列构建二叉树
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://langonggong.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>判断完全二叉树</title>
    <link href="http://langonggong.com/2018/10/19/%E5%88%A4%E6%96%AD%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://langonggong.com/2018/10/19/判断完全二叉树/</id>
    <published>2018-10-19T13:20:47.000Z</published>
    <updated>2020-06-22T16:40:36.962Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">chk</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">   TreeNode[] arr = <span class="keyword">new</span> TreeNode[<span class="number">501</span>];</span><br><span class="line">   <span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line">   TreeNode cur;</span><br><span class="line">   arr[tail++] = root;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (head != tail) &#123;</span><br><span class="line">     cur = arr[head++];</span><br><span class="line">     <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">       arr[tail++] = cur.left;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">       arr[tail++] = cur.right;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///判断是否应该是最后一个节点</span></span><br><span class="line">   <span class="keyword">boolean</span> isTail = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tail;i++) &#123;</span><br><span class="line">     cur = arr[i];</span><br><span class="line">     <span class="keyword">if</span> (cur.left == <span class="keyword">null</span> || cur.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (cur.left == <span class="keyword">null</span> &amp;&amp; cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (!isTail) &#123;</span><br><span class="line">         isTail = <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(cur.left != <span class="keyword">null</span> || cur.right != <span class="keyword">null</span>)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      判断完全二叉树
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="完全二叉树" scheme="http://langonggong.com/tags/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>判断二叉平衡树</title>
    <link href="http://langonggong.com/2018/10/19/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    <id>http://langonggong.com/2018/10/19/判断二叉平衡树/</id>
    <published>2018-10-19T12:10:38.000Z</published>
    <updated>2020-06-22T16:40:36.962Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> boolean check(<span class="type">TreeNode</span> root) &#123;</span><br><span class="line">  <span class="keyword">return</span> chk(root) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> int chk(<span class="type">TreeNode</span> treeNode) &#123;</span><br><span class="line">  <span class="keyword">if</span> (treeNode == null) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int <span class="keyword">left</span> = chk(treeNode.<span class="keyword">left</span>);</span><br><span class="line">  int <span class="keyword">right</span> = chk(treeNode.<span class="keyword">right</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">left</span> &lt; <span class="number">0</span> || <span class="keyword">right</span> &lt; <span class="number">0</span> || <span class="type">Math</span>.<span class="built_in">abs</span>(<span class="keyword">left</span> - <span class="keyword">right</span>) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">Math</span>.<span class="built_in">max</span>(<span class="keyword">left</span>, <span class="keyword">right</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      判断二叉平衡树
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://langonggong.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="二叉平衡树" scheme="http://langonggong.com/tags/%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>非递归遍历二叉树</title>
    <link href="http://langonggong.com/2018/10/19/%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://langonggong.com/2018/10/19/遍历二叉树/</id>
    <published>2018-10-19T10:50:40.000Z</published>
    <updated>2020-06-22T16:40:36.967Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] pre(TreeNode node) &#123;</span><br><span class="line">  Stack&lt;TreeNode&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">  TreeNode cur;</span><br><span class="line">  List&lt;Integer&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="built_in">stack</span>.push(node);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">    cur = <span class="built_in">stack</span>.pop();</span><br><span class="line">    <span class="built_in">list</span>.add(cur.val);</span><br><span class="line">    <span class="keyword">if</span> (cur.right != null) &#123;</span><br><span class="line">      <span class="built_in">stack</span>.push(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur.left != null) &#123;</span><br><span class="line">      <span class="built_in">stack</span>.push(cur.left);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> list2arr(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] mid(TreeNode node) &#123;</span><br><span class="line">  Stack&lt;TreeNode&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">  TreeNode cur = node;</span><br><span class="line">  List&lt;Integer&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="built_in">stack</span>.push(node);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">while</span> (cur != null &amp;&amp; cur.left != null) &#123;</span><br><span class="line">      <span class="built_in">stack</span>.push(cur.left);</span><br><span class="line">      cur = cur.left;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = <span class="built_in">stack</span>.pop();</span><br><span class="line">    <span class="built_in">list</span>.add(cur.val);</span><br><span class="line">    <span class="keyword">if</span> (cur.right != null) &#123;</span><br><span class="line">      <span class="built_in">stack</span>.push(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">    cur = cur.right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> list2arr(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] after(TreeNode node) &#123;</span><br><span class="line">  Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">  Stack&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  TreeNode cur;</span><br><span class="line">  stack1.push(node);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">    cur = stack1.pop();</span><br><span class="line">    stack2.push(cur);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur.left != null) &#123;</span><br><span class="line">      stack1.push(cur.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur.right != null) &#123;</span><br><span class="line">      stack1.push(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List&lt;Integer&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">while</span> (!stack2.isEmpty()) &#123;</span><br><span class="line">    <span class="built_in">list</span>.add(stack2.pop().val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> list2arr(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] list2arr(List&lt;Integer&gt; <span class="built_in">list</span>) &#123;</span><br><span class="line">  <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">list</span>.size()];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.size(); i++) &#123;</span><br><span class="line">    arr[i] = <span class="built_in">list</span>.get(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      非递归遍历二叉树
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://langonggong.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>长连接</title>
    <link href="http://langonggong.com/2018/10/14/%E9%95%BF%E8%BF%9E%E6%8E%A5/"/>
    <id>http://langonggong.com/2018/10/14/长连接/</id>
    <published>2018-10-14T07:33:17.000Z</published>
    <updated>2020-06-22T16:40:36.967Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h1><p><img src="/images/short-connection.png"></p><p>（挥手的地方，第一次发送FIN应该是客户端而非服务端）<br>http协议是无状态协议，每次的请求响应都是独立的<br>客户端通过http进程发起与服务主机的tcp连接，向所建立的tcp连接相关的本地套接字发送一个http请求消息。服务器与tcp相关的本地套接字收到这个请求后，进行处理，经由同一个套接字发出相应消息，同时告知tcp关闭tcp连接</p><h1 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h1><p>http1.1采用持续连接机制，即客户端和服务器建立tcp连接后，多个http请求可以重复利用已经建立起来的tcp连接。这个持续的tcp连接会空闲一段特定的时间后关闭</p><h2 id="不带流水线"><a href="#不带流水线" class="headerlink" title="不带流水线"></a>不带流水线</h2><p>用户的http请求只能在上一个请求得到响应后发出<br><img src="/images/no-pipeline-long-connection.png"></p><h2 id="带流水线"><a href="#带流水线" class="headerlink" title="带流水线"></a>带流水线</h2><p>客户端在web页面发现引用时就可以发起请求，无需考虑上一个请求的响应是否已经收到<br><img src="/images/pipeline-long-connection.png"></p>]]></content>
    
    <summary type="html">
    
      长连接
    
    </summary>
    
      <category term="计算机网络" scheme="http://langonggong.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="http" scheme="http://langonggong.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http/"/>
    
    
      <category term="http" scheme="http://langonggong.com/tags/http/"/>
    
      <category term="长连接" scheme="http://langonggong.com/tags/%E9%95%BF%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>tomcat</title>
    <link href="http://langonggong.com/2018/10/13/tomcat/"/>
    <id>http://langonggong.com/2018/10/13/tomcat/</id>
    <published>2018-10-13T07:11:17.000Z</published>
    <updated>2020-06-22T16:40:36.961Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="tomcat架构"><a href="#tomcat架构" class="headerlink" title="tomcat架构"></a>tomcat架构</h1><p><a href="https://blog.csdn.net/xlgen157387/article/details/79006434" target="_blank" rel="noopener">Tomcat系统架构</a></p><p><a href="https://www.cnblogs.com/diegodu/p/5915300.html" target="_blank" rel="noopener">Tomcat系统架构</a></p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/index.html?ca=drs-" target="_blank" rel="noopener">Tomcat系统架构</a></p><h1 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h1><p><a href="https://blog.csdn.net/gchd19921992/article/details/79076926" target="_blank" rel="noopener">Connector 分析</a></p><h1 id="Tomcat中的设计模式"><a href="#Tomcat中的设计模式" class="headerlink" title="Tomcat中的设计模式"></a>Tomcat中的设计模式</h1><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat2/index.html?ca=drs-" target="_blank" rel="noopener">设计模式</a></p><p><a href="https://blog.csdn.net/u012810020/article/details/71194853" target="_blank" rel="noopener">责任链模式</a></p>]]></content>
    
    <summary type="html">
    
      tomcat
    
    </summary>
    
      <category term="tomcat" scheme="http://langonggong.com/categories/tomcat/"/>
    
    
      <category term="tomcat" scheme="http://langonggong.com/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>DispatcherServlet</title>
    <link href="http://langonggong.com/2018/10/13/DispatcherServlet/"/>
    <id>http://langonggong.com/2018/10/13/DispatcherServlet/</id>
    <published>2018-10-13T07:11:17.000Z</published>
    <updated>2020-06-22T16:40:36.955Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="容器配置"><a href="#容器配置" class="headerlink" title="容器配置"></a>容器配置</h1><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">&lt;context-param&gt;</span></span><br><span class="line">    <span class="params">&lt;param-name&gt;</span>contextConfigLocation<span class="params">&lt;/param-name&gt;</span></span><br><span class="line">    <span class="params">&lt;param-value&gt;</span></span><br><span class="line"><span class="symbol">        classpath:</span>redis/spring-redis.xml</span><br><span class="line">    <span class="params">&lt;/param-value&gt;</span></span><br><span class="line"><span class="params">&lt;/context-param&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="params">&lt;listener&gt;</span></span><br><span class="line">    <span class="params">&lt;listener-class&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="params">&lt;/listener-class&gt;</span></span><br><span class="line"><span class="params">&lt;/listener&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="params">&lt;servlet&gt;</span></span><br><span class="line">    <span class="params">&lt;servlet-name&gt;</span>springMVC<span class="params">&lt;/servlet-name&gt;</span></span><br><span class="line">    <span class="params">&lt;servlet-class&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="params">&lt;/servlet-class&gt;</span></span><br><span class="line">    <span class="params">&lt;init-param&gt;</span></span><br><span class="line">        <span class="params">&lt;param-name&gt;</span>contextConfigLocation<span class="params">&lt;/param-name&gt;</span></span><br><span class="line">        <span class="params">&lt;param-value&gt;</span></span><br><span class="line"><span class="symbol">            classpath:</span>spring/spring-mvc.xml</span><br><span class="line">        <span class="params">&lt;/param-value&gt;</span></span><br><span class="line">    <span class="params">&lt;/init-param&gt;</span></span><br><span class="line">    <span class="params">&lt;load-on-startup&gt;</span><span class="number">1</span><span class="params">&lt;/load-on-startup&gt;</span></span><br><span class="line">    <span class="params">&lt;async-supported&gt;</span>true<span class="params">&lt;/async-supported&gt;</span></span><br><span class="line"><span class="params">&lt;/servlet&gt;</span></span><br><span class="line"><span class="params">&lt;servlet-mapping&gt;</span></span><br><span class="line">    <span class="params">&lt;servlet-name&gt;</span>springMVC<span class="params">&lt;/servlet-name&gt;</span></span><br><span class="line">    <span class="params">&lt;url-pattern&gt;</span>/<span class="params">&lt;/url-pattern&gt;</span></span><br><span class="line"><span class="params">&lt;/servlet-mapping&gt;</span></span><br></pre></td></tr></table></figure><table>   <tr>      <td colspan="2">参数</td>      <td colspan="5">描述</td>      </tr>   <tr>      <td colspan="2"> contextClass </td>      <td colspan="5">实现WebApplicationContext接口的类，当前的servlet用它来创建上下文。如果这个参数没有指定， 默认使用XmlWebApplicationContext</td>      </tr>   <tr>      <td colspan="2"> contextConfigLocation </td>      <td colspan="5">传给上下文实例（由contextClass指定）的字符串，用来指定上下文的位置。这个字符串可以被分成多个字符串（使用逗号作为分隔符） 来支持多个上下文（在多上下文的情况下，如果同一个bean被定义两次，后面一个优先）</td>      </tr>   <tr>      <td colspan="2"> namespace </td>      <td colspan="5">WebApplicationContext命名空间。默认值是[server-name]-servlet</td>      </tr></table><p>ContextLoaderListener初始化的上下文和DispatcherServlet初始化的上下文关系</p><p><img src="/images/Spring-Dispatcher.jpg"></p><p>从图中可以看出</p><ul><li>ContextLoaderListener初始化的上下文加载的Bean是对于整个应用程序共享的，不管是使用什么表现层技术，一般如DAO层、Service层Bean</li><li>DispatcherServlet初始化的上下文加载的Bean是只对Spring Web MVC有效的Bean，如Controller、HandlerMapping、HandlerAdapter等等，该初始化上下文应该只加载Web相关组件</li></ul><h1 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h1><h2 id="Spring-MVC容器的初始化"><a href="#Spring-MVC容器的初始化" class="headerlink" title="Spring MVC容器的初始化"></a>Spring MVC容器的初始化</h2><p>ContextLoaderListener监听器的作用就是启动Web容器（如tomcat）时，自动装配ApplicationContext的配置信息。因为它实现了ServletContextListener这个接口，在web.xml配置了这个监听器，启动容器时，就会默认执行它实现的contextInitialized()方法初始化WebApplicationContext实例，并放入到ServletContext中。由于在ContextLoaderListener继承了ContextLoader这个类，所以整个加载配置过程由ContextLoader来完成</p><h3 id="ServletContextListener接口"><a href="#ServletContextListener接口" class="headerlink" title="ServletContextListener接口"></a>ServletContextListener接口</h3><p>ServletContextListener中的核心逻辑便是初始化WebApplicationContext实例并存放至ServletContext中</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletContextListener</span> <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ** Notification that the web application initialization</span></span><br><span class="line"><span class="comment"> ** process is starting.</span></span><br><span class="line"><span class="comment"> ** All ServletContextListeners are notified of context</span></span><br><span class="line"><span class="comment"> ** initialization before any filter or servlet in the web</span></span><br><span class="line"><span class="comment"> ** application is initialized.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> contextInitialized ( ServletContextEvent sce );</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ** Notification that the servlet context is about to be shut down.</span></span><br><span class="line"><span class="comment"> ** All servlets and filters have been destroy()ed before any</span></span><br><span class="line"><span class="comment"> ** ServletContextListeners are notified of context</span></span><br><span class="line"><span class="comment"> ** destruction.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> contextDestroyed ( ServletContextEvent sce );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ContextLoaderListener类"><a href="#ContextLoaderListener类" class="headerlink" title="ContextLoaderListener类"></a>ContextLoaderListener类</h3><p>这是ContextLoaderListener中的contextInitialized()方法，这里主要是用initWebApplicationContext()方法来初始化WebApplicationContext。这里涉及到一个常用类WebApplicationContext：它继承自ApplicationContext，在ApplicationContext的基础上又追加了一些特定于Web的操作及属性</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ContextLoaderListener</span> <span class="title">extends</span> <span class="title">ContextLoader</span> <span class="title">implements</span> <span class="title">ServletContextListener</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span>(<span class="params">WebApplicationContext context</span>) </span>&#123;</span><br><span class="line">super(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the root web application context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span>(<span class="params">ServletContextEvent <span class="keyword">event</span></span>) </span>&#123;</span><br><span class="line">initWebApplicationContext(<span class="keyword">event</span>.getServletContext());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Close the root web application context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span>(<span class="params">ServletContextEvent <span class="keyword">event</span></span>) </span>&#123;</span><br><span class="line">closeWebApplicationContext(<span class="keyword">event</span>.getServletContext());</span><br><span class="line">ContextCleanupListener.cleanupAttributes(<span class="keyword">event</span>.getServletContext());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ContextLoader类"><a href="#ContextLoader类" class="headerlink" title="ContextLoader类"></a>ContextLoader类</h3><p>在initWebApplicationContext()方法中主要体现了WebApplicationContext实例的创建过程。首先，验证WebApplicationContext的存在性，通过查看ServletContext实例中是否有对应key的属性验证WebApplicationContext是否已经创建过实例。如果没有通过createWebApplicationContext()方法来创建实例，并存放至ServletContext中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize Spring's web application context for the given servlet context,</span></span><br><span class="line"><span class="comment"> * using the application context provided at construction time, or creating a new one</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> WebApplicationContext initWebApplicationContext(ServletContext servletContext) &#123;</span><br><span class="line"><span class="keyword">if</span> (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> new IllegalStateException(</span><br><span class="line"><span class="string">"Cannot initialize context because there is already a root application context present - "</span> +</span><br><span class="line"><span class="string">"check whether you have multiple ContextLoader* definitions in your web.xml!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Log logger = LogFactory.getLog(ContextLoader.<span class="keyword">class</span>);</span><br><span class="line">servletContext.log(<span class="string">"Initializing Spring root WebApplicationContext"</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Root WebApplicationContext: initialization started"</span>);</span><br><span class="line">&#125;</span><br><span class="line">long startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.context == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.context = createWebApplicationContext(servletContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.context instanceof ConfigurableWebApplicationContext) &#123;</span><br><span class="line">ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) <span class="keyword">this</span>.context;</span><br><span class="line"><span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line"><span class="keyword">if</span> (cwac.getParent() == <span class="literal">null</span>) &#123;</span><br><span class="line">ApplicationContext parent = loadParentContext(servletContext);</span><br><span class="line">cwac.setParent(parent);</span><br><span class="line">&#125;</span><br><span class="line">configureAndRefreshWebApplicationContext(cwac, servletContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.context);</span><br><span class="line"></span><br><span class="line">ClassLoader ccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line"><span class="keyword">if</span> (ccl == ContextLoader.<span class="keyword">class</span>.getClassLoader()) &#123;</span><br><span class="line">currentContext = <span class="keyword">this</span>.context;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ccl != <span class="literal">null</span>) &#123;</span><br><span class="line">currentContextPerThread.put(ccl, <span class="keyword">this</span>.context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Published root WebApplicationContext as ServletContext attribute with name ["</span> +</span><br><span class="line">WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">long elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">logger.info(<span class="string">"Root WebApplicationContext: initialization completed in "</span> + elapsedTime + <span class="string">" ms"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.context;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line">servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">logger.error(<span class="string">"Context initialization failed"</span>, err);</span><br><span class="line">servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);</span><br><span class="line"><span class="keyword">throw</span> err;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在createWebApplicationContext()方法中，通过BeanUtils.instanceClass()方法创建实例，而WebApplicationContext的实现类名称则通过determineContextClass()方法获得</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate the root WebApplicationContext for this loader, either the</span></span><br><span class="line"><span class="comment"> * default context class or a custom context class if specified.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> WebApplicationContext createWebApplicationContext(ServletContext sc) &#123;</span><br><span class="line"><span class="keyword">Class</span>&lt;?&gt; contextClass = determineContextClass(sc);</span><br><span class="line"><span class="keyword">if</span> (!ConfigurableWebApplicationContext.<span class="keyword">class</span>.isAssignableFrom(contextClass)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Custom context class ["</span> + contextClass.getName() +</span><br><span class="line"><span class="string">"] is not of type ["</span> + ConfigurableWebApplicationContext.<span class="keyword">class</span>.getName() + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>determineContextClass()方法，通过defaultStrategies.getProperty()方法获得实现类的名称，而defaultStrategies是在ContextLoader类的静态代码块中赋值的。具体的途径，则是读取ContextLoader类的同目录下的ContextLoader.properties属性文件来确定的</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the WebApplicationContext implementation class to use, either the</span></span><br><span class="line"><span class="comment"> * default XmlWebApplicationContext or a custom context class if specified.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">Class</span>&lt;?&gt; determineContextClass(ServletContext servletContext) &#123;</span><br><span class="line">String contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM);</span><br><span class="line"><span class="keyword">if</span> (contextClassName != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line"><span class="string">"Failed to load custom context class ["</span> + contextClassName + <span class="string">"]"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">contextClassName = defaultStrategies.getProperty(WebApplicationContext.<span class="keyword">class</span>.getName());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ClassUtils.forName(contextClassName, ContextLoader.<span class="keyword">class</span>.getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line"><span class="string">"Failed to load default context class ["</span> + contextClassName + <span class="string">"]"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ContextLoader.properties</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.context</span><span class="selector-class">.WebApplicationContext</span>=org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.context</span><span class="selector-class">.support</span><span class="selector-class">.XmlWebApplicationContext</span></span><br></pre></td></tr></table></figure><h2 id="diapatcherServlet的初始化"><a href="#diapatcherServlet的初始化" class="headerlink" title="diapatcherServlet的初始化"></a>diapatcherServlet的初始化</h2><p>DispatcherServlet实现了Servlet接口的实现类。Servlet的生命周期分为3个阶段：初始化、运行和销毁。而其初始化阶段可分为</p><ul><li>Servlet容器加载Servlet类，把类的.class文件中的数据读到内存中</li><li>Servlet容器中创建一个ServletConfig对象。该对象中包含了Servlet的初始化配置信息</li><li>Servlet容器创建一个Servlet对象</li><li>Servlet容器调用Servlet对象的init()方法进行初始化</li></ul><h3 id="HttpServletBean"><a href="#HttpServletBean" class="headerlink" title="HttpServletBean"></a>HttpServletBean</h3><p>Servlet的初始化阶段会调用它的init()方法，DispatcherServlet也不例外，在它的父类HttpServletBean中找到了该方法</p><p>init()方法中先通过ServletConfigPropertiesValues()方法对Servlet初始化参数进行封装，然后再将这个Servlet转换成一个BeanWrapper对象，从而能够以spring的方式来对初始化参数的值进行注入。这些属性如contextConfigLocation、namespace等等。同时注册一个属性编辑器，一旦在属性注入的时候遇到Resource类型的属性就会使用ResourceEditor去解析。再留一个initBeanWrapper(bw)方法给子类覆盖，让子类处真正执行BeanWrapper的属性注入工作。但是HttpServletBean的子类FrameworkServlet和DispatcherServlet都没有覆盖其initBeanWrapper(bw)方法，所以创建的BeanWrapper对象没有任何作用</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServletBean</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span></span><br><span class="line"><span class="class"><span class="title">implements</span> <span class="title">EnvironmentCapable</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Map config parameters onto bean properties of this servlet, and</span></span><br><span class="line"><span class="comment"> * invoke subclass initialization.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">public <span class="keyword">final</span> void init() <span class="keyword">throws</span> <span class="type">ServletException</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Initializing servlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">PropertyValues</span> pvs = <span class="keyword">new</span> <span class="type">ServletConfigPropertyValues</span>(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span><br><span class="line"><span class="type">BeanWrapper</span> bw = <span class="type">PropertyAccessorFactory</span>.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line"><span class="type">ResourceLoader</span> resourceLoader = <span class="keyword">new</span> <span class="type">ServletContextResourceLoader</span>(getServletContext());</span><br><span class="line">bw.registerCustomEditor(<span class="type">Resource</span>.<span class="keyword">class</span>, <span class="keyword">new</span> <span class="type">ResourceEditor</span>(resourceLoader, getEnvironment()));</span><br><span class="line">initBeanWrapper(bw);</span><br><span class="line">bw.setPropertyValues(pvs, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="type">BeansException</span> ex) &#123;</span><br><span class="line">logger.error(<span class="string">"Failed to set bean properties on servlet '"</span> + getServletName() + <span class="string">"'"</span>, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">initServletBean();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Servlet '"</span> + getServletName() + <span class="string">"' configured successfully"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> void initServletBean() <span class="keyword">throws</span> <span class="type">ServletException</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FrameworkServlet"><a href="#FrameworkServlet" class="headerlink" title="FrameworkServlet"></a>FrameworkServlet</h3><p>程序接着往下走，运行到了initServletBean()方法。在之前，ContextLoaderListener加载的时候已经创建了WebApplicationContext实例，而在这里是对这个实例的进一步补充初始化。这个方法在HttpServletBean的子类FrameworkServlet中得到了重写</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameworkServlet</span> <span class="keyword">extends</span> <span class="title">HttpServletBean</span> <span class="title">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Overridden method of &#123;@link HttpServletBean&#125;, invoked after any bean properties</span></span><br><span class="line"><span class="comment"> * have been set. Creates this servlet's WebApplicationContext.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> void initServletBean() <span class="keyword">throws</span> <span class="type">ServletException</span> &#123;</span><br><span class="line">getServletContext().log(<span class="string">"Initializing Spring FrameworkServlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.info(<span class="string">"FrameworkServlet '"</span> + getServletName() + <span class="string">"': initialization started"</span>);</span><br><span class="line">&#125;</span><br><span class="line">long startTime = <span class="type">System</span>.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">initFrameworkServlet();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="type">ServletException</span> ex) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="type">RuntimeException</span> ex) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">long elapsedTime = <span class="type">System</span>.currentTimeMillis() - startTime;</span><br><span class="line"><span class="keyword">this</span>.logger.info(<span class="string">"FrameworkServlet '"</span> + getServletName() + <span class="string">"': initialization completed in "</span> +</span><br><span class="line">elapsedTime + <span class="string">" ms"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initWebApplicationContext()方法主要用于创建或刷新WebApplicationContext实例，并对Servlet功能所使用的变量进行初始化。它获得ContextLoaderListener中初始化的rootContext。再通过构造函数和Servlet的contextAttribute属性查找ServletContext来进行webApplicationContext实例的初始化，如果都不行，只能重新创建一个新的实例。最终都要执行configureAndRefreshWebApplicationContext()方法中的refresh()方法完成servlet中配置文件的加载和与rootContext的整合</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize and publish the WebApplicationContext for this servlet.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Delegates to &#123;<span class="doctag">@link</span> #createWebApplicationContext&#125; for actual creation</span></span><br><span class="line"><span class="comment"> * of the context. Can be overridden in subclasses.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the WebApplicationContext instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #FrameworkServlet(WebApplicationContext)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setContextClass</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setContextConfigLocation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> WebApplicationContext initWebApplicationContext() &#123;</span><br><span class="line">WebApplicationContext rootContext =</span><br><span class="line">WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">WebApplicationContext wac = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">wac = <span class="keyword">this</span>.webApplicationContext;</span><br><span class="line"><span class="keyword">if</span> (wac instanceof ConfigurableWebApplicationContext) &#123;</span><br><span class="line">ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line"><span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line"><span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line"><span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line"><span class="keyword">if</span> (cwac.getParent() == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line"><span class="comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line">cwac.setParent(rootContext);</span><br><span class="line">&#125;</span><br><span class="line">configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line"><span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line"><span class="comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line"><span class="comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line">wac = findWebApplicationContext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">wac = createWebApplicationContext(rootContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</span><br><span class="line"><span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class="line"><span class="comment">// support or the context injected at construction time had already been</span></span><br><span class="line"><span class="comment">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class="line">onRefresh(wac);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</span><br><span class="line"><span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line">String attrName = getServletContextAttributeName();</span><br><span class="line">getServletContext().setAttribute(attrName, wac);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.debug(<span class="string">"Published WebApplicationContext of servlet '"</span> + getServletName() +</span><br><span class="line"><span class="string">"' as ServletContext attribute with name ["</span> + attrName + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onRefresh(wac)方法是FrameworkServlet提供的模板方法，在其子类DispatcherServlet的onRefresh()方法中进行了重写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="comment">// For subclasses: do nothing by default.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h3><p>在onRefresh()方法中调用了initStrategies()方法来完成初始化工作，初始化Spring MVC的9个组件</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="keyword">DispatcherServlet </span><span class="keyword">extends </span>FrameworkServlet &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This implementation calls &#123;@link #initStrategies&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Override</span><br><span class="line">protected void onRefresh(ApplicationContext <span class="built_in">context</span>) &#123;</span><br><span class="line">initStrategies(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the strategy objects that this servlet uses.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">protected void initStrategies(ApplicationContext <span class="built_in">context</span>) &#123;</span><br><span class="line">initMultipartResolver(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">initLocaleResolver(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">initThemeResolver(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">initHandlerMappings(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">initHandlerAdapters(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">initHandlerExceptionResolvers(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">initRequestToViewNameTranslator(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">initViewResolvers(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">initFlashMapManager(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="DispatcherServlet详解"><a href="#DispatcherServlet详解" class="headerlink" title="DispatcherServlet详解"></a>DispatcherServlet详解</h1><h2 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h2><p>DispatcherServlet的默认配置在DispatcherServlet.properties（和DispatcherServlet类在一个包下）中，而且是当Spring配置文件中没有指定配置时使用的默认策略</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.LocaleResolver</span>=org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.i18n</span><span class="selector-class">.AcceptHeaderLocaleResolver</span></span><br><span class="line"></span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.ThemeResolver</span>=org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.theme</span><span class="selector-class">.FixedThemeResolver</span></span><br><span class="line"></span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.HandlerMapping</span>=org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.handler</span><span class="selector-class">.BeanNameUrlHandlerMapping</span>,\</span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.mvc</span><span class="selector-class">.annotation</span><span class="selector-class">.DefaultAnnotationHandlerMapping</span></span><br><span class="line"></span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.HandlerAdapter</span>=org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.mvc</span><span class="selector-class">.HttpRequestHandlerAdapter</span>,\</span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.mvc</span><span class="selector-class">.SimpleControllerHandlerAdapter</span>,\</span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.mvc</span><span class="selector-class">.annotation</span><span class="selector-class">.AnnotationMethodHandlerAdapter</span></span><br><span class="line"></span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.HandlerExceptionResolver</span>=org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.mvc</span><span class="selector-class">.annotation</span><span class="selector-class">.AnnotationMethodHandlerExceptionResolver</span>,\</span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.mvc</span><span class="selector-class">.annotation</span><span class="selector-class">.ResponseStatusExceptionResolver</span>,\</span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.mvc</span><span class="selector-class">.support</span><span class="selector-class">.DefaultHandlerExceptionResolver</span></span><br><span class="line"></span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.RequestToViewNameTranslator</span>=org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.view</span><span class="selector-class">.DefaultRequestToViewNameTranslator</span></span><br><span class="line"></span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.ViewResolver</span>=org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.view</span><span class="selector-class">.InternalResourceViewResolver</span></span><br><span class="line"></span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.FlashMapManager</span>=org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.support</span><span class="selector-class">.SessionFlashMapManager</span></span><br></pre></td></tr></table></figure><h2 id="使用的特殊的Bean"><a href="#使用的特殊的Bean" class="headerlink" title="使用的特殊的Bean"></a>使用的特殊的Bean</h2><p>DispatcherServlet默认使用WebApplicationContext作为上下文，该上下文中有些特殊的Bean</p><ul><li>Controller<br>  处理器/页面控制器，做的是MVC中的C的事情，但控制逻辑转移到前端控制器了，用于对请求进行处理</li><li>HandlerMapping<br>  请求到处理器的映射，如果映射成功返回一个HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象、多个HandlerInterceptor拦截器）对象；如BeanNameUrlHandlerMapping将URL与Bean名字映射，映射成功的Bean就是此处的处理器</li><li>HandlerAdapter<br>  HandlerAdapter将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；如SimpleControllerHandlerAdapter将对实现了Controller接口的Bean进行适配，并且掉处理器的handleRequest方法进行功能处理</li><li>ViewResolver<br>  ViewResolver将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；如InternalResourceViewResolver将逻辑视图名映射为jsp视图</li><li>LocalResover<br>  本地化解析，因为Spring支持国际化，因此LocalResover解析客户端的Locale信息从而方便进行国际化</li><li>ThemeResovler<br>  主题解析，通过它来实现一个页面多套风格，即常见的类似于软件皮肤效果</li><li>MultipartResolver<br>  文件上传解析，用于支持文件上传</li><li>HandlerExceptionResolver<br>  处理器异常解析，可以将异常映射到相应的统一错误界面，从而显示用户友好的界面（而不是给用户看到具体的错误信息）</li><li>RequestToViewNameTranslator<br>  当处理器没有返回逻辑视图名等相关信息时，自动将请求URL映射为逻辑视图名</li><li>FlashMapManager<br>  用于管理FlashMap的策略接口，FlashMap用于存储一个请求的输出，当进入另一个请求时作为该请求的输入，通常用于重定向场景，后边会细述</li></ul><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p><img src="/images/DispatcherServlet.png"></p><p><img src="/images/dispatcher-chain.png"></p><ul><li>用户发请求—&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制。</li><li>DispatcherServlet—&gt;HandlerMapping，HandlerMapping将会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器,多个HandlerInterceptor拦截器)。</li><li>DispatcherServlet—&gt;HandlerAdapter,HandlerAdapter将会把处理器包装为适配器，从而支持多种类型的处理器。</li><li>HandlerAdapter—&gt;处理器功能处理方法的调用，HandlerAdapter将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理，并返回一个ModelAndView对象(包含模型数据，逻辑视图名)</li><li>ModelAndView的逻辑视图名—&gt;ViewResolver，ViewResoler将把逻辑视图名解析为具体的View。</li><li>View—&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构</li><li>返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户。</li></ul>]]></content>
    
    <summary type="html">
    
      DispatcherServlet原理讲解
    
    </summary>
    
      <category term="spring" scheme="http://langonggong.com/categories/spring/"/>
    
      <category term="spring mvc" scheme="http://langonggong.com/categories/spring/spring-mvc/"/>
    
    
      <category term="DispatcherServlet" scheme="http://langonggong.com/tags/DispatcherServlet/"/>
    
      <category term="SpringMvc" scheme="http://langonggong.com/tags/SpringMvc/"/>
    
  </entry>
  
  <entry>
    <title>代理</title>
    <link href="http://langonggong.com/2018/10/09/%E4%BB%A3%E7%90%86/"/>
    <id>http://langonggong.com/2018/10/09/代理/</id>
    <published>2018-10-09T15:45:25.000Z</published>
    <updated>2020-06-22T16:40:36.962Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h1><p>正向代理（Forward Proxy）方式下，使用者需要配置网络访问的代理服务器为Cache设备的地址，内网对互联网的所有访问都是通过代理服务器完成</p><p><img src="/images/forward-proxy1.png"></p><p>正向代理多用于与小企业网络环境，Cache设备作为企业网的出口网关提供代理服务（例如翻墙访问谷歌）、内容缓存、Internet访问控制、安全认证等功能</p><p><img src="/images/forward-proxy2.png"></p><h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><h1 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h1>]]></content>
    
    <summary type="html">
    
      代理
    
    </summary>
    
      <category term="计算机网络" scheme="http://langonggong.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://langonggong.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>CND加速</title>
    <link href="http://langonggong.com/2018/10/05/CND%E5%8A%A0%E9%80%9F/"/>
    <id>http://langonggong.com/2018/10/05/CND加速/</id>
    <published>2018-10-05T14:01:53.000Z</published>
    <updated>2020-06-22T16:40:36.953Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="网页加速"><a href="#网页加速" class="headerlink" title="网页加速"></a>网页加速</h1><p>CDN服务商通过将网页内容缓存到各个CND节点上，并将用户请求调度到最优节点上来获取所需的内容，从而加速页面相应速度、减轻源站点的访问负担</p><h1 id="流媒体加速"><a href="#流媒体加速" class="headerlink" title="流媒体加速"></a>流媒体加速</h1><p>将流媒体内容推送到离用户最近的POP点，使得用户能够从网络边缘获取内容，从而提高视频传输质量，缩短访问时间，节省骨干网络流量，避免单一中心的服务器瓶颈问题</p><h1 id="文件传输加速"><a href="#文件传输加速" class="headerlink" title="文件传输加速"></a>文件传输加速</h1><p>使用CND分布式POP点提供下载服务，网站可以将大量文件下载的性能压力和带宽压力交给CND来分担，提高用户的下载速度</p><h1 id="应用协议加速"><a href="#应用协议加速" class="headerlink" title="应用协议加速"></a>应用协议加速</h1><p>不针对特定内容类型进行加速，而是通过对TCP/IP等传输协议优化，或对SSL协议加速</p><h2 id="广域网应用加速"><a href="#广域网应用加速" class="headerlink" title="广域网应用加速"></a>广域网应用加速</h2><p>目的是“让广域网像局域网一样”</p><p>将分布式的IT基础设施如文件服务器、邮件服务器、网络附加存储（NAS）和远程办公室备份系统集中起来，整合到统一的数据中心</p><h2 id="SSL应用加速"><a href="#SSL应用加速" class="headerlink" title="SSL应用加速"></a>SSL应用加速</h2><p>由CDN的专用SSL加速硬件来完成加密解密运算工作，通过认证之后方可建立起数据传输通道。用户的源站点只需信任有限的CDN cache，而无需面对海量用户，从而减轻了繁重的运算和认证压力</p><h2 id="网页压缩"><a href="#网页压缩" class="headerlink" title="网页压缩"></a>网页压缩</h2><p>可以在服务器端对网页数据进行压缩，将压缩后的文件提供给用户，在浏览器端解压显示。<br>CDN为网站提供网页内容的压缩传输，从而加快内容传输速度</p>]]></content>
    
    <summary type="html">
    
      CND加速
    
    </summary>
    
      <category term="计算机网络" scheme="http://langonggong.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="CDN" scheme="http://langonggong.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CDN/"/>
    
    
      <category term="计算机网络" scheme="http://langonggong.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="CDN" scheme="http://langonggong.com/tags/CDN/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡</title>
    <link href="http://langonggong.com/2018/10/05/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://langonggong.com/2018/10/05/负载均衡/</id>
    <published>2018-10-05T13:52:21.000Z</published>
    <updated>2020-06-22T16:40:36.967Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="全局负载均衡（GSLB）"><a href="#全局负载均衡（GSLB）" class="headerlink" title="全局负载均衡（GSLB）"></a>全局负载均衡（GSLB）</h1><h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><h1 id="本地负载均衡（SLB）"><a href="#本地负载均衡（SLB）" class="headerlink" title="本地负载均衡（SLB）"></a>本地负载均衡（SLB）</h1><h2 id="4层调度"><a href="#4层调度" class="headerlink" title="4层调度"></a>4层调度</h2><h2 id="7层调度"><a href="#7层调度" class="headerlink" title="7层调度"></a>7层调度</h2><h2 id="链路负载调度"><a href="#链路负载调度" class="headerlink" title="链路负载调度"></a>链路负载调度</h2>]]></content>
    
    <summary type="html">
    
      CDN详解
    
    </summary>
    
      <category term="计算机网络" scheme="http://langonggong.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://langonggong.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>CDN</title>
    <link href="http://langonggong.com/2018/10/05/CDN/"/>
    <id>http://langonggong.com/2018/10/05/CDN/</id>
    <published>2018-10-05T13:49:15.000Z</published>
    <updated>2020-06-22T16:40:36.953Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>]]></content>
    
    <summary type="html">
    
      CDN详解
    
    </summary>
    
      <category term="计算机网络" scheme="http://langonggong.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="CDN" scheme="http://langonggong.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CDN/"/>
    
    
      <category term="计算机网络" scheme="http://langonggong.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="CDN" scheme="http://langonggong.com/tags/CDN/"/>
    
  </entry>
  
  <entry>
    <title>uml</title>
    <link href="http://langonggong.com/2018/10/03/uml/"/>
    <id>http://langonggong.com/2018/10/03/uml/</id>
    <published>2018-10-03T02:43:16.000Z</published>
    <updated>2020-06-22T16:40:36.961Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><img src="/images/uml-class.png"></p>]]></content>
    
    <summary type="html">
    
      uml类图
    
    </summary>
    
      <category term="软件工程" scheme="http://langonggong.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件工程" scheme="http://langonggong.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="uml" scheme="http://langonggong.com/tags/uml/"/>
    
  </entry>
  
  <entry>
    <title>linux IO模型</title>
    <link href="http://langonggong.com/2018/09/27/IO%E6%A8%A1%E5%9E%8B/"/>
    <id>http://langonggong.com/2018/09/27/IO模型/</id>
    <published>2018-09-27T11:49:04.000Z</published>
    <updated>2020-06-22T16:40:36.956Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在linux系统下面，根据IO操作的是否被阻塞以及同步异步问题进行分类，可以得到下面五种IO模型</p><ul><li>阻塞I/O（blocking I/O）</li><li>非阻塞I/O （nonblocking I/O）</li><li>I/O复用(select 和poll) （I/O multiplexing）</li><li>信号驱动I/O （signal driven I/O (SIGIO)）</li><li>异步I/O （asynchronous I/O (the POSIX aio_functions)）</li></ul><p>对于一个network IO (以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段：</p><ul><li>等待数据准备 (Waiting for the data to be ready)</li><li>将数据从内核拷贝到进程中(Copying the data from the kernel to the process)</li></ul><p>这些IO模型的区别就是在两个阶段上各有不同的情况</p><ul><li>阻塞IO（blocking IO）<br>  调用blocking IO会一直block住对应的进程直到操作完成</li><li>非阻塞IO（non-blocking IO）<br>  在kernel还在准备数据的情况下会立刻返回。在执行recvfrom这个系统调用的时候，如果kernel的数据没有准备好，这时候不会block进程。但是当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内进程是被block的</li><li>同步IO（synchronous IO）<br>  做IO 操作的时候会将进程阻塞。按照这个定义，blocking IO，non-blocking IO，IO multiplexing都属于同步IO</li><li>异步IO（asynchronous IO）<br>  当进程发起IO操作之后，就直接返回，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block</li></ul><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="阻塞IO（blocking-IO）"><a href="#阻塞IO（blocking-IO）" class="headerlink" title="阻塞IO（blocking IO）"></a>阻塞IO（blocking IO）</h2><p><img src="/images/Blocking-IO.png"></p><p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p><p>所以，blocking IO的特点就是在IO执行的两个阶段（等待数据和拷贝数据两个阶段）都被block了。</p><p>可能同时出现的上千甚至上万次的客户端请求，“线程池”或“连接池”或许可以缓解部分压力，但是不能解决所有问题。总之，多线程模型可以方便高效的解决小规模的服务请求，但面对大规模的服务请求，多线程模型也会遇到瓶颈，可以用非阻塞接口来尝试解决这个问题</p><h2 id="非阻塞IO（non-blocking-IO）"><a href="#非阻塞IO（non-blocking-IO）" class="headerlink" title="非阻塞IO（non-blocking IO）"></a>非阻塞IO（non-blocking IO）</h2><p>Linux下，可以通过设置socket使其变为non-blocking<br><img src="/images/Nonblocking-IO.png"></p><p>从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p><p>所以，在非阻塞式IO中，用户进程其实是需要不断的主动询问kernel数据准备好了没有。</p><p>循环调用recv()将大幅度推高CPU 占用率；此外，在这个方案中recv()更多的是起到检测“操作是否完成”的作用，实际操作系统提供了更为高效的检测“操作是否完成“作用的接口，例如select()多路复用模式，可以一次检测多个连接是否活跃</p><h2 id="多路复用IO（IO-multiplexing）"><a href="#多路复用IO（IO-multiplexing）" class="headerlink" title="多路复用IO（IO multiplexing）"></a>多路复用IO（IO multiplexing）</h2><p>有些地方也称这种IO方式为事件驱动IO(event driven IO)。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程</p><p><img src="/images/IO-multiplexing.png"></p><p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p><p>这个图和blocking IO的图其实并没有太大的不同，事实上还更差一些。因为这里需要使用两个系统调用(select和recvfrom)，而blocking IO只调用了一个系统调用(recvfrom)。但是，用select的优势在于它可以同时处理多个connection</p><p>在多路复用模型中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。因此select()与非阻塞IO类似</p><p>select()接口并不是实现“事件驱动”的最好选择。因为当需要探测的句柄值较大时，select()接口本身需要消耗大量时间去轮询各个句柄</p><h2 id="信号驱动I-O（signal-driven-I-O）"><a href="#信号驱动I-O（signal-driven-I-O）" class="headerlink" title="信号驱动I/O（signal driven I/O）"></a>信号驱动I/O（signal driven I/O）</h2><p><img src="/images/Signal-Driven-IO.png"></p><p>两次调用，两次返回<br>允许套接口进行信号驱动I/O,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据</p><h2 id="异步I-O-（asynchronous-I-O）"><a href="#异步I-O-（asynchronous-I-O）" class="headerlink" title="异步I/O （asynchronous I/O）"></a>异步I/O （asynchronous I/O）</h2><p><img src="/images/Asynchronous-IO.png"></p><p>用户进程发起read操作之后，立刻就可以开始去做其它的事。从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了</p><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>非阻塞IO ，IO请求时加上O_NONBLOCK一类的标志位，立刻返回，IO没有就绪会返回错误，需要请求进程主动轮询不断发IO请求直到返回正确。</p><p>IO复用同非阻塞IO本质一样，不过利用了新的select系统调用，由内核来负责本来是请求进程该做的轮询操作。看似比非阻塞IO还多了一个系统调用开销，不过因为可以支持多路IO，才算提高了效率。</p><p>信号驱动IO，调用sigaltion系统调用，当内核中IO数据就绪时以SIGIO信号通知请求进程，请求进程再把数据从内核读入到用户空间，这一步是阻塞的。</p><p>异步IO，如定义所说，不会因为IO操作阻塞，IO操作全部完成才通知请求进程</p><p><img src="/images/IO-Comparison.png"><br>左边四种方式，第一阶段不同，第二阶段相同（调用recvFrom发生阻塞）</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p><a href="https://blog.csdn.net/hguisu/article/details/7453390" target="_blank" rel="noopener">socket阻塞与非阻塞，同步与异步、I/O模型</a><br><a href="https://my.oschina.net/XYleung/blog/295122" target="_blank" rel="noopener">网络IO模型</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      linux IO模型
    
    </summary>
    
      <category term="linux" scheme="http://langonggong.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://langonggong.com/tags/linux/"/>
    
      <category term="IO" scheme="http://langonggong.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>BlockingQueue</title>
    <link href="http://langonggong.com/2018/09/25/BlockingQueue/"/>
    <id>http://langonggong.com/2018/09/25/BlockingQueue/</id>
    <published>2018-09-25T07:53:14.000Z</published>
    <updated>2020-06-22T16:40:36.953Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>阻塞队列与我们平常接触的普通队列(LinkedList或ArrayList等)的最大不同点，在于阻塞队列支持阻塞添加和阻塞删除方法</p><p>Java中的阻塞队列接口BlockingQueue继承自Queue接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量）</span></span><br><span class="line">    <span class="comment">//在成功时返回 true，如果此队列已满，则抛IllegalStateException。 </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量） </span></span><br><span class="line">    <span class="comment">// 将指定的元素插入此队列的尾部，如果该队列已满， </span></span><br><span class="line">    <span class="comment">//则在到达指定的等待时间之前等待可用的空间,该方法可中断 </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//将指定的元素插入此队列的尾部，如果该队列已满，则一直等到（阻塞）。 </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取并移除此队列的头部，如果没有元素则等待（阻塞）， </span></span><br><span class="line">    <span class="comment">//直到有元素将唤醒等待线程执行该操作 </span></span><br><span class="line">    <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取并移除此队列的头部，在指定的等待时间前一直等到获取元素， //超过时间方法将结束</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//从此队列中移除指定元素的单个实例（如果存在）。 </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>插入方法：<br>add(E e) : 添加成功返回true，失败抛IllegalStateException异常<br>offer(E e) : 成功返回 true，如果此队列已满，则返回 false。<br>put(E e) :将元素插入此队列的尾部，如果该队列已满，则一直阻塞</p></li><li><p>删除方法:<br>remove(Object o) :移除指定元素,成功返回true，失败返回false<br>poll() : 获取并移除此队列的头元素，若队列为空，则返回 null<br>take()：获取并移除此队列头元素，若没有元素则一直阻塞。</p></li><li><p>检查方法<br>element() ：获取但不移除此队列的头元素，没有元素则抛异常<br>peek() :获取但不移除此队列的头；若队列为空，则返回 null。</p></li></ul><h1 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>ArrayBlockingQueue的内部是通过一个可重入锁ReentrantLock和两个Condition条件对象来实现阻塞<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** 存储数据的数组 *</span>/</span></span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Object</span>[] items;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">**获取数据的索引，主要用于take，poll，peek，remove方法 *</span>/</span></span></span><br><span class="line">    <span class="built_in">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">**添加数据的索引，主要用于 put, offer, or add 方法*</span>/</span></span></span><br><span class="line">    <span class="built_in">int</span> putIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** 队列元素的个数 *</span>/</span></span></span><br><span class="line">    <span class="built_in">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** 控制并非访问的锁 *</span>/</span></span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">**notEmpty条件对象，用于通知take方法队列已有元素，可执行获取操作 *</span>/</span></span></span><br><span class="line">    private <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">**notFull条件对象，用于通知put方法队列未满，可执行添加操作 *</span>/</span></span></span><br><span class="line">    private <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">       迭代器</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    transient Itrs itrs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><p>put方法，它是一个阻塞添加的方法<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put方法，阻塞时可中断</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span>(<span class="params">E e</span>) throws InterruptedException </span>&#123;</span><br><span class="line">     checkNotNull(e);</span><br><span class="line">      final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">      <span class="keyword">lock</span>.lockInterruptibly();<span class="comment">//该方法可中断</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//当队列元素个数与数组长度相等时，无法添加元素</span></span><br><span class="line">          <span class="keyword">while</span> (count == items.length)</span><br><span class="line">              <span class="comment">//将当前调用线程挂起，添加到notFull条件队列中等待唤醒</span></span><br><span class="line">              notFull.<span class="keyword">await</span>();</span><br><span class="line">          enqueue(e);<span class="comment">//如果队列没有满直接添加。。</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">lock</span>.unlock();</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h2 id="take方法"><a href="#take方法" class="headerlink" title="take方法"></a>take方法</h2><p>take()方法，是一个阻塞方法，直接获取队列头元素并删除<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从队列头部删除，队列没有元素就阻塞，可中断</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">take</span>(<span class="params"></span>) throws InterruptedException </span>&#123;</span><br><span class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">      <span class="keyword">lock</span>.lockInterruptibly();<span class="comment">//中断</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//如果队列没有元素</span></span><br><span class="line">          <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">              <span class="comment">//执行阻塞操作</span></span><br><span class="line">              notEmpty.<span class="keyword">await</span>();</span><br><span class="line">          <span class="keyword">return</span> dequeue();<span class="comment">//如果队列有元素执行删除操作</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">lock</span>.unlock();</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h1 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h1><p>LinkedBlockingQueue是一个由链表实现的有界队列阻塞队列，但大小默认值为Integer.MAX_VALUE，所以在使用LinkedBlockingQueue时建议手动传值，为其提供我们所需的大小，避免队列过大造成机器负载或者内存爆满等情况</p><p>在正常情况下，链接队列的吞吐量要高于基于数组的队列（ArrayBlockingQueue），因为其内部实现添加和删除操作使用的两个ReenterLock来控制并发执行，而ArrayBlockingQueue内部只是使用一个ReenterLock控制并发，因此LinkedBlockingQueue的吞吐量要高于ArrayBlockingQueue<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue&lt;E&gt;</span> <span class="keyword">extends</span> <span class="title">AbstractQueue&lt;E&gt;</span></span></span><br><span class="line"><span class="class">        <span class="title">implements</span> <span class="title">BlockingQueue&lt;E&gt;</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点类，用于存储数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    static <span class="class"><span class="keyword">class</span> <span class="title">Node&lt;E&gt;</span> </span>&#123;</span><br><span class="line">        <span class="type">E</span> item;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span>&lt;<span class="type">E</span>&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span>(<span class="type">E</span> x) &#123; item = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 阻塞队列的大小，默认为Integer.MAX_VALUE */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当前阻塞队列中的元素个数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> count = <span class="keyword">new</span> <span class="type">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞队列的头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    transient <span class="type">Node</span>&lt;<span class="type">E</span>&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞队列的尾节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> transient <span class="type">Node</span>&lt;<span class="type">E</span>&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取并移除元素时使用的锁，如take, poll, etc */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> takeLock = <span class="keyword">new</span> <span class="type">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** notEmpty条件对象，当队列没有数据时用于挂起执行删除的线程 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 添加元素时使用的锁如 put, offer, etc */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> putLock = <span class="keyword">new</span> <span class="type">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** notFull条件对象，当队列数据已满时用于挂起执行添加的线程 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> notFull = putLock.newCondition();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="take方法-1"><a href="#take方法-1" class="headerlink" title="take方法"></a>take方法</h2><ul><li>如果队列没有数据就挂起当前线程到 notEmpty条件对象的等待队列中一直等待，如果有数据就删除节点并返回数据项，同时唤醒后续消费线程(如果不为空)</li><li>尝试唤醒条件对象notFull上等待队列中的添加线程</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">E</span> take() <span class="keyword">throws</span> <span class="type">InterruptedException</span> &#123;</span><br><span class="line">    <span class="type">E</span> x;</span><br><span class="line">    int <span class="built_in">c</span> = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="built_in">count</span> = this.<span class="built_in">count</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> takeLock = this.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">count</span>.<span class="keyword">get</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        <span class="built_in">c</span> = <span class="built_in">count</span>.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">c</span> &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">c</span> == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">signalNotFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="put方法-1"><a href="#put方法-1" class="headerlink" title="put方法"></a>put方法</h2><ul><li>如果队列已满就挂起当前线程到notFull条件对象的等待队列中一直等待，如果有空余节点就添加当前节点，同时唤醒后续生产线程(如果队列未满)</li><li>尝试唤醒条件对象notEmpty上等待队列中的添加线程</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> put(E e) <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger <span class="keyword">count</span> = <span class="keyword">this</span>.<span class="keyword">count</span>;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">count</span>.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(node);</span><br><span class="line">        c = <span class="keyword">count</span>.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ul><li><p>队列大小有所不同，ArrayBlockingQueue是有界的初始化必须指定大小，而LinkedBlockingQueue可以是有界的也可以是无界的(Integer.MAX_VALUE)，对于后者而言，当添加速度大于移除速度时，在无界的情况下，可能会造成内存溢出等问题。</p></li><li><p>数据存储容器不同，ArrayBlockingQueue采用的是数组作为数据存储容器，而LinkedBlockingQueue采用的则是以Node节点作为连接对象的链表。</p></li><li><p>由于ArrayBlockingQueue采用的是数组的存储容器，因此在插入或删除元素时不会产生或销毁任何额外的对象实例，而LinkedBlockingQueue则会生成一个额外的Node对象。这可能在长时间内需要高效并发地处理大批量数据的时，对于GC可能存在较大影响。</p></li><li><p>两者的实现队列添加或移除的锁不一样，ArrayBlockingQueue实现的队列中的锁是没有分离的，即添加操作和移除操作采用的同一个ReenterLock锁，而LinkedBlockingQueue实现的队列中的锁是分离的，其添加采用的是putLock，移除采用的则是takeLock，这样能大大提高队列的吞吐量，也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p></li></ul>]]></content>
    
    <summary type="html">
    
      java阻塞队列LinkedBlockingQueue与ArrayBlockingQueue
    
    </summary>
    
      <category term="java" scheme="http://langonggong.com/categories/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://langonggong.com/tags/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>synchronized</title>
    <link href="http://langonggong.com/2018/09/23/synchronized/"/>
    <id>http://langonggong.com/2018/09/23/synchronized/</id>
    <published>2018-09-23T07:59:04.000Z</published>
    <updated>2020-06-22T16:40:36.961Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><p><img src="/images/java-object2.png"></p><ul><li>对象头<br>标记字（32位虚拟机4B，64位虚拟机8B） + 类型指针（32位虚拟机4B，64位虚拟机8B）+ [数组长（对于数组对象才需要此部分信息）]。用于存储对象的元数据信息<ul><li>Mark Word：数据的长度在32位和64位虚拟机（未开启压缩指针）中分别为32bit和64bit，存储对象自身的运行时数据如哈希值等。Mark Word一般被设计为非固定的数据结构，以便存储更多的数据信息和复用自己的存储空间。</li><li>类型指针：指向它的类元数据的指针，用于判断对象属于哪个类的实例</li></ul></li><li>实例数据<br>存储的是真正有效数据，如各种字段内容，各字段的分配策略为longs/doubles、ints、shorts/chars、bytes/boolean、oops(ordinary object pointers)，相同宽度的字段总是被分配到一起，便于之后取数据。父类定义的变量会出现在子类定义的变量的前面</li><li>对齐填充<br>对于64位虚拟机来说，对象大小必须是8B的整数倍，不够的话需要占位填充。仅仅起到占位符的作用，并非必须</li></ul><h1 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h1><p>对象头信息是与对象自身定义的数据无关的额外存储成本，但是考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据，它会根据对象的状态复用自己的存储空间，也就是说，Mark Word会随着程序的运行发生变化，变化状态如下（32位虚拟机）</p><table style="text-align:center">   <tr>      <td rowspan="2">锁状态</td>      <td colspan="2">25 bit</td>      <td rowspan="2">4 bit</td>      <td>1 bit</td>      <td>2 bit</td>   </tr>   <tr>      <td>23 bit</td>      <td>2 bit</td>      <td>是否是偏向锁</td>      <td>锁标志位</td>   </tr>   <tr>      <td>无锁状态</td>      <td colspan="2">对象HashCode</td>      <td>对象分代年龄</td>      <td>0</td>      <td>01</td>   </tr>   <tr>      <td>轻量级锁</td>      <td colspan="4">指向栈中锁记录的指针</td>      <td colspan="1">00</td>   </tr>    <tr>      <td>偏向锁</td>      <td>线程ID</td>      <td> Epoch</td>      <td>对象分代年龄</td>      <td>1</td>      <td>01</td>   </tr>   <tr>      <td>重量级锁</td>      <td colspan="4">指向互斥量（重量级锁）的指针</td>      <td colspan="1">10</td>   </tr>   <tr>      <td>GC标记</td>      <td colspan="4">空</td>      <td colspan="1">11</td>   </tr></table><h1 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h1><p>重量级锁也就是通常说synchronized的对象锁，锁标识位为10，其中指针指向的是monitor对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">//记录个数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL; <span class="comment">//指向持有ObjectMonitor对象的线程</span></span><br><span class="line">    _WaitSet      = NULL; <span class="comment">//处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表( 每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSe t集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示</p><p><img src="/images/monitor2.png"></p><h1 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncCodeBlock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//同步代码库</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译上述代码并使用javap反编译后得到字节码如下</p><p><img src="/images/sync-code-block-monitor.png"></p><p>从字节码中可知同步语句块的实现使用的是monitorenter 和 monitorexit 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置，当执行monitorenter指令时，当前线程将试图获取 objectref(即对象锁) 所对应的 monitor 的持有权，当 objectref 的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。如果当前线程已经拥有 objectref 的 monitor 的持有权，那它可以重入这个 monitor (关于重入性稍后会分析)，重入时计数器的值也会加 1。倘若其他线程已经拥有 objectref 的 monitor 的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放 monitor(锁)并设置计数器值为0 ，其他线程将有机会持有 monitor 。值得注意的是编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。从字节码中也可以看出多了一个monitorexit指令，它就是异常结束时被执行的释放monitor 的指令</p><p>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。如果一个同步方法执行期间抛 出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用javap反编译后的字节码如下</p><p><img src="/images/sync-method-monitor.png"></p><h1 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h1><p>锁可以升级但不能降级，目的是为了提高获得锁和释放锁的效率<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">无锁</span> <span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">偏向锁</span> <span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">轻量级</span> <span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">重量级</span></span><br></pre></td></tr></table></figure></p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>引入背景：大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁，减少不必要的CAS操作。</p><p>加锁：当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程（此时会引发竞争，偏向锁会升级为轻量级锁）。</p><p>膨胀过程：当前线程执行CAS获取偏向锁失败（这一步是偏向锁的关键），表示在该锁对象上存在竞争并且这个时候另外一个线程获得偏向锁所有权。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，并从偏向锁所有者的私有Monitor Record列表中获取一个空闲的记录，并将Object设置LightWeight Lock状态并且Mark Word中的LockRecord指向刚才持有偏向锁线程的Monitor record，最后被阻塞在安全点的线程被释放，进入到轻量级锁的执行路径中，同时被撤销偏向锁的线程继续往下执行同步代码。</p><p><img src="/images/BiasedLockingExpand.png"></p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>引入背景：这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态（即单线程执行环境），在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒</p><p>加锁：<br>（1）当对象处于无锁状态时（RecordWord值为HashCode，状态位为001），线程首先从自己的可用moniter record列表中取得一个空闲的moniter record，初始Nest和Owner值分别被预先设置为1和该线程自己的标识，一旦monitor record准备好然后我们通过CAS原子指令安装该monitor record的起始地址到对象头的LockWord字段，如果存在其他线程竞争锁的情况而调用CAS失败，则只需要简单的回到monitorenter重新开始获取锁的过程即可。</p><p>（2）对象已经被膨胀同时Owner中保存的线程标识为获取锁的线程自己，这就是重入（reentrant）锁的情况，只需要简单的将Nest加1即可。不需要任何原子操作，效率非常高。</p><p>（3）对象已膨胀但Owner的值为NULL，当一个锁上存在阻塞或等待的线程同时锁的前一个拥有者刚释放锁时会出现这种状态，此时多个线程通过CAS原子指令在多线程竞争状态下试图将Owner设置为自己的标识来获得锁，竞争失败的线程在则会进入到第四种情况（4）的执行路径。</p><p>（4）对象处于膨胀状态同时Owner不为NULL(被锁住)，在调用操作系统的重量级的互斥锁之前先自旋一定的次数，当达到一定的次数时如果仍然没有成功获得锁，则开始准备进入阻塞状态，首先将rfThis的值原子性的加1，由于在加1的过程中可能会被其他线程破坏Object和monitor record之间的关联，所以在原子性加1后需要再进行一次比较以确保LockWord的值没有被改变，当发现被改变后则要重新monitorenter过程。同时再一次观察Owner是否为NULL，如果是则调用CAS参与竞争锁，锁竞争失败则进入到阻塞状态。</p><p><img src="/images/synchronizedExpand.png"></p><h1 id="不同锁的比较"><a href="#不同锁的比较" class="headerlink" title="不同锁的比较"></a>不同锁的比较</h1><div class="table-container"><table><thead><tr><th style="text-align:center">锁</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th><th style="text-align:center">适用场景</th></tr></thead><tbody><tr><td style="text-align:center">偏向锁</td><td style="text-align:center">加锁和解锁不需要额外的消耗，和执行非同步方法仅存在纳秒级差别</td><td style="text-align:center">如果线程间存在竞争，会带来额外的锁撤销的消耗</td><td style="text-align:center">适用于只有一个线程访问同步块的场景</td></tr><tr><td style="text-align:center">轻量级锁</td><td style="text-align:center">竞争的线程不会阻塞，提高响应速度</td><td style="text-align:center">始终得不到锁的竞争线程自旋消耗CPU</td><td style="text-align:center">追求响应时间，同步代码块执行较快</td></tr><tr><td style="text-align:center">重量级锁</td><td style="text-align:center">线程竞争不使用自旋，不消耗CPU</td><td style="text-align:center">线程阻塞，响应时间慢</td><td style="text-align:center">追求吞吐量，同步块执行比较慢</td></tr></tbody></table></div><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p><a href="https://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="noopener">深入理解Java并发之synchronized实现原理</a><br><a href="https://blog.csdn.net/u012465296/article/details/53022317" target="_blank" rel="noopener">Java中synchronized的实现原理与应用</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      synchronized原理详解
    
    </summary>
    
      <category term="java" scheme="http://langonggong.com/categories/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://langonggong.com/tags/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>condition</title>
    <link href="http://langonggong.com/2018/09/22/condition/"/>
    <id>http://langonggong.com/2018/09/22/condition/</id>
    <published>2018-09-22T01:14:04.000Z</published>
    <updated>2020-06-22T16:40:36.957Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在java中，对于任意一个java对象，它都拥有一组定义在java.lang.Object上监视器方法，包括wait()，wait(long timeout)，notify()，notifyAll()，这些方法配合synchronized关键字一起使用可以实现等待/通知模式。</p><p>同样，Condition接口也提供了类似Object监视器的方法，通过与Lock配合来实现等待/通知模式</p><div class="table-container"><table><thead><tr><th style="text-align:center">对比项</th><th style="text-align:center">Object监视器</th><th style="text-align:center">Condition</th></tr></thead><tbody><tr><td style="text-align:center">前置条件</td><td style="text-align:center">获取对象的锁</td><td style="text-align:center">调用Lock.lock获取锁，调用Lock.newCondition获取Condition对象</td></tr><tr><td style="text-align:center">调用方式</td><td style="text-align:center">直接调用，比如object.notify()</td><td style="text-align:center">直接调用，比如condition.await()</td></tr><tr><td style="text-align:center">等待队列的个数</td><td style="text-align:center">一个</td><td style="text-align:center">多个</td></tr><tr><td style="text-align:center">当前线程释放锁进入等待状态</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">当前线程释放锁进入等待状态，在等待状态中不断响中断</td><td style="text-align:center">不支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">当前线程释放锁并进入超时等待状态</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">当前线程释放锁并进入等待状态直到将来的某个时间</td><td style="text-align:center">不支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">唤醒等待队列中的一个线程</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">唤醒等待队列中的全部线程</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr></tbody></table></div><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>实现一个简单的有界队列，队列为空时，队列的删除操作将会阻塞直到队列中有新的元素，队列已满时，队列的插入操作将会阻塞直到队列出现空位</p><p><img src="/images/condition-queue.png"></p><h1 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 使当前线程进入等待状态直到被通知(signal)或中断</span></span><br><span class="line"><span class="comment">  * 当其他线程调用singal()或singalAll()方法时，该线程将被唤醒</span></span><br><span class="line"><span class="comment">  * 当其他线程调用interrupt()方法中断当前线程</span></span><br><span class="line"><span class="comment">  * await()相当于synchronized等待唤醒机制中的wait()方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//当前线程进入等待状态，直到被唤醒，该方法不响应中断要求</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//调用该方法，当前线程进入等待状态，直到被唤醒或被中断或超时</span></span><br><span class="line"> <span class="comment">//其中nanosTimeout指的等待超时时间，单位纳秒</span></span><br><span class="line"> <span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//同awaitNanos，但可以指明时间单位</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//调用该方法当前线程进入等待状态，直到被唤醒、中断或到达某个时</span></span><br><span class="line"> <span class="comment">//间期限(deadline),如果没到指定时间就被唤醒，返回true，其他情况返回false</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//唤醒一个等待在Condition上的线程，该线程从等待方法返回前必须</span></span><br><span class="line"> <span class="comment">//获取与Condition相关联的锁，功能与notify()相同</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//唤醒所有等待在Condition上的线程，该线程从等待方法返回前必须</span></span><br><span class="line"> <span class="comment">//获取与Condition相关联的锁，功能与notifyAll()相同</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>Condition的具体实现类是AQS的内部类ConditionObject。AQS中存在两种队列，一种是同步队列，一种是等待队列，而等待队列就相对于Condition而言的。注意在使用Condition前必须获得锁，同时在Condition的等待队列上的结点与前面同步队列的结点是同一个类即Node，其结点的waitStatus的值为CONDITION。在实现类ConditionObject中有两个结点分别是firstWaiter和lastWaiter，firstWaiter代表等待队列第一个等待结点，lastWaiter代表等待队列最后一个等待结点，如下</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> &#123;</span></span><br><span class="line">    <span class="comment">//等待队列第一个等待结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="comment">//等待队列最后一个等待结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">    <span class="comment">//省略其他代码.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个Condition都对应着一个等待队列，也就是说如果一个锁上创建了多个Condition对象，那么也就存在多个等待队列。等待队列是一个FIFO的队列，在队列中每一个节点都包含了一个线程的引用，而该线程就是Condition对象上等待的线程。当一个线程调用了await()相关的方法，那么该线程将会释放锁，并构建一个Node节点封装当前线程的相关信息加入到等待队列中进行等待，直到被唤醒、中断、超时才从队列中移出</p><h2 id="await-实现"><a href="#await-实现" class="headerlink" title="await()实现"></a>await()实现</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="comment">//判断线程是否被中断</span></span><br><span class="line">  <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">  <span class="comment">//创建新结点加入等待队列并返回</span></span><br><span class="line">  Node node = addConditionWaiter();</span><br><span class="line">  <span class="comment">//释放当前线程锁即释放同步状态</span></span><br><span class="line">  <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">  <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//判断结点是否同步队列(SyncQueue)中,即是否被唤醒</span></span><br><span class="line">  <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    <span class="comment">//挂起线程</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//判断是否被中断唤醒，如果是退出循环。</span></span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//被唤醒后执行自旋操作争取获得锁，同时判断线程是否被中断</span></span><br><span class="line">  <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">    interruptMode = REINTERRUPT;</span><br><span class="line">  <span class="comment">// clean up if cancelled</span></span><br><span class="line">  <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">//清理等待队列中不为CONDITION状态的结点</span></span><br><span class="line">    unlinkCancelledWaiters();</span><br><span class="line">  <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">    reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//添加到等待队列</span><br><span class="line">private <span class="keyword">Node</span> <span class="title">addConditionWaiter</span>() &#123;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">t</span> = lastWaiter;</span><br><span class="line">  // 判断是否为结束状态的结点并移除</span><br><span class="line">  if (t != null &amp;&amp; t.waitStatus != <span class="keyword">Node</span>.<span class="title">CONDITION</span>) &#123;</span><br><span class="line">    unlinkCancelledWaiters();</span><br><span class="line">    t = lastWaiter;</span><br><span class="line">  &#125;</span><br><span class="line">  //创建新结点状态为CONDITION</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">node</span> = new <span class="keyword">Node</span><span class="title">(Thread</span>.currentThread(), <span class="keyword">Node</span>.<span class="title">CONDITION</span>);</span><br><span class="line">  //加入等待队列</span><br><span class="line">  if (t == null) &#123;</span><br><span class="line">    firstWaiter = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">  &#125; else</span> &#123;</span><br><span class="line">    t.nextWaiter = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">  &#125;</span></span><br><span class="line"><span class="title">  lastWaiter</span> = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">  return</span> <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>调用addConditionWaiter()方法将当前线程封装成node结点加入等待队列</li><li>调用fullyRelease(node)方法释放同步状态并唤醒同步队列后继结点的线程</li><li>调用isOnSyncQueue(node)方法判断结点是否在同步队列中，注意是个while循环，如果同步队列中没有该结点就直接挂起该线程，如果线程被唤醒后就调用acquireQueued(node, savedState)执行自旋操作争取锁，即当前线程结点从等待队列转移到同步队列并开始努力获取锁</li></ul><p><img src="/images/condition-await.png"></p><h2 id="signal-实现"><a href="#signal-实现" class="headerlink" title="signal()实现"></a>signal()实现</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//判断是否持有独占锁，如果不是抛出异常</span></span><br><span class="line">  <span class="comment">//只有独占模式采用等待队列，而共享模式下是没有等待队列的，也就没法使用Condition</span></span><br><span class="line">  <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">  Node first = firstWaiter;</span><br><span class="line">  <span class="comment">//唤醒等待队列第一个结点的线程</span></span><br><span class="line">  <span class="keyword">if</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">    doSignal(first);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void doSignal(Node <span class="built_in">first</span>) &#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//移除条件等待队列中的第一个结点</span></span><br><span class="line">    <span class="comment">//然后重新维护条件等待队列的firstWaiter和lastWaiter的指向</span></span><br><span class="line">    if ((firstWaiter = <span class="built_in">first</span>.nextWaiter) == <span class="built_in">null</span>) &#123;</span><br><span class="line">      lastWaiter = <span class="built_in">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">first</span>.nextWaiter = <span class="built_in">null</span>;</span><br><span class="line">    <span class="comment">//如果被通知节点没有进入到同步队列并且条件等待队列还有不为空的节点，则继续循环通知后续结点</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (!transferForSignal(<span class="built_in">first</span>) &amp;&amp; (<span class="built_in">first</span> = firstWaiter) != <span class="built_in">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">final boolean transferForSignal(<span class="keyword">Node</span> <span class="title">node</span>) &#123;</span><br><span class="line">  //尝试设置唤醒结点的waitStatus为<span class="number">0</span>，即初始化状态</span><br><span class="line">  //如果设置失败，说明当前结点<span class="keyword">node</span><span class="title">的waitStatus</span>已不为</span><br><span class="line">  //CONDITION状态，那么只能是结束状态了，因此返回<span class="literal">false</span></span><br><span class="line">  //返回doSignal()方法中继续唤醒其他结点的线程，注意这里并</span><br><span class="line">  //不涉及并发问题，所以CAS操作失败只可能是预期值不为CONDITION，</span><br><span class="line">  //而不是多线程设置导致预期值变化，毕竟操作该方法的线程是持有锁的。</span><br><span class="line">  if (!compareAndSetWaitStatus(<span class="keyword">node</span><span class="title">, Node</span>.CONDITION, <span class="number">0</span>))</span><br><span class="line">    return <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  //加入同步队列并返回前驱结点p</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">p</span> = enq(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">  int</span> ws = p.waitStatus;</span><br><span class="line">  //判断前驱结点是否为结束结点(<span class="attr">CANCELLED=</span><span class="number">1</span>)或者在设置</span><br><span class="line">  //前驱节点状态为<span class="keyword">Node</span>.<span class="title">SIGNAL</span>状态失败时，唤醒被通知节点代表的线程</span><br><span class="line">  if (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, <span class="keyword">Node</span>.<span class="title">SIGNAL</span>))</span><br><span class="line">    //唤醒<span class="keyword">node</span><span class="title">结点的线程</span></span><br><span class="line"><span class="title">    LockSupport</span>.unpark(<span class="keyword">node</span>.<span class="title">thread</span>);</span><br><span class="line">  return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被唤醒后的线程，将从前面的await()方法中的while循环中退出，因为此时该线程的结点已在同步队列中，那么while (!isOnSyncQueue(node))将不在符合循环条件，进而调用AQS的acquireQueued()方法加入获取同步状态的竞争中，这就是等待唤醒机制的整个流程实现原理<br><img src="/images/condition-signal.png"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p><a href="https://blog.csdn.net/javazejian/article/details/75043422" target="_blank" rel="noopener">深入剖析基于并发AQS的(独占锁)重入锁(ReetrantLock)及其Condition实现原理</a><br><a href="https://www.jianshu.com/p/be2dc7c878dc" target="_blank" rel="noopener">java并发编程之Condition</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      condition原理详解
    
    </summary>
    
      <category term="java" scheme="http://langonggong.com/categories/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://langonggong.com/tags/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口算法</title>
    <link href="http://langonggong.com/2018/09/19/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/"/>
    <id>http://langonggong.com/2018/09/19/滑动窗口算法/</id>
    <published>2018-09-19T14:56:15.000Z</published>
    <updated>2020-06-22T16:40:36.965Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>题目描述</p><blockquote><p>有一个整型数组 arr 和一个大小为 w 的窗口从数组的最左边滑到最右边,窗口每次向右边滑一个位置。 返回一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值。 以数组为[4,3,5,4,3,3,6,7]，w=3为例。因为第一个窗口[4,3,5]的最大值为5，第二个窗口[3,5,4]的最大值为5，第三个窗口[5,4,3]的最大值为5。第四个窗口[4,3,3]的最大值为4。第五个窗口[3,3,6]的最大值为6。第六个窗口[3,6,7]的最大值为7。所以最终返回[5,5,5,4,6,7]。</p><p>给定整形数组arr及它的大小n，同时给定w，请返回res数组。保证w小于等于n，同时保证数组大小小于等于500。</p></blockquote><p>解题思路</p><blockquote><p>使用一个长度为w的双端队列，存储数组的索引。每次有新元素加入，将小于或等于改元素的值的原有元素对应的索引删掉，将不在该窗口范围的索引删掉。队列的索引对应的元素值倒序排序。则队列的第一个元素始终为该窗口内最大值的索引</p></blockquote><p>参考代码<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlideWindow</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] slide(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> w) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || arr.length &lt; w) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedList&lt;Integer&gt; <span class="keyword">list</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length - w + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="comment">//把较小的值挤掉，按照从大到小排序</span></span><br><span class="line">      <span class="keyword">while</span> (!<span class="keyword">list</span>.isEmpty() &amp;&amp; arr[<span class="keyword">list</span>.peekLast()] &lt;= arr[i]) &#123;</span><br><span class="line">        <span class="keyword">list</span>.pollLast();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">list</span>.addLast(i);</span><br><span class="line">      <span class="comment">//不在窗口里面的元素删掉</span></span><br><span class="line">      <span class="keyword">if</span> (i - <span class="keyword">list</span>.peekFirst() == w) &#123;</span><br><span class="line">        <span class="keyword">list</span>.pollFirst();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= w) &#123;</span><br><span class="line">        result[index++] = arr[<span class="keyword">list</span>.peekFirst()];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      滑动窗口算法
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="队列" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="队列" scheme="http://langonggong.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>小范围排序</title>
    <link href="http://langonggong.com/2018/09/07/%E5%B0%8F%E8%8C%83%E5%9B%B4%E6%8E%92%E5%BA%8F/"/>
    <id>http://langonggong.com/2018/09/07/小范围排序/</id>
    <published>2018-09-06T17:04:14.000Z</published>
    <updated>2020-06-22T16:40:36.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>题目描述</p><blockquote><p>已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序</p></blockquote><p>解题思路</p><blockquote><p>使用变种的堆排序：维护一个长度为k的最小根堆，将数组的元素不断的加入堆中，调整后将堆顶弹出赋给数组，将排序的范围始终限制在长度为k、近乎排序的堆中</p></blockquote><p>参考代码<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class ScaleSort &#123;</span><br><span class="line">  public <span class="type">int</span>[] sortElement(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == null || arr.<span class="built_in">length</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建长度为k的小根堆，此过程也可以在heap数组中进行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = k / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      headAdjust(arr, i, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将调整好的最小根堆赋值给heap数组</span></span><br><span class="line">    <span class="type">int</span>[] heap = new <span class="type">int</span>[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">      heap[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//每从最小跟堆中弹出堆顶给数组，就从数组中弹出一个元素给堆，再次调整为最小跟堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; arr.<span class="built_in">length</span>; i++) &#123;</span><br><span class="line">      arr[i - k] = heap[<span class="number">0</span>];</span><br><span class="line">      heap[<span class="number">0</span>] = arr[i];</span><br><span class="line">      headAdjust(heap, <span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最小根堆不能保证左右节点之间的大小顺序，所以不能直接将heap完整复制给arr</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = arr.<span class="built_in">length</span> - k; i &lt; arr.<span class="built_in">length</span>; i++) &#123;</span><br><span class="line">      arr[i] = heap[<span class="number">0</span>];</span><br><span class="line">      <span class="comment">//由于堆中没有新的元素加入，只能每次将堆顶放到后面，对前面一部分进行堆调整</span></span><br><span class="line">      swap(heap, <span class="number">0</span>, arr.<span class="built_in">length</span> - i - <span class="number">1</span>);</span><br><span class="line">      headAdjust(heap, <span class="number">0</span>, arr.<span class="built_in">length</span> - i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//堆调整，保证[index,length)这条支线满足最小根堆</span></span><br><span class="line">  private <span class="type">void</span> headAdjust(<span class="type">int</span>[] arr, <span class="type">int</span> <span class="keyword">index</span>, <span class="type">int</span> <span class="built_in">length</span>) &#123;</span><br><span class="line">    <span class="type">int</span> minIndex, left, right;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">index</span> &lt; <span class="built_in">length</span>) &#123;</span><br><span class="line">      minIndex = <span class="keyword">index</span>;</span><br><span class="line">      left = <span class="number">2</span> * <span class="keyword">index</span> + <span class="number">1</span>;</span><br><span class="line">      right = <span class="number">2</span> * <span class="keyword">index</span> + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (left &lt; <span class="built_in">length</span> &amp;&amp; arr[left] &lt; arr[minIndex]) &#123;</span><br><span class="line">        minIndex = left;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (right &lt; <span class="built_in">length</span> &amp;&amp; arr[right] &lt; arr[minIndex]) &#123;</span><br><span class="line">        minIndex = right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//临界条件，表示无需再调整</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">index</span> == minIndex) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(arr, <span class="keyword">index</span>, minIndex);</span><br><span class="line">      <span class="keyword">index</span> = minIndex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static <span class="type">void</span> swap(<span class="type">int</span>[] arr, <span class="type">int</span> index1, <span class="type">int</span> index2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index1 == index2) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tmp = arr[index1];</span><br><span class="line">    arr[index1] = arr[index2];</span><br><span class="line">    arr[index2] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      几乎有序的数组进行排序
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>DNS解析</title>
    <link href="http://langonggong.com/2018/09/06/DNS%E8%A7%A3%E6%9E%90/"/>
    <id>http://langonggong.com/2018/09/06/DNS解析/</id>
    <published>2018-09-06T08:46:42.000Z</published>
    <updated>2020-06-22T16:40:36.954Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>nslookup<br><img src="/images/nslook-baidu.png"></p><p>第一行Server是：DNS服务器的主机名—10.4.1.14<br>第二行Address是：它的IP地址—10.4.1.14#53</p><p>百度有一个cname = www.a.shifen.com的别名</p><p>下面的Name是：解析的URL—www.a.shifen.com<br>Address是：解析出来的IP—220.181.112.244和220.181.111.188</p><p>dig www.baidu.com +trace<br><img src="/images/dig-baidu.jpg">    </p><p>Dig工具会在本地计算机做迭代，然后记录查询的过程</p><ul><li>第一步，向我这台机器的ISPDNS获取到根域服务区的13个IP和主机名[b-j].root-servers.net.</li><li>第二步，向其中的一台根域服务器（m.root-servers.net）发送www.baidu.com的查询请求，他返回了com.顶级域的服务器名称</li><li>第三步，向com.域的一台服务器i.gtld-servers.net请求,www.baidu.com，他返回了baidu.com域的服务器IP（未显示）和名称，百度有5台顶级域的服务器</li><li>第四步，向百度的顶级域服务器（202.108.22.220）请求www.baidu.com，他发现这个www有个别名，而不是一台主机，别名是www.a.shifen.com</li></ul><p>当dns请求到别名的时候，查询不会终止，而是重新发起查询别名的请求，此处返回的是www.a.shifen.com，然后继续请求</p><p>使用dig www.a.shifen.com +trace查看<br><img src="/images/dig-shifen.jpg">    </p><p>再一次去请求com域，重复上面的步骤，最终从ns X.a.shifen.com中一台拿到了一条A记录，便是www.baidu.com的IP地址了</p>]]></content>
    
    <summary type="html">
    
      DNS解析
    
    </summary>
    
      <category term="计算机网络" scheme="http://langonggong.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://langonggong.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="DNS" scheme="http://langonggong.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>基数排序</title>
    <link href="http://langonggong.com/2018/09/05/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://langonggong.com/2018/09/05/基数排序/</id>
    <published>2018-09-05T15:41:05.000Z</published>
    <updated>2020-06-22T16:40:36.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>1、构造从0到9的10个桶，将数组的每个元素按照个位数的大小放入对应的桶中<br>2、构造新的10个桶，将原桶中的数字依次弹出，按照十位数的大小依次放入对应的新桶中<br>3、对百位、千位等按照上述步骤处理</p><p>需考虑负数</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RadixSort</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">radixSort</span>(<span class="params"><span class="keyword">int</span>[] arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> posNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        posNum++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] posArr = <span class="keyword">new</span> <span class="keyword">int</span>[posNum];</span><br><span class="line">    <span class="keyword">int</span>[] negArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length - posNum];</span><br><span class="line">    <span class="keyword">int</span> posIndex = <span class="number">0</span>, negIndex = <span class="number">0</span>, posMax = <span class="number">0</span>, negMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        posArr[posIndex++] = i;</span><br><span class="line">        posMax = Math.max(posMax, i);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> j = -i;</span><br><span class="line">        negArr[negIndex++] = j;</span><br><span class="line">        negMax = Math.max(j, negMax);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    radixSortForPositive(posArr, posMax);</span><br><span class="line">    radixSortForPositive(negArr, negMax);</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=negArr.length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">      arr[index++] = -negArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;posArr.length;i++) &#123;</span><br><span class="line">      arr[index++] = posArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//针对正数的基数排序</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSortForPositive</span>(<span class="params"><span class="keyword">int</span>[] arr, <span class="keyword">int</span> max</span>) </span>&#123;</span><br><span class="line">    List&lt;LinkedList&lt;Integer&gt;&gt; temp1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;LinkedList&lt;Integer&gt;&gt; temp2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      temp1.<span class="keyword">add</span>(<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">      temp2.<span class="keyword">add</span>(<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按照个位数的大小将元素放入桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">      temp1.<span class="keyword">get</span>(i % <span class="number">10</span>).<span class="keyword">add</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> <span class="keyword">base</span> = <span class="number">10</span>; <span class="keyword">base</span> &lt;= max; <span class="keyword">base</span> *= <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (LinkedList&lt;Integer&gt; integers : temp1) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!integers.isEmpty()) &#123;</span><br><span class="line">          Integer integer = integers.pop();</span><br><span class="line">          temp2.<span class="keyword">get</span>((integer / <span class="keyword">base</span>) % <span class="number">10</span>).<span class="keyword">add</span>(integer);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      List&lt;LinkedList&lt;Integer&gt;&gt; temp;</span><br><span class="line">      temp = temp1;</span><br><span class="line">      temp1 = temp2;</span><br><span class="line">      temp2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (LinkedList&lt;Integer&gt; integers : temp1) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Integer integer : integers) &#123;</span><br><span class="line">        arr[index++] = integer;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      按照位数从低到高依次排序
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>计数排序</title>
    <link href="http://langonggong.com/2018/09/05/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://langonggong.com/2018/09/05/计数排序/</id>
    <published>2018-09-05T15:37:25.000Z</published>
    <updated>2020-06-22T16:40:36.966Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>根据数组最大最小值构建数组，记录每个数字出现次数</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class CountingSort &#123;</span><br><span class="line"></span><br><span class="line">  public <span class="type">int</span>[] countingSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == null || arr.<span class="built_in">length</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">min</span> = arr[<span class="number">0</span>], <span class="built_in">max</span> = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.<span class="built_in">length</span>;i++) &#123;</span><br><span class="line">      <span class="built_in">min</span> = Math.<span class="built_in">min</span>(<span class="built_in">min</span>, arr[i]);</span><br><span class="line">      <span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] store = new <span class="type">int</span>[<span class="built_in">max</span> - <span class="built_in">min</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;arr.<span class="built_in">length</span>;j++) &#123;</span><br><span class="line">      store[arr[j] - <span class="built_in">min</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;store.<span class="built_in">length</span>;k++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (store[k]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        arr[<span class="keyword">index</span>++] = k + <span class="built_in">min</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      根据数组最大最小值构建数组，记录每个数字出现次数
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>希尔排序</title>
    <link href="http://langonggong.com/2018/09/05/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>http://langonggong.com/2018/09/05/希尔排序/</id>
    <published>2018-09-05T15:00:26.000Z</published>
    <updated>2020-06-22T16:40:36.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>令k=2<br>1、将数组分成k等分，构建length/2个间隔为k的数组，对每个数组进行插入排序<br>2、k=k*2,重复步骤1</p><p>插入排序:假设前面的数组已经有序，则找到改点合适的位置插入(该点下沉到合适的位置)</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] shellSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = arr.length ;</span><br><span class="line">    <span class="comment">//将数组2等分，4等分...直到一等分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = length &gt;&gt; <span class="number">1</span>; gap &gt; <span class="number">0</span>; gap &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">//对生成的多个数组进行插入排序</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> start = gap; start &lt; arr.length; start++) &#123;</span><br><span class="line">        <span class="comment">//对单个数组进行插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> <span class="keyword">index</span> = start; <span class="keyword">index</span> &gt;= gap; <span class="keyword">index</span> -= gap) &#123;</span><br><span class="line">          <span class="keyword">if</span> (arr[<span class="keyword">index</span> - gap] &gt; arr[<span class="keyword">index</span>]) &#123;</span><br><span class="line">            swap(arr, <span class="keyword">index</span> - gap, <span class="keyword">index</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> swap(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index1 == index2) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[index1];</span><br><span class="line">    arr[index1] = arr[index2];</span><br><span class="line">    arr[index2] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      直接插入排序的优化
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="http://langonggong.com/2018/09/05/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://langonggong.com/2018/09/05/堆排序/</id>
    <published>2018-09-04T16:28:14.000Z</published>
    <updated>2020-06-22T16:40:36.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>1、构建大根堆，满足父大于子，堆顶为最大值<br>2、将堆顶与最后一位进行替换，将前n-1位调整为大根堆<br>3、对前n-1位大根堆重复过程2</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class HeapSort &#123;</span><br><span class="line"></span><br><span class="line">  public <span class="type">int</span>[] heapSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == null || arr.<span class="built_in">length</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建大根堆，使整棵树满足:父&gt;子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = arr.<span class="built_in">length</span> / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="comment">//每次调整，都要保证将后面所有的都调整一遍</span></span><br><span class="line">      headAdjust(arr, i, arr.<span class="built_in">length</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将堆顶（最大值）替换到第j个点，然后将前面j-1个点调整为大根堆，</span></span><br><span class="line">    <span class="comment">//对前j-1个点重复此过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=arr.<span class="built_in">length</span><span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">      swap(arr, <span class="number">0</span>, j);</span><br><span class="line">      headAdjust(arr, <span class="number">0</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//保证[index,length)单条支线上的点满足:最大值出现在index点</span></span><br><span class="line">  private <span class="type">void</span> headAdjust(<span class="type">int</span>[] arr, <span class="type">int</span> <span class="keyword">index</span>,<span class="type">int</span> <span class="built_in">length</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">index</span> &lt; <span class="built_in">length</span>) &#123;</span><br><span class="line">      <span class="type">int</span> left = <span class="number">2</span> * <span class="keyword">index</span> + <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> right = <span class="number">2</span> * <span class="keyword">index</span> + <span class="number">2</span>;</span><br><span class="line">      <span class="type">int</span> <span class="built_in">max</span> = <span class="keyword">index</span>;</span><br><span class="line">      <span class="keyword">if</span> (left &lt; <span class="built_in">length</span> &amp;&amp; arr[left] &gt; arr[<span class="keyword">index</span>]) &#123;</span><br><span class="line">        <span class="built_in">max</span> = left;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (right &lt; <span class="built_in">length</span> &amp;&amp; arr[right] &gt; arr[<span class="built_in">max</span>]) &#123;</span><br><span class="line">        <span class="built_in">max</span> = right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">index</span> == <span class="built_in">max</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(arr, <span class="keyword">index</span>, <span class="built_in">max</span>);</span><br><span class="line">      <span class="keyword">index</span> = <span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static <span class="type">void</span> swap(<span class="type">int</span>[] arr, <span class="type">int</span> index1, <span class="type">int</span> index2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index1 == index2) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tmp = arr[index1];</span><br><span class="line">    arr[index1] = arr[index2];</span><br><span class="line">    arr[index2] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      将数组作为堆结构进行处理
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://langonggong.com/2018/09/03/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://langonggong.com/2018/09/03/快速排序/</id>
    <published>2018-09-03T15:56:00.000Z</published>
    <updated>2020-06-22T16:40:36.964Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>选择任意一点，将元素划分为小于该值和大于该值的左右两部分，递归次过程</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> int[] <span class="built_in">quickSort</span>(int[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == null || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> void process(int[] arr, int <span class="keyword">left</span>, int <span class="keyword">right</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">left</span> &gt;= <span class="keyword">right</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    int random = <span class="keyword">left</span> + (int) <span class="type">Math</span>.random() * (<span class="keyword">right</span> - <span class="keyword">left</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">swap</span>(arr, random, <span class="keyword">right</span>);</span><br><span class="line">    int <span class="built_in">partition</span> = <span class="built_in">partition</span>(arr, <span class="keyword">left</span>, <span class="keyword">right</span>);</span><br><span class="line">    process(arr, <span class="keyword">left</span>, <span class="built_in">partition</span> - <span class="number">1</span>);</span><br><span class="line">    process(arr, <span class="built_in">partition</span> + <span class="number">1</span>, <span class="keyword">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将小于或等于right的元素替换到左边，大于right的元素保持不动</span></span><br><span class="line"><span class="comment">   * partition加一递增，指向最近一个被替换到左边的位置</span></span><br><span class="line"><span class="comment">   * 当数组遍历完，right处的元素被替换到partition所指的位置</span></span><br><span class="line"><span class="comment">   * partition左边的值全部小于或等于该值，右边的值全部大于该值</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> int <span class="built_in">partition</span>(int[] arr, int <span class="keyword">left</span>, int <span class="keyword">right</span>) &#123;</span><br><span class="line">    int <span class="built_in">partition</span> = <span class="keyword">left</span> - <span class="number">1</span>;</span><br><span class="line">    int index = <span class="keyword">left</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt;= <span class="keyword">right</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[index] &lt;= arr[<span class="keyword">right</span>]) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr, ++<span class="built_in">partition</span>, index);</span><br><span class="line">      &#125;</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">partition</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> void <span class="built_in">swap</span>(int[] arr, int index1, int index2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index1 == index2) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    int tmp = arr[index1];</span><br><span class="line">    arr[index1] = arr[index2];</span><br><span class="line">    arr[index2] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      选择任意一点，将元素划分为小于该值和大于该值的左右两部分，递归次过程
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="http://langonggong.com/2018/09/03/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://langonggong.com/2018/09/03/归并排序/</id>
    <published>2018-09-03T13:24:32.000Z</published>
    <updated>2020-06-22T16:40:36.964Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>二分后递归调用自身，然后对这两部分处理后的结果进行排序</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> MergeSort &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">int</span>[] mergeSort(<span class="built_in">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    divide(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    return arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> void divide(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">left</span> &gt;= <span class="built_in">right</span>) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>) / <span class="number">2</span>;</span><br><span class="line">    divide(arr, <span class="built_in">left</span>, <span class="built_in">mid</span>);</span><br><span class="line">    divide(arr, <span class="built_in">mid</span> + <span class="number">1</span>, <span class="built_in">right</span>);</span><br><span class="line">    merge(arr, <span class="built_in">left</span>, <span class="built_in">mid</span>, <span class="built_in">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> void merge(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">mid</span>, <span class="built_in">int</span> <span class="built_in">right</span>) &#123;</span><br><span class="line">    <span class="built_in">int</span>[] result = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="built_in">right</span> - <span class="built_in">left</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">int</span> i = <span class="built_in">left</span>, j = <span class="built_in">mid</span> + <span class="number">1</span>, index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= <span class="built_in">mid</span> &amp;&amp; j &lt;= <span class="built_in">right</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">        result[index++] = arr[i++];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result[index++] = arr[j++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= <span class="built_in">mid</span>) &#123;</span><br><span class="line">      result[index++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= <span class="built_in">right</span>) &#123;</span><br><span class="line">      result[index++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> k=<span class="number">0</span>;k&lt;result.length;k++) &#123;</span><br><span class="line">      arr[<span class="built_in">left</span> + k] = result[k];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      二分后递归调用自身，然后对这两部分处理后的结果进行排序
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>插入排序</title>
    <link href="http://langonggong.com/2018/09/02/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://langonggong.com/2018/09/02/插入排序/</id>
    <published>2018-09-02T15:10:00.000Z</published>
    <updated>2020-06-22T16:40:36.964Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>假设前面的数组已经有序，则找到改点合适的位置插入(该点下沉到合适的位置)</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InsertionSort</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">insertionSort</span>(<span class="params"><span class="keyword">int</span>[] arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> j = i;</span><br><span class="line">      <span class="keyword">while</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">          swap(arr, j, j - <span class="number">1</span>);</span><br><span class="line">          j--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span>(<span class="params"><span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      假设前面的数组已经有序，则找到改点合适的位置插入
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>选择排序</title>
    <link href="http://langonggong.com/2018/09/02/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://langonggong.com/2018/09/02/选择排序/</id>
    <published>2018-09-02T14:58:40.000Z</published>
    <updated>2020-06-22T16:40:36.967Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>选择最小值与第一个数字交换</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SelectSort</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">selectionSort</span>(<span class="params"><span class="keyword">int</span>[] arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> mini = i;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">        mini = arr[j] &lt; arr[mini] ? j : mini;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(arr, i, mini);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span>(<span class="params"><span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      选择最小值与第一个数字交换
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="http://langonggong.com/2018/09/02/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://langonggong.com/2018/09/02/冒泡排序/</id>
    <published>2018-09-02T14:49:03.000Z</published>
    <updated>2020-06-22T16:40:36.962Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>最大值上浮</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BubbleSort</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">bubbleSort</span>(<span class="params"><span class="keyword">int</span>[] arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=arr.length<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">          swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span>(<span class="params"><span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      最大值上浮
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>AQS</title>
    <link href="http://langonggong.com/2018/09/01/AQS/"/>
    <id>http://langonggong.com/2018/09/01/AQS/</id>
    <published>2018-09-01T06:14:14.000Z</published>
    <updated>2020-06-22T16:40:36.953Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在JDK1.5之前，一般是靠synchronized关键字来实现线程对共享变量的互斥访问。synchronized是在字节码上加指令，依赖于底层操作系统的Mutex Lock实现。<br>AQS定义了一套多线程访问共享资源的同步器框架，是整个java.util.concurrent包的基石，Lock、ReadWriteLock、CountDowndLatch、CyclicBarrier、Semaphore、ThreadPoolExecutor等都是在AQS的基础上实现的。</p><h1 id="同步队列-CLH"><a href="#同步队列-CLH" class="headerlink" title="同步队列(CLH)"></a>同步队列(CLH)</h1><p>AQS维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）</p><p><img src="/images/AQS同步队列模型.png"></p><p>AQS的内部队列是CLH同步锁的一种变形。其主要从两方面进行了改造，节点的结构与节点等待机制</p><ul><li>在结构上引入了头结点和尾节点，分别指向队列的头和尾，尝试获取锁、入队列、释放锁等实现都与头尾节点相关</li><li>为了可以处理timeout和cancel操作，每个node维护一个指向前驱的指针。如果一个node的前驱被cancel，这个node可以前向移动使用前驱的状态字段</li><li>在每个node里面使用一个状态字段来控制阻塞/唤醒，而不是自旋</li><li>head结点使用的是傀儡结点</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span>&#123;</span></span><br><span class="line"><span class="comment">//指向同步队列队头</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指向同步的队尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步状态，在不同的子类有不同的含义</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略其他代码......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h2><p>Node结点是对每一个访问同步代码的线程的封装，从图中的Node的数据结构也可看出，其包含了需要同步的线程本身以及线程的状态，如是否被阻塞，是否等待唤醒，是否已经被取消等。每个Node结点内部关联其前继结点prev和后继结点next，这样可以方便线程释放锁后快速唤醒下一个在等待的线程，Node是AQS的内部类，其数据结构如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">//共享模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">//独占模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标识线程已处于结束状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//等待被唤醒状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//条件状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//在共享模式中使用表示获得的同步状态会被传播</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待状态,存在CANCELLED、SIGNAL、CONDITION、PROPAGATE 4种</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同步队列中前驱结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">//同步队列中后继结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">//请求锁的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="comment">//等待队列中的后继结点，这个与Condition有关</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否为共享模式</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取前驱结点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中SHARED和EXCLUSIVE常量分别代表共享模式和独占模式，所谓共享模式是一个锁允许多条线程同时操作，如Semaphore、CountDownLatch采用的就是基于AQS的共享模式实现的，而独占模式则是同一个时间段只能有一个线程对共享资源进行操作，多余的请求线程需要排队等待，如ReentranLock。变量waitStatus则表示当前被封装成Node结点的等待状态，共有4种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE</p><ul><li>CANCELLED：值为1，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node的结点，其结点的waitStatus为CANCELLED，即结束状态，进入该状态后的结点将不会再变化。</li><li>SIGNAL：值为-1，被标识为该等待唤醒状态的后继结点，当其前继结点的线程释放了同步锁或被取消，将会通知该后继结点的线程执行。说白了，就是处于唤醒状态，只要前继结点释放锁，就会通知标识为SIGNAL状态的后继结点的线程执行。</li><li>CONDITION：值为-2，与Condition相关，该标识的结点处于等待队列中，结点的线程等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。</li><li>PROPAGATE：值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态。</li><li>0状态：值为0，代表初始化状态。</li></ul><h2 id="AQS-lock-操作"><a href="#AQS-lock-操作" class="headerlink" title="AQS lock()操作"></a>AQS lock()操作</h2><p><img src="/images/AQS-lock.png"></p><h1 id="Sync与State实现"><a href="#Sync与State实现" class="headerlink" title="Sync与State实现"></a>Sync与State实现</h1><h2 id="state机制"><a href="#state机制" class="headerlink" title="state机制"></a>state机制</h2><p>volatile 变量 state;  用于同步线程之间的共享状态。通过 CAS 和 volatile 保证其原子性和可见性。<br>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步状态 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//CAS </span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this  </span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> unsafe.<span class="title">compareAndSwapInt</span><span class="params">(<span class="keyword">this</span>, stateOffset, expect, update)</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同实现类的Sync与State"><a href="#不同实现类的Sync与State" class="headerlink" title="不同实现类的Sync与State"></a>不同实现类的Sync与State</h2><p>基于AQS构建的Synchronizer包括ReentrantLock,Semaphore,CountDownLatch, ReetrantRead WriteLock,FutureTask等，这些Synchronizer实际上最基本的东西就是原子状态的获取和释放，只是条件不一样而已</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>需要记录当前线程获取原子状态的次数，如果次数为零，那么就说明这个线程放弃了锁（也有可能其他线程占据着锁从而需要等待），如果次数大于1，也就是获得了重进入的效果，而其他线程只能被park住，直到这个线程重进入锁次数变成0而释放原子状态。以下为ReetranLock的FairSync的tryAcquire实现代码解析</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公平获取锁</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//如果当前重进入数为0,说明有机会取得锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果是第一个等待者，并且设置重进入数成功，那么当前线程获得锁</span></span><br><span class="line">        <span class="keyword">if</span> (isFirst(current) &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="comment">//如果当前线程本身就持有锁，那么叠加重进入数，并且继续获得锁</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">     <span class="comment">//以上条件都不满足，那么线程进入等待队列。</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平锁和非公平锁</p><ul><li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了</li><li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面</li></ul><p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态</p><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>信号量维护了一个许可集，我们在初始化Semaphore时需要为这个许可集传入一个数量值，该数量值代表同一时间能访问共享资源的线程数量。以下为Semaphore的FairSync实现</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> tryAcquireShared(<span class="keyword">int</span> acquires) &#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="built_in">for</span> (;;) &#123;</span><br><span class="line">         Thread first = getFirstQueuedThread();</span><br><span class="line">         <span class="comment">//如果当前等待队列的第一个线程不是当前线程，那么就返回-1表示当前线程需要等待</span></span><br><span class="line">         <span class="built_in">if</span> (first != null &amp;&amp; first != current)</span><br><span class="line">              <span class="built_in">return</span> <span class="number">-1</span>;</span><br><span class="line">         <span class="comment">//如果当前队列没有等待者，或者当前线程就是等待队列第一个等待者，</span></span><br><span class="line">         <span class="comment">//那么先取得semaphore还有几个许可证，并且减去当前线程需要的许可证得到剩下的值</span></span><br><span class="line">         <span class="keyword">int</span> <span class="built_in">available</span> = getState();</span><br><span class="line">         <span class="keyword">int</span> remaining = <span class="built_in">available</span> - acquires;</span><br><span class="line">         <span class="comment">//如果remining&lt;0，那么反馈给AQS当前线程需要等待，如果remaining&gt;0，并且设置availble成功设置成剩余数，</span></span><br><span class="line">         <span class="comment">//那么返回剩余值(&gt;0)，也就告知AQS当前线程拿到许可，可以继续执行。</span></span><br><span class="line">         <span class="built_in">if</span> (remaining &lt; <span class="number">0</span> ||compareAndSetState(<span class="built_in">available</span>, remaining))</span><br><span class="line">             <span class="built_in">return</span> remaining;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>void acquire()：从此信号量获取一个许可前线程将一直阻塞</li><li>void acquire(int n)：从此信号量获取给定数目许可，在提供这些许可前一直将线程阻塞</li><li>void release()：释放一个许可，将其返回给信号量</li><li>void release(int n)：释放n个许可</li></ul><p>使用场景：一般用于控制对某组资源的访问控制</p><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p><code>闭锁</code>则要保持其状态，在这个状态到达终止态之前，所有线程都会被park住，闭锁可以设定初始值，这个值的含义就是这个闭锁需要被countDown()几次，因为每次CountDown是sync.releaseShared(1),而一开始初始值为10的话，那么这个闭锁需要被countDown()十次，才能够将这个初始值减到0，从而释放原子状态，让等待的所有线程通过</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//await时候执行，只查看当前需要countDown数量减为0了，如果为0，说明可以继续执行，</span></span><br><span class="line"><span class="comment">//否则需要park住，等待countDown次数足够，并且unpark所有等待线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> getState() == <span class="number">0</span>? <span class="number">1</span> : -1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//countDown 时候执行，如果当前countDown数量为0，说明没有线程await，</span></span><br><span class="line"><span class="comment">//直接返回false而不需要唤醒park住线程，</span></span><br><span class="line"><span class="comment">//如果不为0，得到剩下需要 countDown的数量并且compareAndSet,</span></span><br><span class="line"><span class="comment">//最终返回剩下的countDown数量是否为0,供AQS判定是否释放所有await线程。</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         <span class="keyword">int</span> c = getState();</span><br><span class="line">         <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">int</span> nextc = c<span class="number">-1</span>;</span><br><span class="line">         <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">             <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>void await()：调用await()方法的线程会被挂起，它会等待直到countDown值为0才继续执行</li><li>boolean await(long timeout, TimeUnit unit)：await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</li><li>void countDown()：将countDown值减1</li></ul><p>使用场景：多个子线程都结束后才运行主线程，并且子线程不会阻塞，例如多步计算后的汇总工作</p><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>需要记录任务的执行状态，当调用其实例的get方法时,内部类Sync会去调用AQS的acquireSharedInterruptibly()方法，而这个方法会反向调用Sync实现的tryAcquireShared()方法，即让具体实现类决定是否让当前线程继续还是park,而FutureTask的tryAcquireShared方法所做的唯一事情就是检查状态，如果是RUNNING状态那么让当前线程park。而跑任务的线程会在任务结束时调用FutureTask 实例的set方法（与等待线程持相同的实例），设定执行结果，并且通过unpark唤醒正在等待的线程，返回结果</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get时待用，只检查当前任务是否完成或者被Cancel，如果未完成并且没有被cancel，那么告诉AQS当前线程需要进入等待队列并且park住</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> ignore)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> innerIsDone()? <span class="number">1</span> : -1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//判定任务是否完成或者被Cancel</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">innerIsDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ranOrCancelled(getState()) &amp;&amp;    runner == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//get时调用，对于CANCEL与其他异常进行抛错</span></span><br><span class="line"><span class="function">V <span class="title">innerGet</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquireSharedNanos(<span class="number">0</span>,nanosTimeout))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">    <span class="keyword">if</span> (getState() == CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(exception);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//任务的执行线程执行完毕调用（set(V v)）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">innerSet</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = getState();</span><br><span class="line">        <span class="comment">//如果线程任务已经执行完毕，那么直接返回（多线程执行任务？）</span></span><br><span class="line">        <span class="keyword">if</span> (s == RAN)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果被CANCEL了，那么释放等待线程，并且会抛错</span></span><br><span class="line">        <span class="keyword">if</span> (s == CANCELLED) &#123;</span><br><span class="line">            releaseShared(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">        <span class="comment">//如果成功设定任务状态为已完成，那么设定结果，unpark等待线程(调用get()方法而阻塞的线程),以及后续清理工作（一般由FutrueTask的子类实现）</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(s, RAN)) &#123;</span><br><span class="line">            result = v;</span><br><span class="line">            releaseShared(<span class="number">0</span>);</span><br><span class="line">            done();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><p>Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否锁定状态</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试获取资源，立即返回。成功则返回true，否则false。</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// 这里限定只能为1个量</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">//state为0才设置为1，不可重入！</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//设置为当前线程独占资源</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试释放资源，立即返回。成功则为true，否则false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// 限定为1个量</span></span><br><span class="line">    <span class="keyword">if</span> (getState() == <span class="number">0</span>)<span class="comment">//既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(<span class="number">0</span>);<span class="comment">//释放资源，放弃占有状态</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p><a href="https://blog.csdn.net/javazejian/article/details/75043422#aqs%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%A6%82%E8%A6%81" target="_blank" rel="noopener">深入剖析基于并发AQS的(独占锁)重入锁(ReetrantLock)及其Condition实现原理</a><br><a href="https://blog.csdn.net/javazejian/article/details/76167357" target="_blank" rel="noopener">剖析基于并发AQS的共享锁的实现(基于信号量Semaphore)</a><br><a href="https://blog.csdn.net/vernonzheng/article/details/8275624" target="_blank" rel="noopener">Java多线程（七）之同步器基础：AQS框架深入分析</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-jtp04186/" target="_blank" rel="noopener">非阻塞算法简介</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      AQS定义了一套多线程访问共享资源的同步器框架，是整个java.util.concurrent包的基石
    
    </summary>
    
      <category term="java" scheme="http://langonggong.com/categories/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://langonggong.com/tags/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>KMP</title>
    <link href="http://langonggong.com/2018/08/30/KMP/"/>
    <id>http://langonggong.com/2018/08/30/KMP/</id>
    <published>2018-08-29T16:44:12.000Z</published>
    <updated>2020-06-22T16:40:36.957Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h1><p>字符串组成为</p><script type="math/tex; mode=display">p_0...p_k...p_i...p_{i+k}...p_j...p_{j+k}...p_m...p_{m+k}...</script><p>假设\(next_{[i+k]}==next_{[m+k]}\)，表示\(p_0…p_{i+k}=p_j…p_{m+k}\) </p><ul><li>如果\(p_{i+k+1}=p_{m+k+1}\)，则\(next_{[m+k+1]}==next_{[m+k]}+1\) </li><li>如果\(p_{i+k+1}!=p_{m+k+1}\)，有\(next_{[i+k]}=k\)，表示\(p_0…p_{k}=p_i…p_{i+k}=p_m…p_{m+k}\)，<ul><li>如果\(p_{m+k+1}=p_{k+1}\)，则\(next_{[m+k+1]}=next_{[k]}+1\)</li><li>如果\(p_{m+k+1}!=p_{k+1}\)，则有\(next_{[k]}=l\)，继续上面的过程</li></ul></li></ul><p>总结下来，若\(next_{[i]}==next_{[j]}\)</p><ul><li>if \(p_{i+1}=p_{j+1}\), then \(next_{[j+1]}==next_{[j]+1}\)</li><li>else \(i==next_{[i]}\),继续上一步</li></ul><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> KMP &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] getNextArr(<span class="keyword">char</span>[] pattern) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pattern == <span class="keyword">null</span> || pattern.length == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] <span class="keyword">next</span> = <span class="keyword">new</span> <span class="keyword">int</span>[pattern.length];</span><br><span class="line">    <span class="keyword">next</span>[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">next</span>[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> currentNext=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos &lt; pattern.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pattern[pos - <span class="number">1</span>] == pattern[currentNext]) &#123;</span><br><span class="line">        <span class="keyword">next</span>[pos++] = ++currentNext;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentNext &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        currentNext = <span class="keyword">next</span>[currentNext];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">next</span>[pos++] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> getIndexOf(String ori, String pattern) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ori.length() &lt; pattern.length()) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] oriArr = ori.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] patternArr = pattern.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> indexOfOri = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> indexOfPattern = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] <span class="keyword">next</span> = getNextArr(patternArr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (indexOfOri &lt; oriArr.length &amp;&amp; indexOfPattern &lt; patternArr.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oriArr[indexOfOri] == patternArr[indexOfPattern]) &#123;</span><br><span class="line">        indexOfOri++;</span><br><span class="line">        indexOfPattern++;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">next</span>[indexOfPattern] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        indexOfPattern = <span class="keyword">next</span>[indexOfPattern];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        indexOfOri++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> indexOfPattern == patternArr.length ? indexOfOri - indexOfPattern : -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      KMP算法
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串匹配" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串匹配" scheme="http://langonggong.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>内存屏障</title>
    <link href="http://langonggong.com/2018/08/23/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"/>
    <id>http://langonggong.com/2018/08/23/内存屏障/</id>
    <published>2018-08-23T15:15:18.000Z</published>
    <updated>2020-06-22T16:40:36.962Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="内存屏障的目的"><a href="#内存屏障的目的" class="headerlink" title="内存屏障的目的"></a>内存屏障的目的</h1><p>每个CPU都会有自己的缓存（有的甚至L1,L2,L3），缓存的目的就是为了提高性能，避免每次都要向内存取。但是这样的弊端也很明显：不能实时的和内存发生信息交换，分在不同CPU执行的不同线程对同一个变量的缓存值不同</p><h1 id="内存屏障的作用"><a href="#内存屏障的作用" class="headerlink" title="内存屏障的作用"></a>内存屏障的作用</h1><p>硬件层的内存屏障分为两种：Load Barrier 和 Store Barrier即读屏障和写屏障</p><ul><li>对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据</li><li>对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见</li></ul><p>内存屏障有两个作用</p><ul><li>阻止屏障两侧的指令重排序</li><li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效</li></ul><h1 id="java内存屏障"><a href="#java内存屏障" class="headerlink" title="java内存屏障"></a>java内存屏障</h1><p>内存屏障可以被分为以下几种类型:</p><ul><li><code>LoadLoad屏障</code>：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li><li><code>StoreStore屏障</code>：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li><li><code>LoadStore屏障</code>：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li><li><code>StoreLoad屏障</code>：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</li></ul><h1 id="volatile语义中的内存屏障"><a href="#volatile语义中的内存屏障" class="headerlink" title="volatile语义中的内存屏障"></a>volatile语义中的内存屏障</h1><p>volatile的内存屏障策略非常严格、悲观</p><ul><li>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障</li><li>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障</li></ul><p>volatile重排序规则：</p><ul><li>volatile写与之前的读写不能重排序</li><li>volatile读与之后的读写不能重排序</li><li>相邻的volatile之间不能重排序</li></ul><p><img src="/images/reordering-table.png"></p><p>volatile内存屏障规则：</p><ul><li>volatile写之前，所有的读写都必须已经完成</li><li>volatile读结束后，所有的读写才能开始</li><li>相邻的volatile必须有序实行</li></ul><p><img src="/images/fences-table.png"></p><h1 id="final语义中的内存屏障"><a href="#final语义中的内存屏障" class="headerlink" title="final语义中的内存屏障"></a>final语义中的内存屏障</h1><ul><li><p>新建对象过程中，构造体中对final域的初始化写入和这个对象赋值给其他引用变量，这两个操作不能重排序</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x.<span class="attr">finalField</span> = v; ... ;构建方法边界<span class="attr">sharedRef</span> = x;</span><br><span class="line">v.<span class="attr">afield</span> = <span class="number">1</span>; x.<span class="attr">finalField</span> = v; ... ; 构建方法边界<span class="attr">sharedRef</span> = x;</span><br><span class="line">这两条语句中，构建方法边界前后的指令都不能重排序。</span><br></pre></td></tr></table></figure></li><li><p>初次读包含final域的对象引用和读取这个final域，这两个操作不能重排序</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">x</span> = sharedRef<span class="comment">; ... ; i = x.finalField;</span></span><br></pre></td></tr></table></figure></li><li><p>为了保证final字段的特殊语义，也会在下面的语句加入内存屏障</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.<span class="attr">finalField</span> = v; StoreStore; <span class="attr">sharedRef</span> = x;</span><br></pre></td></tr></table></figure></li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://www.jianshu.com/p/2ab5e3d7e510" target="_blank" rel="noopener">内存屏障</a></li><li><a href="https://www.cnblogs.com/chenyangyao/p/5269622.html" target="_blank" rel="noopener">JVM内存模型、指令重排、内存屏障概念解析</a></li><li><a href="https://blog.csdn.net/coslay/article/details/41955899" target="_blank" rel="noopener">java内存模型 内存屏障</a></li></ul>]]></content>
    
    <summary type="html">
    
      内存屏障原理解析
    
    </summary>
    
      <category term="java" scheme="http://langonggong.com/categories/java/"/>
    
      <category term="内存模型" scheme="http://langonggong.com/categories/java/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
    
      <category term="java" scheme="http://langonggong.com/tags/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java内存模型" scheme="http://langonggong.com/tags/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>volatile</title>
    <link href="http://langonggong.com/2018/08/23/volatile/"/>
    <id>http://langonggong.com/2018/08/23/volatile/</id>
    <published>2018-08-23T12:54:28.000Z</published>
    <updated>2020-06-22T16:40:36.962Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><p>volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值</p><p><code>线程写volatile变量的过程</code></p><ul><li>改变线程工作内存中volatile变量副本的值</li><li>将改变后的副本的值从工作内存刷新到主内存</li></ul><p><code>线程读volatile变量的过程</code></p><ul><li>从主内存中读取volatile变量的最新值到线程的工作内存中</li><li>从工作内存中读取volatile变量的副本</li></ul><h3 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h3><p>多线程版本(错误的)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> Helper helper = <span class="keyword">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Helper <span class="title">getHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (helper == <span class="keyword">null</span>) </span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (helper == <span class="keyword">null</span>) </span><br><span class="line">          helper = <span class="keyword">new</span> Helper();</span><br><span class="line">      &#125;    </span><br><span class="line">    <span class="keyword">return</span> helper;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// other functions and members...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>volatile关键字修改版<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Helper helper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Helper <span class="title">getHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (helper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (helper == <span class="keyword">null</span>)</span><br><span class="line">                    helper = <span class="keyword">new</span> Helper();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在给helper对象初始化的过程中，jvm做了下面3件事:</p><ul><li>给helper对象分配内存</li><li>调用构造函数</li><li>将helper对象指向分配的内存空间</li></ul><p>由于jvm的”优化”,指令2和指令3的执行顺序是不一定的，当执行完指定3后，此时的helper对象就已经不在是null的了,但此时指令2不一定已经被执行。</p><p>假设线程1和线程2同时调用getHelper()方法，此时线程1执行完指令1和指令3，线程2抢到了执行权，此时helper对象是非空的</p><ul><li>volatile关键字可以保证jvm执行的一定的“有序性”，在指令1和指令2执行完之前，指定3一定不会被执行</li><li>volatile变量被修改后立刻刷新会驻内存中</li></ul><h3 id="不保证复合操作的原子性"><a href="#不保证复合操作的原子性" class="headerlink" title="不保证复合操作的原子性"></a>不保证复合操作的原子性</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        final Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        System.<span class="keyword">out</span>.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程A读取最新的值并在工作内存修改后，还未更新到主存就耗尽cpu时间片，等再次获取时间片后主存的变量值已被线程B修改，但线程A并未感知，继续将值更新到主存，导致B的修改无效</p>]]></content>
    
    <summary type="html">
    
      volatile原理解析
    
    </summary>
    
      <category term="java" scheme="http://langonggong.com/categories/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://langonggong.com/tags/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>hexo高级特性</title>
    <link href="http://langonggong.com/2018/08/19/cool/"/>
    <id>http://langonggong.com/2018/08/19/cool/</id>
    <published>2018-08-19T08:35:51.000Z</published>
    <updated>2020-06-22T16:40:36.957Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="网易云"><a href="#网易云" class="headerlink" title="网易云"></a>网易云</h1><h2 id="通过外链添加"><a href="#通过外链添加" class="headerlink" title="通过外链添加"></a>通过外链添加</h2><p>在网易云音乐的网页版生成歌单外链</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe <span class="attribute">frameborder</span>=<span class="string">"no"</span> <span class="attribute">border</span>=<span class="string">"0"</span> <span class="attribute">marginwidth</span>=<span class="string">"0"</span> <span class="attribute">marginheight</span>=<span class="string">"0"</span> <span class="attribute">width</span>=330 <span class="attribute">height</span>=450 <span class="attribute">src</span>=<span class="string">"//music.163.com/outchain/player?type=0&amp;id=2343741251&amp;auto=1&amp;height=430"</span>&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="450" src="//music.163.com/outchain/player?type=0&id=2343741251&auto=1&height=430"></iframe><h2 id="通过aplayer插件"><a href="#通过aplayer插件" class="headerlink" title="通过aplayer插件"></a>通过aplayer插件</h2><p><a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md#meingjs-%E6%94%AF%E6%8C%81-30-%E6%96%B0%E5%8A%9F%E8%83%BD" target="_blank" rel="noopener">MeingJS 支持</a><br>id为网页上url后面的id值<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% meting <span class="string">"468513829"</span> <span class="string">"netease"</span> <span class="string">"song"</span> <span class="string">"autoplay"</span> <span class="string">"mutex: true"</span> <span class="string">"listmaxheight:340px"</span> <span class="string">"preload:none"</span> <span class="string">"theme:#ad7a86"</span>%&#125;</span><br></pre></td></tr></table></figure></p>    <div id="aplayer-mNaSbgHF" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="468513829" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="none" data-theme="#ad7a86"></div><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% meting <span class="string">"384485381"</span> <span class="string">"netease"</span> <span class="string">"playlist"</span> <span class="string">"autoplay"</span> <span class="string">"mutex: true"</span> <span class="string">"listmaxheight:340px"</span> <span class="string">"preload:none"</span> <span class="string">"theme:#ad7a86"</span>%&#125;</span><br></pre></td></tr></table></figure>    <div id="aplayer-yaQtGvFf" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="2384642500" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="340px" data-preload="none" data-theme="#ad7a86"></div><h2 id="行间公式"><a href="#行间公式" class="headerlink" title="行间公式"></a>行间公式</h2><script type="math/tex; mode=display">f(n)=\begin{cases}n/2, & \text{如果$ x<=2 $}\\3n+1, & \text{如果$ x>2 $}\end{cases}</script><h2 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h2><p>比如 \(x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}\)</p>]]></content>
    
    <summary type="html">
    
      测试hexo系统新特性
    
    </summary>
    
      <category term="hexo" scheme="http://langonggong.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://langonggong.com/tags/hexo/"/>
    
      <category term="新特性" scheme="http://langonggong.com/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>mysql</title>
    <link href="http://langonggong.com/2018/08/19/mysql/"/>
    <id>http://langonggong.com/2018/08/19/mysql/</id>
    <published>2018-08-19T05:47:35.000Z</published>
    <updated>2020-06-22T16:40:36.959Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="mysql体系结构"><a href="#mysql体系结构" class="headerlink" title="mysql体系结构"></a>mysql体系结构</h2><p><img src="/images/mysql-server.jpg"></p><p><a href="https://www.cnblogs.com/Survivalist/p/7954977.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><div class="table-container"><table><thead><tr><th style="text-align:center">特点</th><th style="text-align:center">MyISAM</th><th style="text-align:center">BDB</th><th style="text-align:center">Memory</th><th style="text-align:center">InnoDB</th><th style="text-align:center">Archive</th></tr></thead><tbody><tr><td style="text-align:center">存储限制</td><td style="text-align:center">没有</td><td style="text-align:center">没有</td><td style="text-align:center">有</td><td style="text-align:center">64TB</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center">事务安全</td><td style="text-align:center"></td><td style="text-align:center">支持</td><td style="text-align:center"></td><td style="text-align:center">支持</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">锁机制</td><td style="text-align:center">表锁</td><td style="text-align:center">页锁</td><td style="text-align:center">表锁</td><td style="text-align:center">行锁</td><td style="text-align:center">行锁</td></tr><tr><td style="text-align:center">B数索引</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">哈希索引</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">全文索引</td><td style="text-align:center">支持</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">集群索引</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">支持</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">数据缓存</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">索引缓存</td><td style="text-align:center">支持</td><td style="text-align:center"></td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">数据可压缩</td><td style="text-align:center">支持</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">空间使用</td><td style="text-align:center">低</td><td style="text-align:center">低</td><td style="text-align:center">N/A</td><td style="text-align:center">高</td><td style="text-align:center">非常低</td></tr><tr><td style="text-align:center">内存使用</td><td style="text-align:center">低</td><td style="text-align:center">低</td><td style="text-align:center">中等</td><td style="text-align:center">高</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">批量插入的速度</td><td style="text-align:center">高</td><td style="text-align:center">高</td><td style="text-align:center">高</td><td style="text-align:center">低</td><td style="text-align:center">非常高</td></tr><tr><td style="text-align:center">支持外键</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">支持</td></tr></tbody></table></div><p><a href="https://blog.csdn.net/len9596/article/details/80206532" target="_blank" rel="noopener">InnoDB与MyISAM原理比较</a></p><p><a href="https://www.cnblogs.com/wangdake-qq/p/7358322.html" target="_blank" rel="noopener">InnoDB与MyISAM索引比较</a></p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h2><h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h3><p><a href="https://blog.csdn.net/mine_song/article/details/63251546" target="_blank" rel="noopener">参考链接</a><br>B树中关键字集合分布在整棵树中，叶节点中不包含任何关键字信息，而B+树关键字集合分布在叶子结点中，非叶节点只是叶子结点中关键字的索引</p><h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><p><a href="https://www.cnblogs.com/heiming/p/5865101.html" target="_blank" rel="noopener">B Tree索引和哈希索引的区别</a></p><p>缺点<br>不支持范围查询和排序、最左匹配规则</p><h3 id="空间-R-Tree-索引"><a href="#空间-R-Tree-索引" class="headerlink" title="空间(R-Tree)索引"></a>空间(R-Tree)索引</h3><p><img src="/images/RTree.jpg"></p><p><a href="https://blog.csdn.net/MongChia1993/article/details/69941783#toc_16" target="_blank" rel="noopener">参考链接</a></p><h3 id="全文-Full-text-索引"><a href="#全文-Full-text-索引" class="headerlink" title="全文(Full-text)索引"></a>全文(Full-text)索引</h3><p>类似es搜索的Lucene分词策略</p><p><a href="https://www.cnblogs.com/itxiongwei/p/7064252.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="索引策略"><a href="#索引策略" class="headerlink" title="索引策略"></a>索引策略</h2><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p><a href="https://blog.csdn.net/john1337/article/details/71081827" target="_blank" rel="noopener">高性能mysql章节</a></p><p>概念<br>使用该列开始的部分长度字符串作</p><p>注意<br>选择足够长的前缀以保证较高的选择性，同时又不能太长以便节约空间</p><p>缺点<br>mysql无法使用其前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描</p><h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p><a href="https://www.cnblogs.com/codeAB/p/6387148.html" target="_blank" rel="noopener">mysql多列索引的生效规则</a></p><h3 id="聚簇索引-Clustered-Indexes-及二级索引-辅助索引"><a href="#聚簇索引-Clustered-Indexes-及二级索引-辅助索引" class="headerlink" title="聚簇索引(Clustered Indexes)及二级索引(辅助索引)"></a>聚簇索引(Clustered Indexes)及二级索引(辅助索引)</h3><p><a href="https://www.linuxidc.com/Linux/2018-02/150809.htm" target="_blank" rel="noopener">高性能mysql章节</a></p><p><a href="https://blog.csdn.net/mine_song/article/details/63251546" target="_blank" rel="noopener">InnoDB与MyISAM的主键索引和二级索引的区别</a></p><ul><li><p>聚集索引<br>表数据按照索引的顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序一致。对于聚集索引，叶子结点即存储了真实的数据行，不再有另外单独的数据页。 在一张表上最多只能创建一个聚集索引，因为真实数据的物理顺序只能有一种</p></li><li><p>非聚集索引<br>表数据存储顺序与索引顺序无关。对于非聚集索引，叶结点包含索引字段值及指向数据页数据行的逻辑指针，其行数量与数据表行数据量一致</p></li></ul><h3 id="覆盖索引-Covering-Indexes"><a href="#覆盖索引-Covering-Indexes" class="headerlink" title="覆盖索引(Covering Indexes)"></a>覆盖索引(Covering Indexes)</h3><p>建立索引的字段正好是覆盖查询语句[select子句]与查询条件[Where子句]中所涉及的字段,数据列只用从索引中就能够取得，不必从数据表中读取<br>参考&lt;&lt;高性能mysql&gt;&gt;</p><p><a href="https://www.cnblogs.com/happyflyingpig/p/7662881.html" target="_blank" rel="noopener">参考链接</a><br><a href="https://www.cnblogs.com/Profound/p/8763022.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="压缩-前缀压缩-索引"><a href="#压缩-前缀压缩-索引" class="headerlink" title="压缩(前缀压缩)索引"></a>压缩(前缀压缩)索引</h3><p><a href="https://blog.csdn.net/yirentianran/article/details/79423908" target="_blank" rel="noopener">参考链接</a></p><h3 id="重复索引"><a href="#重复索引" class="headerlink" title="重复索引"></a>重复索引</h3><p>相同列上按照相同的顺序创建的相同类型的索引    </p><h3 id="冗余索引"><a href="#冗余索引" class="headerlink" title="冗余索引"></a>冗余索引</h3><p>若存在索引(a,b),则(a)是冗余,因为a是前缀,(a,b)可以当成(a)使用;（b,a）和(b)不是冗余索引</p><h3 id="分形树-fractal-treeindex-索引"><a href="#分形树-fractal-treeindex-索引" class="headerlink" title="分形树(fractal treeindex)索引"></a>分形树(fractal treeindex)索引</h3><h3 id="块级别元数据"><a href="#块级别元数据" class="headerlink" title="块级别元数据"></a>块级别元数据</h3><p><img src="/images/ib.png"></p><p><a href="https://blog.csdn.net/hguisu/article/details/11848411" target="_blank" rel="noopener">Infobright高性能数据仓库</a></p><h1 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h1><h2 id="explain关键字"><a href="#explain关键字" class="headerlink" title="explain关键字"></a>explain关键字</h2><p><a href="https://www.cnblogs.com/butterfly100/archive/2018/01/15/8287569.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="查询路径"><a href="#查询路径" class="headerlink" title="查询路径"></a>查询路径</h2><p><img src="/images/mysql-query.png"></p><p><a href="https://www.cnblogs.com/yuyue2014/p/3826941.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p><a href="https://www.cnblogs.com/shengdimaya/p/7123069.html" target="_blank" rel="noopener">join原理</a></p><p>JOIN算法</p><ul><li>Nested-Loop Join<ul><li>Simple Nested-Loop Join</li><li>Index Nested-Loop Join</li><li>Block Nested-Loop Join    </li></ul></li><li>哈希关联</li><li>合并连接</li></ul><h1 id="mysql高级特性"><a href="#mysql高级特性" class="headerlink" title="mysql高级特性"></a>mysql高级特性</h1><h2 id="分库、分区、分表、分片"><a href="#分库、分区、分表、分片" class="headerlink" title="分库、分区、分表、分片"></a>分库、分区、分表、分片</h2><p><a href="http://langonggong.com/2018/07/14/mysql%E5%88%86%E5%BA%93-%E5%88%86%E5%8C%BA-%E5%88%86%E8%A1%A8-%E5%88%86%E7%89%87/">参考链接</a></p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h2 id="内部存储代码"><a href="#内部存储代码" class="headerlink" title="内部存储代码"></a>内部存储代码</h2><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><h3 id="绑定变量"><a href="#绑定变量" class="headerlink" title="绑定变量"></a>绑定变量</h3><h3 id="XA"><a href="#XA" class="headerlink" title="XA"></a>XA</h3><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><h1 id="mvcc与锁"><a href="#mvcc与锁" class="headerlink" title="mvcc与锁"></a>mvcc与锁</h1><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p><a href="https://www.cnblogs.com/chenpingzhao/p/5065316.html" target="_blank" rel="noopener">原理</a></p><h3 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h3><h3 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h3>]]></content>
    
    <summary type="html">
    
      《高性能mysql》读书笔记
    
    </summary>
    
      <category term="mysql" scheme="http://langonggong.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://langonggong.com/tags/mysql/"/>
    
      <category term="DB" scheme="http://langonggong.com/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>spring cloud</title>
    <link href="http://langonggong.com/2018/08/19/springcloud/"/>
    <id>http://langonggong.com/2018/08/19/springcloud/</id>
    <published>2018-08-19T05:12:12.000Z</published>
    <updated>2020-06-22T16:40:36.960Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p><img src="/images/spring-cloud-architecture.png"></p><h2 id="四大神器"><a href="#四大神器" class="headerlink" title="四大神器"></a>四大神器</h2><ul><li>auto-configuration</li><li>starters<br>  <img src="/images/spring-cloud-stater.png"></li><li>cli：Spring Boot Commad Line    </li><li>Autuator监控</li></ul><h1 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h1><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p><img src="/images/aws-eureka.png"></p><p><a href="https://luyiisme.github.io/2017/04/22/spring-cloud-service-discovery-products/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">参考链接</a></p><div class="table-container"><table><thead><tr><th style="text-align:center">Feature</th><th style="text-align:center">Consul</th><th style="text-align:center">zookeeper</th><th style="text-align:center">etcd</th><th style="text-align:center">Eureka</th></tr></thead><tbody><tr><td style="text-align:center">服务健康检查</td><td style="text-align:center">服务状态，内存，硬盘等</td><td style="text-align:center">(弱)长连接，keepalive</td><td style="text-align:center">连接心跳</td><td style="text-align:center">可配支持</td></tr><tr><td style="text-align:center">多数据中心</td><td style="text-align:center">支持</td><td style="text-align:center">—</td><td style="text-align:center">—</td><td style="text-align:center">—</td></tr><tr><td style="text-align:center">kv存储服务</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">—</td></tr><tr><td style="text-align:center">一致性</td><td style="text-align:center">raft</td><td style="text-align:center">paxos</td><td style="text-align:center">raft</td><td style="text-align:center">—</td></tr><tr><td style="text-align:center">cap</td><td style="text-align:center">ca</td><td style="text-align:center">cp</td><td style="text-align:center">cp</td><td style="text-align:center">ap</td></tr><tr><td style="text-align:center">使用接口(多语言能力)</td><td style="text-align:center">支持http和dns</td><td style="text-align:center">客户端</td><td style="text-align:center">http/grpc</td><td style="text-align:center">http（sidecar）</td></tr><tr><td style="text-align:center">watch支持</td><td style="text-align:center">全量/支持long polling    支持</td><td style="text-align:center">支持</td><td style="text-align:center">long polling</td><td style="text-align:center">支持 long polling/大部分增量</td></tr><tr><td style="text-align:center">自身监控</td><td style="text-align:center">metrics</td><td style="text-align:center">—</td><td style="text-align:center">metrics</td><td style="text-align:center">metrics</td></tr><tr><td style="text-align:center">安全</td><td style="text-align:center">acl /https</td><td style="text-align:center">acl    https支持（弱）</td><td style="text-align:center">—</td></tr><tr><td style="text-align:center">spring cloud集成</td><td style="text-align:center">已支持</td><td style="text-align:center">已支持</td><td style="text-align:center">已支持</td><td style="text-align:center">已支持</td></tr></tbody></table></div><h2 id="CAP理论与BASE思想"><a href="#CAP理论与BASE思想" class="headerlink" title="CAP理论与BASE思想"></a>CAP理论与BASE思想</h2><h2 id="服务发现的方式"><a href="#服务发现的方式" class="headerlink" title="服务发现的方式"></a>服务发现的方式</h2><ul><li>客户端发现<br><img src="/images/client-find.png"></li><li>服务器端发现<br><img src="/images/server-find.png"></li></ul><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><h2 id="LB方案"><a href="#LB方案" class="headerlink" title="LB方案"></a>LB方案</h2><p><a href="https://www.cnblogs.com/mindwind/p/5339657.html" target="_blank" rel="noopener">参考链接1</a></p><p><a href="https://www.cnblogs.com/LittleHann/p/3963255.html" target="_blank" rel="noopener">参考链接2</a></p><p><img src="/images/lb-whole.jpg"></p><ul><li>硬负载</li><li>软负载</li><li>DNS负载</li><li>CDN负载</li></ul><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p><strong>核心组件</strong></p><ul><li>ServerList<br>  用于获取地址列表。它既可以是静态的(提供一组固定的地址)，也可以是动态的(从注册中心中定期查询地址列表)    </li><li>ServerListFilter<br>  仅当使用动态ServerList时使用，用于在原始的服务列表中使用一定策略过虑掉一部分地址    </li><li>IRule<br>  选择一个最终的服务地址作为LB结果。选择策略有轮询、根据响应时间加权、断路器(当Hystrix可用时)等    </li></ul><h1 id="rest调用"><a href="#rest调用" class="headerlink" title="rest调用"></a>rest调用</h1><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><h1 id="容错处理"><a href="#容错处理" class="headerlink" title="容错处理"></a>容错处理</h1><p><a href="http://blog.51cto.com/developerycj/1950881" target="_blank" rel="noopener">参考链接1</a><br><a href="https://www.cnblogs.com/leeSmall/p/8847652.html" target="_blank" rel="noopener">参考链接2</a></p><h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><ul><li>限流</li><li>降级</li><li>熔断</li></ul><h2 id="Dashboard-服务监控"><a href="#Dashboard-服务监控" class="headerlink" title="Dashboard 服务监控"></a>Dashboard 服务监控</h2><h2 id="Turbine-聚合监控"><a href="#Turbine-聚合监控" class="headerlink" title="Turbine 聚合监控"></a>Turbine 聚合监控</h2><h1 id="微服务网关"><a href="#微服务网关" class="headerlink" title="微服务网关"></a>微服务网关</h1><h2 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h2><h3 id="过滤器机制"><a href="#过滤器机制" class="headerlink" title="过滤器机制"></a>过滤器机制</h3><p><img src="/images/zuul-filter.png"></p><h3 id="标准过滤器类型"><a href="#标准过滤器类型" class="headerlink" title="标准过滤器类型"></a>标准过滤器类型</h3><ul><li>PRE<ul><li>鉴权</li><li>流量转发</li></ul></li><li>ROUTING</li><li>POST<ul><li>跨域</li><li>统计</li></ul></li><li>ERROR</li></ul><h3 id="request生命周期"><a href="#request生命周期" class="headerlink" title="request生命周期"></a>request生命周期</h3><p><img src="/images/zuul-filter-lifecyle.png"></p><p><a href="http://www.scienjus.com/api-gateway-and-netflix-zuul/#Netflix-Zuul" target="_blank" rel="noopener">参考链接1</a></p><p><a href="https://www.cnblogs.com/lexiaofei/p/7080257.html" target="_blank" rel="noopener">参考链接2</a></p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><ul><li>隔离机制</li><li>重试机制</li></ul><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul><li>验证与安全保障</li><li>审查与监控</li><li>动态路由</li><li>压力测试</li><li>负载分配</li><li>静态响应处理</li><li>多区域弹性</li></ul><h1 id="微服务配置"><a href="#微服务配置" class="headerlink" title="微服务配置"></a>微服务配置</h1><h2 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h2><p><img src="/images/spring-cloud-config.png"></p><h2 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h2><p><img src="/images/configbus2.jpg"></p><p><a href="https://www.cnblogs.com/ityouknow/p/6931958.html" target="_blank" rel="noopener">参考链接</a></p><ul><li>提交代码触发post请求给bus/refresh</li><li>server端接收到请求并发送给Spring Cloud Bus</li><li>Spring Cloud bus接到消息并通知给其它客户端</li><li>其它客户端接收到通知，请求Server端获取最新配置</li><li>全部客户端均获取到最新的配置</li></ul><h1 id="微服务跟踪"><a href="#微服务跟踪" class="headerlink" title="微服务跟踪"></a>微服务跟踪</h1><h2 id="Spring-Cloud-Sleuth"><a href="#Spring-Cloud-Sleuth" class="headerlink" title="Spring Cloud Sleuth"></a>Spring Cloud Sleuth</h2><h2 id="ZipKin"><a href="#ZipKin" class="headerlink" title="ZipKin"></a>ZipKin</h2><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2>]]></content>
    
    <summary type="html">
    
      微服务概念学习
    
    </summary>
    
      <category term="spring" scheme="http://langonggong.com/categories/spring/"/>
    
      <category term="spring cloud" scheme="http://langonggong.com/categories/spring/spring-cloud/"/>
    
    
      <category term="java" scheme="http://langonggong.com/tags/java/"/>
    
      <category term="spring cloud" scheme="http://langonggong.com/tags/spring-cloud/"/>
    
      <category term="网关" scheme="http://langonggong.com/tags/%E7%BD%91%E5%85%B3/"/>
    
      <category term="docker" scheme="http://langonggong.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>java-concurrency</title>
    <link href="http://langonggong.com/2018/08/19/java-concurrency/"/>
    <id>http://langonggong.com/2018/08/19/java-concurrency/</id>
    <published>2018-08-19T04:48:15.000Z</published>
    <updated>2020-06-22T16:40:36.958Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="concurrent包"><a href="#concurrent包" class="headerlink" title="concurrent包"></a>concurrent包</h1><p><img src="/images/concurrent-package.png"></p><p><img src="/images/java-concurrent.png"></p><h2 id="locks-锁"><a href="#locks-锁" class="headerlink" title="locks(锁)"></a>locks(锁)</h2><p><img src="/images/locks.png"></p><h3 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h3><p><a href="http://www.importnew.com/19472.html" target="_blank" rel="noopener">锁分类1</a><br><a href="https://www.cnblogs.com/qifengshi/p/6831055.html" target="_blank" rel="noopener">锁分类2</a></p><ul><li>公平锁/非公平锁</li><li>可重入锁</li><li>可中断锁</li><li>独享锁/共享锁</li><li>互斥锁/读写锁</li><li>乐观锁/悲观锁</li><li>分段锁</li><li>偏向锁/轻量级锁/重量级锁</li><li>自旋锁</li></ul><h3 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h3><p><a href="https://my.oschina.net/hosee/blog/615865" target="_blank" rel="noopener">锁的优化</a></p><ul><li>减少锁持有时间</li><li>减小锁粒度</li><li>锁分离</li><li>锁粗化</li><li>锁消除</li></ul><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>参考链接<br><a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">参考1</a><br><a href="https://segmentfault.com/a/1190000008471362" target="_blank" rel="noopener">参考2</a><br><a href="https://blog.csdn.net/javazejian/article/details/75043422" target="_blank" rel="noopener">AQS、ReetrantLock、Condition实现原理</a></p><p>重要方法:        </p><ul><li>isHeldExclusively()</li><li>tryAcquire(int)</li><li>tryRelease(int)</li><li>tryAcquireShared(int)</li><li>tryReleaseShared(int)</li></ul><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>参考链接<br><a href="https://www.cnblogs.com/aishangJava/p/6555291.html" target="_blank" rel="noopener">参考1</a><br><a href="https://www.cnblogs.com/dolphin0520/p/3923167.html" target="_blank" rel="noopener">参考2</a></p><p>重要方法</p><ul><li>lock()</li><li>lockInterruptibly() throws InterruptedException</li><li>tryLock()</li><li>tryLock(long time, TimeUnit unit) throws InterruptedException</li><li>unlock()</li><li>Condition newCondition()</li></ul><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p><img src="/images/ReentrantLock.gif"></p><p>参考链接<br>    <a href="https://www.cnblogs.com/onlywujun/articles/3531568.html" target="_blank" rel="noopener">参考1</a></p><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p><img src="/images/ReentrantReadWriteLock.jpg"></p><p>参考链接<br><a href="https://www.cnblogs.com/skywang12345/p/3505809.html" target="_blank" rel="noopener">参考1</a><br><a href="https://www.cnblogs.com/grefr/p/6094922.html" target="_blank" rel="noopener">参考2</a></p><h3 id="condition"><a href="#condition" class="headerlink" title="condition"></a>condition</h3><p><a href="https://blog.csdn.net/bohu83/article/details/51098106" target="_blank" rel="noopener">参考链接</a></p><p><a href="https://www.cnblogs.com/Ming8006/p/7243858.html" target="_blank" rel="noopener">生产者、消费者三种实现</a></p><h2 id="atomic-原子变量"><a href="#atomic-原子变量" class="headerlink" title="atomic(原子变量)"></a>atomic(原子变量)</h2><ul><li>AtomicInteger</li><li>AtomicLong</li><li>AtomicBoolean</li><li>AtomicReference</li><li>AtomicIntegerArray/AtomicLongArray/AtomicReferenceArray</li></ul><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>Unsafe类<br>ABA问题</p><h2 id="executor-线程池"><a href="#executor-线程池" class="headerlink" title="executor(线程池)"></a>executor(线程池)</h2><p><a href="https://www.cnblogs.com/aspirant/p/6920418.html" target="_blank" rel="noopener">参考链接</a></p><h3 id="框架类图"><a href="#框架类图" class="headerlink" title="框架类图"></a>框架类图</h3><p><img src="/images/Executor.png"></p><ul><li><p><strong>ThreadPoolExecutor</strong></p><p>  <a href="https://blog.csdn.net/qq_25806863/article/details/71126867" target="_blank" rel="noopener">构造方法和规则</a></p><p>  <a href="http://www.cnblogs.com/trust-freedom/p/6681948.html" target="_blank" rel="noopener">执行原理</a></p><p>  <a href="http://www.cnblogs.com/trust-freedom/p/6693601.html" target="_blank" rel="noopener">线程池终止</a></p><p>  关键参数</p><ul><li>workQueue(排队策略)</li><li>threadFactory</li><li><p>RejectedExecutionHandler(饱和策略)</p><p>常用方法</p></li></ul></li><li><p><strong>Executors</strong></p><p>  创建线程池</p><ul><li>newFixedThreadPool</li><li>newCachedThreadPool</li><li>newSingleThreadExecutor</li><li>newScheduledThreadPool</li></ul></li></ul><h2 id="collections-并发容器"><a href="#collections-并发容器" class="headerlink" title="collections(并发容器)"></a>collections(并发容器)</h2><h3 id="List和Set"><a href="#List和Set" class="headerlink" title="List和Set"></a>List和Set</h3><p><img src="/images/list&set.jpg"></p><ul><li><p>CopyOnWriteArrayList    </p><p>  <a href="http://www.cnblogs.com/skywang12345/p/3498483.html" target="_blank" rel="noopener">参考1</a></p></li><li><p>CopyOnWriteArraySet</p><p>  <a href="http://www.cnblogs.com/skywang12345/p/3498497.html" target="_blank" rel="noopener">参考1</a></p></li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><img src="/images/map.jpg"></p><ul><li><p>ConcurrentHashMap</p><p>  <a href="http://www.cnblogs.com/skywang12345/p/3498537.html" target="_blank" rel="noopener">参考</a></p></li><li><p>ConcurrentSkipListMap</p><p>  <a href="http://www.cnblogs.com/skywang12345/p/3498556.html" target="_blank" rel="noopener">参考</a></p></li><li><p>ConcurrentSkipListSet</p></li></ul><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p><img src="/images/queue.jpg"></p><ul><li><p>ArrayBlockingQueue</p>  <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure><p>  notEmpty和notFull是锁的两个Condition条件<br>  <a href="https://blog.csdn.net/javazejian/article/details/77410889" target="_blank" rel="noopener">实现原理</a></p></li><li><p>LinkedBlockingQueue</p></li><li>LinkedBlockingDeque</li><li>ConcurrentLinkedQueue</li><li>ConcurrentLinkedDeque</li></ul><h2 id="tools-同步工具"><a href="#tools-同步工具" class="headerlink" title="tools(同步工具)"></a>tools(同步工具)</h2><ul><li>CountDownLatch</li><li>CyclicBarrier</li><li>Semaphore</li></ul><h1 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h1><p><a href="https://blog.csdn.net/javazejian/article/details/72772461" target="_blank" rel="noopener">java内存模型</a><br><a href="https://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="noopener">synchronized原理</a></p><h2 id="内存模型概述"><a href="#内存模型概述" class="headerlink" title="内存模型概述"></a>内存模型概述</h2><p><img src="/images/jmm-summary.png"></p><ul><li>主内存</li><li>工作内存</li></ul><h2 id="Java内存模型与硬件内存架构的关系"><a href="#Java内存模型与硬件内存架构的关系" class="headerlink" title="Java内存模型与硬件内存架构的关系"></a>Java内存模型与硬件内存架构的关系</h2><p><img src="/images/jmm-hardware.png"></p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>原子性</li><li>可见性</li><li>有序性</li></ul><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><ul><li>指令重排</li><li>编译器重排</li></ul><h2 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h2><h2 id="happens-before-原则"><a href="#happens-before-原则" class="headerlink" title="happens-before 原则"></a>happens-before 原则</h2><ul><li>程序顺序原则</li><li>锁规则</li><li>volatile规则</li><li>线程启动规则</li><li>传递性</li><li>线程终止规则</li><li>线程中断规则</li><li>对象终结规则</li></ul><h2 id="volatile内存语义"><a href="#volatile内存语义" class="headerlink" title="volatile内存语义"></a>volatile内存语义</h2><ul><li>可见性</li><li>禁止重排优化</li></ul><h2 id="内存屏障（Memory-Barrier）"><a href="#内存屏障（Memory-Barrier）" class="headerlink" title="内存屏障（Memory Barrier）"></a>内存屏障（Memory Barrier）</h2><p><a href="http://ifeve.com/jmm-cookbook-mb/" target="_blank" rel="noopener">参考链接</a></p><ul><li>LoadLoad Barriers</li><li>StoreStore  Barriers</li><li>LoadStore Barriers</li><li>StoreLoad Barriers</li></ul>]]></content>
    
    <summary type="html">
    
      Java Concurrency in Practice读书笔记
    
    </summary>
    
      <category term="java" scheme="http://langonggong.com/categories/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://langonggong.com/tags/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="jvm" scheme="http://langonggong.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch常用搜索</title>
    <link href="http://langonggong.com/2018/08/19/Elasticsearch/"/>
    <id>http://langonggong.com/2018/08/19/Elasticsearch/</id>
    <published>2018-08-19T04:41:41.000Z</published>
    <updated>2020-06-22T16:40:36.956Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="多字段查找"><a href="#多字段查找" class="headerlink" title="多字段查找"></a>多字段查找</h2><p><code>multi_match</code>        </p><p>以下表达式等价于<code>field1 = value1 or field2 = value1</code></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET <span class="built_in">index</span>/<span class="built_in">type</span>/_<span class="built_in">search</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span><span class="symbol">:</span> &#123;</span><br><span class="line">    <span class="string">"multi_match"</span><span class="symbol">:</span> &#123;</span><br><span class="line">      <span class="string">"query"</span><span class="symbol">:</span> <span class="string">"value1"</span>,</span><br><span class="line">      <span class="string">"fields"</span><span class="symbol">:</span> [<span class="string">"field1"</span>,<span class="string">"field2"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  , <span class="string">"_source"</span><span class="symbol">:</span> [<span class="string">"field1"</span>,<span class="string">"field2"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="布尔查询"><a href="#布尔查询" class="headerlink" title="布尔查询"></a>布尔查询</h2><p><code>must</code>等价于<code>and</code>,<code>must_not</code>等价于<code>not</code>,    <code>should</code>等价于<code>or</code>        </p><p>以下表达式等价于<code>( field1 = value1 or field2 = value2 ) and field3 != value3</code></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">GET index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"size"</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"bool"</span>: &#123;</span><br><span class="line">      <span class="string">"must"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"bool"</span>: &#123;</span><br><span class="line">            <span class="string">"should"</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="string">"match"</span>: &#123;</span><br><span class="line">                  <span class="string">"field1"</span>: <span class="string">"value1"</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="string">"match"</span>: &#123;</span><br><span class="line">                  <span class="string">"field2"</span>: <span class="string">"value2"</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">"must_not"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"match"</span>: &#123;</span><br><span class="line">            <span class="string">"field3"</span>: <span class="string">"value3"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"_source"</span>: [</span><br><span class="line">    <span class="string">"field1"</span>,<span class="string">"field2"</span>,<span class="string">"field3"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p><code>fuzziness</code></p><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/languages.html" target="_blank" rel="noopener">参考链接</a></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">GET index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"size"</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"bool"</span>: &#123;</span><br><span class="line">      <span class="string">"must"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"match"</span>: &#123;</span><br><span class="line">            <span class="string">"city"</span>: &#123;</span><br><span class="line">              <span class="string">"query"</span>: <span class="string">"Hoiliste"</span>,</span><br><span class="line">              <span class="string">"fuzziness"</span>: <span class="string">"auto"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"_source"</span>: [</span><br><span class="line">    <span class="string">"city"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通配符查询"><a href="#通配符查询" class="headerlink" title="通配符查询"></a>通配符查询</h2><p><code>*</code>匹配零个或多个字符</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GET index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"size"</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"bool"</span>: &#123;</span><br><span class="line">      <span class="string">"must"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"wildcard"</span>: &#123;</span><br><span class="line">            <span class="string">"field1"</span>: &#123;</span><br><span class="line">              <span class="string">"value"</span>: <span class="string">"wu*"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"_source"</span>: [</span><br><span class="line">    <span class="string">"field1"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正则查询"><a href="#正则查询" class="headerlink" title="正则查询"></a>正则查询</h2><p><code>regexp</code></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET <span class="built_in">index</span>/<span class="built_in">type</span>/_<span class="built_in">search</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"size"</span><span class="symbol">:</span> <span class="number">100</span>,</span><br><span class="line">  <span class="string">"query"</span><span class="symbol">:</span> &#123;</span><br><span class="line">    <span class="string">"regexp"</span><span class="symbol">:</span>&#123;</span><br><span class="line">      <span class="string">"field1"</span><span class="symbol">:</span><span class="string">"[a-zA-Z]+[0-9]*"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"_source"</span><span class="symbol">:</span> [</span><br><span class="line">    <span class="string">"field1"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h2><p><code>range</code></p><figure class="highlight flix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET <span class="keyword">index</span>/<span class="keyword">type</span>/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"size"</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"range"</span>: &#123;</span><br><span class="line">      <span class="string">"field1"</span>: &#123;</span><br><span class="line">        <span class="string">"from"</span>: <span class="string">"2018-04-16 05:22:39"</span>,</span><br><span class="line">        <span class="string">"to"</span>: <span class="string">"2018-06-23 05:22:39"</span>,</span><br><span class="line">        <span class="string">"include_lower"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"include_upper"</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"_source"</span>: [</span><br><span class="line">    <span class="string">"field1"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><code>sort</code></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"size"</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"bool"</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"sort"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"field1"</span>: &#123;</span><br><span class="line">        <span class="string">"order"</span>: <span class="string">"desc"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"_source"</span>: [</span><br><span class="line">    <span class="string">"field1"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多重过滤"><a href="#多重过滤" class="headerlink" title="多重过滤"></a>多重过滤</h2><p><code>filter</code></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">GET index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"size"</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"bool"</span>: &#123;</span><br><span class="line">      <span class="string">"filter"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"bool"</span>: &#123;</span><br><span class="line">            <span class="string">"must"</span>: &#123;</span><br><span class="line">              <span class="string">"term"</span>: &#123;</span><br><span class="line">                <span class="string">"field1"</span>: <span class="string">"value1"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"bool"</span>: &#123;</span><br><span class="line">            <span class="string">"must"</span>: &#123;</span><br><span class="line">              <span class="string">"term"</span>: &#123;</span><br><span class="line">                <span class="string">"field2"</span>: <span class="string">"value1"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">"_source"</span>: [<span class="string">"cityTerm"</span>, <span class="string">"mlsOrgId"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="脚本查询"><a href="#脚本查询" class="headerlink" title="脚本查询"></a>脚本查询</h2><p><a href="https://my.oschina.net/secisland/blog/683518" target="_blank" rel="noopener">参考链接</a></p><p><code>script</code><br>支持Groovy、java等多种语言的脚本</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"bool"</span>: &#123;</span><br><span class="line">            <span class="attr">"filter"</span>: &#123;</span><br><span class="line">              <span class="attr">"script"</span>: &#123;</span><br><span class="line">                <span class="attr">"script"</span>: &#123;</span><br><span class="line">                  <span class="attr">"inline"</span>: <span class="string">"doc['field1'].value - doc['field2'].value &gt; 0"</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Elasticsearch常用搜索
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://langonggong.com/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://langonggong.com/tags/Elasticsearch/"/>
    
      <category term="DSL" scheme="http://langonggong.com/tags/DSL/"/>
    
  </entry>
  
  <entry>
    <title>mysql分库、分区、分表、分片</title>
    <link href="http://langonggong.com/2018/08/19/mysql%E5%88%86%E5%BA%93%E3%80%81%E5%88%86%E5%8C%BA%E3%80%81%E5%88%86%E8%A1%A8%E3%80%81%E5%88%86%E7%89%87/"/>
    <id>http://langonggong.com/2018/08/19/mysql分库、分区、分表、分片/</id>
    <published>2018-08-19T01:20:32.000Z</published>
    <updated>2020-06-22T16:40:36.959Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>mysql的分表是真正的分表，一张表分成很多表后，每一个小表都是完正的一张表，都对应三个文件（MyISAM引擎：一个.MYD数据文件，.MYI索引文件，.frm表结构文件）<br>分表后数据都是存放在分表里，总表只是一个外壳，存取数据发生在一个一个的分表里面</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>一张表的查询速度已经慢到影响使用的时候</li><li>当频繁插入或者联合查询时，速度变慢</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>利用merge存储引擎来实现分表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb_member1`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`sex`</span> tinyint(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM AUTO_INCREMENT=<span class="number">2</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb_member2`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`sex`</span> tinyint(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM AUTO_INCREMENT=<span class="number">2</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb_member`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`sex`</span> tinyint(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MRG_MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 INSERT_METHOD=<span class="keyword">LAST</span> <span class="keyword">UNION</span>=(<span class="string">`tb_member1`</span>,<span class="string">`tb_member2`</span>)</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>分表数据库引擎是MyISAM</li><li>分表与主表的字段定义一致</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/miketwais/articles/mysql_partition.html" target="_blank" rel="noopener">参考链接1</a></p><p><a href="https://www.cnblogs.com/lucky-man/p/6207873.html" target="_blank" rel="noopener">参考链接2</a></p><h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>把存放数据的文件分成了许多小块，分区后的表还是一张表</p><h2 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>一张表的查询速度已经慢到影响使用的时候</li><li>表中的数据是分段的</li><li>对数据的操作往往只涉及一部分数据，而不是所有的数据</li></ul><p>历史数据或不常访问的数据占很大部分，最新或热点数据占的比例不是很大，可以根据有些条件进行表分区。例如，表中有大量的历史记录，而“热数据”却位于表的末尾</p><h2 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h2><div class="table-container"><table><thead><tr><th style="text-align:center">分区类型</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center">RANGE</td><td style="text-align:center">基于属于一个给定连续区间的列值，把多行分配给分区</td></tr><tr><td style="text-align:center">LIST</td><td style="text-align:center">类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择</td></tr><tr><td style="text-align:center">HASH</td><td style="text-align:center">基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式</td></tr><tr><td style="text-align:center">KEY</td><td style="text-align:center">类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值</td></tr></tbody></table></div><h2 id="操作方式"><a href="#操作方式" class="headerlink" title="操作方式"></a>操作方式</h2><p>创建分区</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sales (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT,</span><br><span class="line">    amount <span class="keyword">DOUBLE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    order_day DATETIME <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>, order_day)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">Innodb</span> </span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(<span class="keyword">YEAR</span>(order_day)) (</span><br><span class="line">    <span class="keyword">PARTITION</span> p_2010 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2010</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p_2011 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2011</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p_2012 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2012</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p_catchall <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> MAXVALUE);</span><br></pre></td></tr></table></figure><p>常用操作</p><p><img src="/images/mysql-PARTITION-use.jpg"></p><h2 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/laoyang360/article/details/52886987" target="_blank" rel="noopener">参考链接1</a></p><p><a href="https://www.cnblogs.com/mliudong/p/3625522.html" target="_blank" rel="noopener">参考链接2</a></p><h1 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h1><p><a href="https://www.cnblogs.com/sunny3096/p/8595058.html" target="_blank" rel="noopener">参考链接</a></p><h1 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h1><p><a href="https://www.cnblogs.com/vadim/p/6985430.html" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      《高性能mysql》读书笔记
    
    </summary>
    
      <category term="mysql" scheme="http://langonggong.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://langonggong.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>java虚拟机</title>
    <link href="http://langonggong.com/2018/08/19/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://langonggong.com/2018/08/19/java虚拟机/</id>
    <published>2018-08-18T22:07:10.000Z</published>
    <updated>2020-06-22T16:40:36.959Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><p><img src="/images/jvm_ architect.png"></p><h2 id="Java堆（Heap）"><a href="#Java堆（Heap）" class="headerlink" title="Java堆（Heap）"></a>Java堆（Heap）</h2><p>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中<code>最大</code>的一块。Java堆是被所有线程共享的一块内存区域，<code>在虚拟机启动时创建</code>。此内存区域的唯一目的就是存放对象实例，<code>几乎所有的对象实例都在这里分配内存</code>。</p><p>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“<code>GC堆</code>”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。</p><p>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。</p><p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，<code>它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</code>。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p><p>对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“<code>永久代</code>”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。</p><p>Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。</p><p>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><h2 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h2><p>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是<code>当前线程所执行的字节码的行号指示器</code>。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），<code>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</code>。 </p><p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 </p><p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。</p><p><code>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域</code>。</p><h2 id="JVM栈（JVM-Stacks）"><a href="#JVM栈（JVM-Stacks）" class="headerlink" title="JVM栈（JVM Stacks）"></a>JVM栈（JVM Stacks）</h2><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，<code>它的生命周期与线程相同</code>。虚拟机栈描述的是Java方法执行的内存模型：<code>每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息</code>。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。<br><a href="https://blog.csdn.net/xtayfjpk/article/details/41924283" target="_blank" rel="noopener">运行时栈帧结构</a></p><p>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p><p>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p>在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。</p><h2 id="本地方法栈（Native-Method-Stacks）"><a href="#本地方法栈（Native-Method-Stacks）" class="headerlink" title="本地方法栈（Native Method Stacks）"></a>本地方法栈（Native Method Stacks）</h2><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是<code>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务</code>。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><h3 id="句柄方式"><a href="#句柄方式" class="headerlink" title="句柄方式"></a>句柄方式</h3><p>如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息</p><p>优点<br>使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改</p><p><img src="/images/jvm_obj_handle.png"></p><h3 id="直接指针方式"><a href="#直接指针方式" class="headerlink" title="直接指针方式"></a>直接指针方式</h3><p>如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址</p><p>优点<br>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本</p><p><img src="/images/jvm_obj_ cursor.png"></p><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><h2 id="对象存活分析"><a href="#对象存活分析" class="headerlink" title="对象存活分析"></a>对象存活分析</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>原理<br>给对象中每一个对象分配一个引用计数器，每当有地方引用该对象时，引用计数器的值加一，当引用失效时，引用计数器的值减一，不管什么时候，只要引用计数器的值等于0了，说明该对象不可能再被使用了</p><p>优缺点<br>实现原理简单，而且判定效率很高。大部分情况下都是一个不错的算法。但很难解决对象之间相互循环引用的问题</p><h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>原理<br>通过一系列被称为“GC Roots‘’的对象作为起始点，从这些节点向下搜索，搜索所走过的路径叫做引用链，当一个节点到GC Roots没有任何引用链时，证明该对象不可用了</p><p>被作为GC Roots的对象有以下几种:</p><ul><li>虚拟机栈中引用的对象（栈帧中的引用变量表）</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中Native方法（JNI）引用的对象</li></ul><h2 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h2><p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类</p><p>废弃常量回收<br>回收废弃常量与回收Java堆中的对象非常相似。以常量池中字面量的回收为例，若字符串“abc”已经进入常量池中，但当前系统没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用该字面量，若发生内存回收，且必要的话，该“abc”就会被系统清理出常量池。常量池中其他的类（接口）、方法、字段的符号引用与此类似</p><p>无用的类回收</p><ul><li>该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例</li><li>加载该类的ClassLoader已经被回收</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul><p>在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出</p><h2 id="新生代、老年代以及永久代"><a href="#新生代、老年代以及永久代" class="headerlink" title="新生代、老年代以及永久代"></a>新生代、老年代以及永久代</h2><p><img src="/images/java-heap.jpeg"></p><p>堆大小 = 新生代 + 老年代</p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>1个Eden区和2个Survivor区（分别叫from和to）,默认比例为8：1。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。</p><p>因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在<code>年轻代的垃圾回收算法使用的是复制算法</code></p><p>在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”</p><p><img src="/images/java-new-generation.png"></p><h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>老年代与新生代不同，对象存活的时间比较长，比较稳定，因此采用标记（Mark）算法来进行回收</p><h3 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h3><p>在JDK的HotSpot虚拟机中，可以认为方法区就是永久代，但是在其他类型的虚拟机中，没有永久代的概念</p><h2 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h2><ul><li><p>Minor GC<br>  发生在新生代中的垃圾收集动作，所采用的是复制算法</p></li><li><p>FullGC (Major GC)<br>  发生在老年代的垃圾收集动作，所采用的是标记-清除算法</p></li></ul><h2 id="JVM内存管理参数"><a href="#JVM内存管理参数" class="headerlink" title="JVM内存管理参数"></a>JVM内存管理参数</h2><p><a href="https://blog.csdn.net/Thousa_Ho/article/details/77278656" target="_blank" rel="noopener">JVM参数使用总结</a></p><ul><li>-Xms 设置堆的最小空间大小</li><li>-Xmx 设置堆的最大空间大小</li><li>-XX:NewSize 设置新生代最小空间大小</li><li>-XX:MaxNewSize 设置新生代最大空间大小</li><li>-Xmn:设置新生代的内存空间大小</li><li>-XX:PermSize 设置永久代最小空间大小</li><li>-XX:MaxPermSize 设置永久代最大空间大小</li><li>-Xss 设置每个线程的堆栈大小。</li><li>-XX:NewRatio 设置新生代和老生代的相对大小</li><li>-XX:SurvivorRatio 指定Eden区和Survivor区的大小比例,注意两个幸存区是一样大的</li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><ul><li><p>复制算法(新生代)<br>该算法的核心是将可用内存按容量划分为大小相等的两块, 每次只用其中一块, 当这一块的内存用完, 就将还存活的对象复制到另外一块上面, 然后把已使用过的内存空间一次清理掉</p></li><li><p>标记清除算法(老年代)(mark-sweep)<br>该算法分为“标记”和“清除”两个阶段: 首先标记出所有需要回收的对象(可达性分析), 在标记完成后统一清理掉所有被标记的对象</p><p>  该算法会有以下两个问题</p><ul><li>效率问题: 标记和清除过程的效率都不高;</li><li>空间问题: 标记清除后会产生大量不连续的内存碎片, 空间碎片太多可能会导致在运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集</li></ul></li><li><p>标记整理算法(老年代)(mark-compact)<br>标记清除算法会产生内存碎片问题, 而复制算法需要有额外的内存担保空间, 于是针对老年代的特点, 又有了标记整理算法. 标记整理算法的标记过程与标记清除算法相同, 但后续步骤不再对可回收对象直接清理, 而是让所有存活的对象都向一端移动,然后清理掉端边界以外的内存</p></li></ul><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="/images/GC-collertor2.jpg"></p><p><a href="https://blog.csdn.net/qq_33938256/article/details/52502502" target="_blank" rel="noopener">GC收集器</a><br><a href="http://www.importnew.com/23035.html" target="_blank" rel="noopener">内存分配、GC原理与垃圾收集器</a></p><ul><li>串行收集器 Serial开头的 <ul><li>Serial</li><li>Serial Old(MSC)</li></ul></li><li>并行收集器 Parallel开头的 <ul><li>ParNew</li><li>Parallel Scavenge</li><li>Parallel Old</li></ul></li><li>并发收集器 <ul><li>CMS (Concurrent Mark Sweep)</li></ul></li><li>G1(Garbage First)<br>  图片中的问号位置<br>  JDK 1.7后有G1</li></ul><p>说明：</p><ul><li>Parallel Scanvenge<br>  也叫吞吐量优先收集器，吞吐量=运行用户代码时间/(运行用户代码时间 + GC时间)。停顿时间短，适合与用户交互的程序；高吞吐量，可以有效利用CPU时间，尽管完成计算任务，适合后台运算而不需要太多交互的任务</li><li>CMS<br>  目标：最短回收停顿时间。并发收集，低停顿，适合B/S架构，需要低延迟时间的应用需求</li></ul><h2 id="GC日志"><a href="#GC日志" class="headerlink" title="GC日志"></a>GC日志</h2><p>日志格式<br><img src="/images/gc_log.png"></p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">GC（GC类型，当前是Minor</span> GC） (<span class="name">Allocation</span> Failure) [<span class="name">DefNew（GC的区域，当前为新生代）:</span> <span class="number">5688</span>K（垃圾回收前的大小）-&gt;790K（垃圾回收以后的大小）(<span class="name">9216K</span>)（该区域总大小）, <span class="number">0.0060899</span> secs] <span class="number">5688</span>K（堆在垃圾回收前的大小）-&gt;4886K（堆在垃圾回收后的大小）(<span class="name">19456K</span>)（堆的总大小）, <span class="number">0.0061183</span> secs] [<span class="name">Times:</span> user=0.00（用户态消耗CPU时间） sys=0.01（内核态小时CPU时间）, real=0.00 secs（操作的实际时间）]</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/fd1d4f21733a" target="_blank" rel="noopener">理解GC日志</a><br><a href="https://www.cnblogs.com/duke2016/p/6250766.html" target="_blank" rel="noopener">GC收集器与GC日志</a></p><ul><li>大对象直接进入老年代</li><li>长期存活的对象进入老年代</li></ul><h1 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h1><p><img src="/images/class.png"></p><p><a href="https://blog.csdn.net/column/details/jvm-principle.html" target="_blank" rel="noopener">参考系列</a></p><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><p><img src="/images/class-load.png"></p><p><a href="https://blog.csdn.net/fgets/article/details/52934178" target="_blank" rel="noopener">参考链接</a><br><a href="https://blog.csdn.net/shakespeare001/article/details/51765353" target="_blank" rel="noopener">参考章节</a></p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><ul><li>通过一个类的全限定名来获取其定义的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口</li></ul><p>除了可以使用系统提供的引导类加载器外，还可以使用用户自定义的类加载器。任意一个类，都需要由加载它的类加载器和这个类本身共同确定其在Java 虚拟机中的唯一性</p><p>类加载器</p><p><img src="/images/classLoader.png"></p><ul><li>启动类加载器：启动类加载器无法被 java 程序直接引用，如需要，直接使用 null 代替即可</li><li>扩展类加载器</li><li>应用程序类加载器：它负责加载用户路径(ClassPath)上所指定的类库，开发者可以使用这个类加载器，如果应用程序没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器</li></ul><p>双亲委派模型<br>如果一个类加载器收到了类加载器的请求，它首先不会自己尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类时），子加载类才会尝试自己去加载</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</p><ul><li>文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理</li><li>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，主要是验证类的继承关系、数据类型是否符合</li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。对类的方法体进行校验分析，以保证被校验类的方法在运行时不会做出危害虚拟机安全的事件</li><li>符号引用验证：发生在虚拟机将符号引用转化为直接引用的时候,对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验</li></ul><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配</p><ul><li>这阶段进行内存分配的仅包括类变量（即被static修饰的变量），不包括实例变量</li><li>这里所说的初始值“通常情况”下是数据类型的零值</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程</p><ul><li>符号引用（Symbolic References）：即用一组符号来描述所引用的目标。它与虚拟机的内存布局无关，引用的目标不一定已经加载到内存中</li><li>直接引用（Direct References）：直接引用可以是指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。它是和虚拟机内存布局相关的，如果有了直接引用，那引用的目标必定已经在内存中存在了</li></ul><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7类符号引用进行</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化是类加载过程的最后一步，此阶段才开始真正执行类中定义的Java程序代码（或者说字节码，也仅限与执行<clinit>()方法）。在准备阶段，我们已经给变量付过一次系统要求的初始值（零值），而在初始化阶段，则会根据程序员的意愿给类变量和其他资源赋值。主要是通过<clinit>()方法来执行的</clinit></clinit></p><h1 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h1><p><a href="https://blog.csdn.net/u013678930/article/details/51980460" target="_blank" rel="noopener">章节参考</a></p><h1 id="Java编译期优化"><a href="#Java编译期优化" class="headerlink" title="Java编译期优化"></a>Java编译期优化</h1><p><img src="/images/jvm_complier.png"></p><h2 id="解析与填充符号表过程"><a href="#解析与填充符号表过程" class="headerlink" title="解析与填充符号表过程"></a>解析与填充符号表过程</h2><p>解析步骤包含了词法分析和语法分析两个过程，首先词法分析是将源代码的字符流转变成为标记集合（token），然后语法分析是根据token序列来构造抽象语法树（一种用来描述程序代码语法结构的树状表示方式）。完成词法分析和语法分析之后，下一步是填充符号表，符号表是由一组符号地址和符号信息构成的表格，符号表中所登记的信息在编译的不同阶段都要用到（比如语义分析中符号表所登记的内容将用于语义检查和产生中间代码，目标代码生成阶段当对符号名进行地址分配时，符号表是地址分配的依据）</p><h2 id="插入式注解处理器的注解处理过程"><a href="#插入式注解处理器的注解处理过程" class="headerlink" title="插入式注解处理器的注解处理过程"></a>插入式注解处理器的注解处理过程</h2><p>插入式注解处理器可以看做是一组编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，那么编译器将回到解析及填充符号表的过程重新处理，直到所有的插入式注解处理器都没有再对语法树进行修改为止</p><h2 id="语义分析与字节码生成过程"><a href="#语义分析与字节码生成过程" class="headerlink" title="语义分析与字节码生成过程"></a>语义分析与字节码生成过程</h2><p>语法分析之后，编译器获得了程序代码的抽象语法树表示，语法树能够表示结构正确的源程序的抽象，但是无法保证源程序是否符合逻辑，而语义分析主要是对结构上正确的源程序进行上下文有关性质的检查</p><h3 id="标注检查"><a href="#标注检查" class="headerlink" title="标注检查"></a>标注检查</h3><p>标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配，等等。还有一个重要的动作称为常量折叠也在此阶段完成</p><h3 id="数据及控制流分析"><a href="#数据及控制流分析" class="headerlink" title="数据及控制流分析"></a>数据及控制流分析</h3><p>数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否有返回值、是否所有的受查异常都被正确处理了等问题</p><h3 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h3><p>语法糖是指在计算机语言中添加某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。java中的泛型，变长参数，自动拆箱与装箱，条件编译等就属于语法糖，它们在编译阶段就被还原成简单的语法结构（比如List<string>和List<integer>在运行期间其实是同一个类）</integer></string></p><h3 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h3><p>此过程是javac编译过程的最后一个阶段，字节码生成阶段将之前各个步骤所生成的信息转化成字节码写到磁盘中，另外还进行少量的代码添加和转换工作</p><h1 id="Java运行期优化"><a href="#Java运行期优化" class="headerlink" title="Java运行期优化"></a>Java运行期优化</h1><p><img src="/images/jvm_jit.png"></p><p>在部分商用虚拟机中，java程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块运行特别频繁，就会把这些代码认定为“热点代码”，为了提高热点代码的执行效率，在运行时，虚拟机就会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器或JIT编译器。</p><p>即时编译器并不是虚拟机必须的部分，但是即时编译器编译性能的好坏、代码优化程度的高低确是衡量一款商用虚拟机优秀与否的最关键的指标之一。</p><p>众多主流的虚拟机都同时包含解释器和JIT编译器，解释器与JIT编译器各有优势：当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行。当程序运行后，随着事件的推移，JIT编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率</p><p>会被即时编译器编译的热点代码有两类</p><ul><li>被多次调用的方法体</li><li>被多次调用的循环体</li></ul><p>即时编译器会以整个方法作为编译对象，将其编译成机器码。这种编译方式因为编译发生在方法执行过程之中，因此被称作栈上替换（OSR）</p><p>判断一段代码是否是热点代码的方式（热点探测）有两种</p><ul><li>基于采样的热点探测：此方法会周期性检查各个线程的栈顶，如果发现某个或某些方法经常出现在栈顶，那么这个方法就是热点方法。此方法的缺点是很难精确地确认一个方法的热度，容易受到诸如线程阻塞等因素影响</li><li>基于计数器的热点探测：此方法会为每个方法甚至是代码块建立计数器，统计方法的执行次数，如果执行次数超过一个阀值就认为它是热点方法</li></ul><p>默认设置下，执行引擎并不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成。当编译工作完成之后，这个方法的调用入口地址就会被系统自动改写成新的地址，下一次调用该方法时就会使用已编译的版本。也就是说，在编译器还未完成之前，执行引擎仍按照解释方式继续执行，而编译动作则在后台的编译线程中进行</p><p>优化技术<br>一般来说即时编译器所产生的本地代码会比javac产生的字节码更优秀。即时编译器采用了一系列的技术来优化代码，比如公共子表达式消除，数组范围内检查消除，方法内联，逃逸分析等</p>]]></content>
    
    <summary type="html">
    
      《深入理解JAVA虚拟机实战》读书笔记
    
    </summary>
    
      <category term="java" scheme="http://langonggong.com/categories/java/"/>
    
      <category term="jvm" scheme="http://langonggong.com/categories/java/jvm/"/>
    
    
      <category term="java" scheme="http://langonggong.com/tags/java/"/>
    
      <category term="jvm" scheme="http://langonggong.com/tags/jvm/"/>
    
  </entry>
  
</feed>

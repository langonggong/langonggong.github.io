<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>武汉旭神</title>
  
  <subtitle>路漫漫其修远兮，吾将上下而求索</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-19T15:02:55.807Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>lanxu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>滑动窗口算法</title>
    <link href="http://yoursite.com/2018/09/19/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/09/19/滑动窗口算法/</id>
    <published>2018-09-19T14:56:15.000Z</published>
    <updated>2018-09-19T15:02:55.807Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>题目描述</p><blockquote><p>有一个整型数组 arr 和一个大小为 w 的窗口从数组的最左边滑到最右边,窗口每次向右边滑一个位置。 返回一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值。 以数组为[4,3,5,4,3,3,6,7]，w=3为例。因为第一个窗口[4,3,5]的最大值为5，第二个窗口[3,5,4]的最大值为5，第三个窗口[5,4,3]的最大值为5。第四个窗口[4,3,3]的最大值为4。第五个窗口[3,3,6]的最大值为6。第六个窗口[3,6,7]的最大值为7。所以最终返回[5,5,5,4,6,7]。</p><p>给定整形数组arr及它的大小n，同时给定w，请返回res数组。保证w小于等于n，同时保证数组大小小于等于500。</p></blockquote><p>解题思路</p><blockquote><p>使用一个长度为w的双端队列，存储数组的索引。每次有新元素加入，将小于或等于改元素的值的原有元素对应的索引删掉，将不在该窗口范围的索引删掉。队列的索引对应的元素值倒序排序。则队列的第一个元素始终为该窗口内最大值的索引</p></blockquote><p>参考代码<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlideWindow</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] slide(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> w) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || arr.length &lt; w) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedList&lt;Integer&gt; <span class="keyword">list</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length - w + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="comment">//把较小的值挤掉，按照从大到小排序</span></span><br><span class="line">      <span class="keyword">while</span> (!<span class="keyword">list</span>.isEmpty() &amp;&amp; arr[<span class="keyword">list</span>.peekLast()] &lt;= arr[i]) &#123;</span><br><span class="line">        <span class="keyword">list</span>.pollLast();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">list</span>.addLast(i);</span><br><span class="line">      <span class="comment">//不在窗口里面的元素删掉</span></span><br><span class="line">      <span class="keyword">if</span> (i - <span class="keyword">list</span>.peekFirst() == w) &#123;</span><br><span class="line">        <span class="keyword">list</span>.pollFirst();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= w) &#123;</span><br><span class="line">        result[index++] = arr[<span class="keyword">list</span>.peekFirst()];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      滑动窗口算法
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="队列" scheme="http://yoursite.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>小范围排序</title>
    <link href="http://yoursite.com/2018/09/07/%E5%B0%8F%E8%8C%83%E5%9B%B4%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/09/07/小范围排序/</id>
    <published>2018-09-06T17:04:14.000Z</published>
    <updated>2018-09-06T17:23:57.690Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>题目描述</p><blockquote><p>已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序</p></blockquote><p>解题思路</p><blockquote><p>使用变种的堆排序：维护一个长度为k的最小根堆，将数组的元素不断的加入堆中，调整后将堆顶弹出赋给数组，将排序的范围始终限制在长度为k、近乎排序的堆中</p></blockquote><p>参考代码<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class ScaleSort &#123;</span><br><span class="line">  public <span class="type">int</span>[] sortElement(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == null || arr.<span class="built_in">length</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建长度为k的小根堆，此过程也可以在heap数组中进行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = k / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      headAdjust(arr, i, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将调整好的最小根堆赋值给heap数组</span></span><br><span class="line">    <span class="type">int</span>[] heap = new <span class="type">int</span>[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">      heap[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//每从最小跟堆中弹出堆顶给数组，就从数组中弹出一个元素给堆，再次调整为最小跟堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; arr.<span class="built_in">length</span>; i++) &#123;</span><br><span class="line">      arr[i - k] = heap[<span class="number">0</span>];</span><br><span class="line">      heap[<span class="number">0</span>] = arr[i];</span><br><span class="line">      headAdjust(heap, <span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最小根堆不能保证左右节点之间的大小顺序，所以不能直接将heap完整复制给arr</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = arr.<span class="built_in">length</span> - k; i &lt; arr.<span class="built_in">length</span>; i++) &#123;</span><br><span class="line">      arr[i] = heap[<span class="number">0</span>];</span><br><span class="line">      <span class="comment">//由于堆中没有新的元素加入，只能每次将堆顶放到后面，对前面一部分进行堆调整</span></span><br><span class="line">      swap(heap, <span class="number">0</span>, arr.<span class="built_in">length</span> - i - <span class="number">1</span>);</span><br><span class="line">      headAdjust(heap, <span class="number">0</span>, arr.<span class="built_in">length</span> - i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//堆调整，保证[index,length)这条支线满足最小根堆</span></span><br><span class="line">  private <span class="type">void</span> headAdjust(<span class="type">int</span>[] arr, <span class="type">int</span> <span class="keyword">index</span>, <span class="type">int</span> <span class="built_in">length</span>) &#123;</span><br><span class="line">    <span class="type">int</span> minIndex, left, right;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">index</span> &lt; <span class="built_in">length</span>) &#123;</span><br><span class="line">      minIndex = <span class="keyword">index</span>;</span><br><span class="line">      left = <span class="number">2</span> * <span class="keyword">index</span> + <span class="number">1</span>;</span><br><span class="line">      right = <span class="number">2</span> * <span class="keyword">index</span> + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (left &lt; <span class="built_in">length</span> &amp;&amp; arr[left] &lt; arr[minIndex]) &#123;</span><br><span class="line">        minIndex = left;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (right &lt; <span class="built_in">length</span> &amp;&amp; arr[right] &lt; arr[minIndex]) &#123;</span><br><span class="line">        minIndex = right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//临界条件，表示无需再调整</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">index</span> == minIndex) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(arr, <span class="keyword">index</span>, minIndex);</span><br><span class="line">      <span class="keyword">index</span> = minIndex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static <span class="type">void</span> swap(<span class="type">int</span>[] arr, <span class="type">int</span> index1, <span class="type">int</span> index2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index1 == index2) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tmp = arr[index1];</span><br><span class="line">    arr[index1] = arr[index2];</span><br><span class="line">    arr[index2] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      几乎有序的数组进行排序
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>DNS解析</title>
    <link href="http://yoursite.com/2018/09/06/DNS%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/09/06/DNS解析/</id>
    <published>2018-09-06T08:46:42.000Z</published>
    <updated>2018-09-06T09:56:17.291Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>nslookup<br><img src="/images/nslook-baidu.png"></p><p>第一行Server是：DNS服务器的主机名—10.4.1.14<br>第二行Address是：它的IP地址—10.4.1.14#53</p><p>百度有一个cname = www.a.shifen.com的别名</p><p>下面的Name是：解析的URL—www.a.shifen.com<br>Address是：解析出来的IP—220.181.112.244和220.181.111.188</p><p>dig www.baidu.com +trace<br><img src="/images/dig-baidu.jpg">    </p><p>Dig工具会在本地计算机做迭代，然后记录查询的过程</p><ul><li>第一步，向我这台机器的ISPDNS获取到根域服务区的13个IP和主机名[b-j].root-servers.net.</li><li>第二步，向其中的一台根域服务器（m.root-servers.net）发送www.baidu.com的查询请求，他返回了com.顶级域的服务器名称</li><li>第三步，向com.域的一台服务器i.gtld-servers.net请求,www.baidu.com，他返回了baidu.com域的服务器IP（未显示）和名称，百度有5台顶级域的服务器</li><li>第四步，向百度的顶级域服务器（202.108.22.220）请求www.baidu.com，他发现这个www有个别名，而不是一台主机，别名是www.a.shifen.com</li></ul><p>当dns请求到别名的时候，查询不会终止，而是重新发起查询别名的请求，此处返回的是www.a.shifen.com，然后继续请求</p><p>使用dig www.a.shifen.com +trace查看<br><img src="/images/dig-shifen.jpg">    </p><p>再一次去请求com域，重复上面的步骤，最终从ns X.a.shifen.com中一台拿到了一条A记录，便是www.baidu.com的IP地址了</p>]]></content>
    
    <summary type="html">
    
      DNS解析
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="DNS" scheme="http://yoursite.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>基数排序</title>
    <link href="http://yoursite.com/2018/09/05/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/09/05/基数排序/</id>
    <published>2018-09-05T15:41:05.000Z</published>
    <updated>2018-09-06T15:00:43.761Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>1、构造从0到9的10个桶，将数组的每个元素按照个位数的大小放入对应的桶中<br>2、构造新的10个桶，将原桶中的数字依次弹出，按照十位数的大小依次放入对应的新桶中<br>3、对百位、千位等按照上述步骤处理</p><p>需考虑负数</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RadixSort</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">radixSort</span>(<span class="params"><span class="keyword">int</span>[] arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> posNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        posNum++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] posArr = <span class="keyword">new</span> <span class="keyword">int</span>[posNum];</span><br><span class="line">    <span class="keyword">int</span>[] negArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length - posNum];</span><br><span class="line">    <span class="keyword">int</span> posIndex = <span class="number">0</span>, negIndex = <span class="number">0</span>, posMax = <span class="number">0</span>, negMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        posArr[posIndex++] = i;</span><br><span class="line">        posMax = Math.max(posMax, i);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> j = -i;</span><br><span class="line">        negArr[negIndex++] = j;</span><br><span class="line">        negMax = Math.max(j, negMax);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    radixSortForPositive(posArr, posMax);</span><br><span class="line">    radixSortForPositive(negArr, negMax);</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=negArr.length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">      arr[index++] = -negArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;posArr.length;i++) &#123;</span><br><span class="line">      arr[index++] = posArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//针对正数的基数排序</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSortForPositive</span>(<span class="params"><span class="keyword">int</span>[] arr, <span class="keyword">int</span> max</span>) </span>&#123;</span><br><span class="line">    List&lt;LinkedList&lt;Integer&gt;&gt; temp1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;LinkedList&lt;Integer&gt;&gt; temp2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      temp1.<span class="keyword">add</span>(<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">      temp2.<span class="keyword">add</span>(<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按照个位数的大小将元素放入桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">      temp1.<span class="keyword">get</span>(i % <span class="number">10</span>).<span class="keyword">add</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> <span class="keyword">base</span> = <span class="number">10</span>; <span class="keyword">base</span> &lt;= max; <span class="keyword">base</span> *= <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (LinkedList&lt;Integer&gt; integers : temp1) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!integers.isEmpty()) &#123;</span><br><span class="line">          Integer integer = integers.pop();</span><br><span class="line">          temp2.<span class="keyword">get</span>((integer / <span class="keyword">base</span>) % <span class="number">10</span>).<span class="keyword">add</span>(integer);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      List&lt;LinkedList&lt;Integer&gt;&gt; temp;</span><br><span class="line">      temp = temp1;</span><br><span class="line">      temp1 = temp2;</span><br><span class="line">      temp2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (LinkedList&lt;Integer&gt; integers : temp1) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Integer integer : integers) &#123;</span><br><span class="line">        arr[index++] = integer;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      按照位数从低到高依次排序
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>计数排序</title>
    <link href="http://yoursite.com/2018/09/05/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/09/05/计数排序/</id>
    <published>2018-09-05T15:37:25.000Z</published>
    <updated>2018-09-06T02:13:48.172Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>根据数组最大最小值构建数组，记录每个数字出现次数</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class CountingSort &#123;</span><br><span class="line"></span><br><span class="line">  public <span class="type">int</span>[] countingSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == null || arr.<span class="built_in">length</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">min</span> = arr[<span class="number">0</span>], <span class="built_in">max</span> = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.<span class="built_in">length</span>;i++) &#123;</span><br><span class="line">      <span class="built_in">min</span> = Math.<span class="built_in">min</span>(<span class="built_in">min</span>, arr[i]);</span><br><span class="line">      <span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] store = new <span class="type">int</span>[<span class="built_in">max</span> - <span class="built_in">min</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;arr.<span class="built_in">length</span>;j++) &#123;</span><br><span class="line">      store[arr[j] - <span class="built_in">min</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;store.<span class="built_in">length</span>;k++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (store[k]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        arr[<span class="keyword">index</span>++] = k + <span class="built_in">min</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      根据数组最大最小值构建数组，记录每个数字出现次数
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>希尔排序</title>
    <link href="http://yoursite.com/2018/09/05/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/09/05/希尔排序/</id>
    <published>2018-09-05T15:00:26.000Z</published>
    <updated>2018-09-05T15:37:11.765Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>令k=2<br>1、将数组分成k等分，构建length/2个间隔为k的数组，对每个数组进行插入排序<br>2、k=k*2,重复步骤1</p><p>插入排序:假设前面的数组已经有序，则找到改点合适的位置插入(该点下沉到合适的位置)</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] shellSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = arr.length ;</span><br><span class="line">    <span class="comment">//将数组2等分，4等分...直到一等分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = length &gt;&gt; <span class="number">1</span>; gap &gt; <span class="number">0</span>; gap &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">//对生成的多个数组进行插入排序</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> start = gap; start &lt; arr.length; start++) &#123;</span><br><span class="line">        <span class="comment">//对单个数组进行插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> <span class="keyword">index</span> = start; <span class="keyword">index</span> &gt;= gap; <span class="keyword">index</span> -= gap) &#123;</span><br><span class="line">          <span class="keyword">if</span> (arr[<span class="keyword">index</span> - gap] &gt; arr[<span class="keyword">index</span>]) &#123;</span><br><span class="line">            swap(arr, <span class="keyword">index</span> - gap, <span class="keyword">index</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> swap(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index1 == index2) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[index1];</span><br><span class="line">    arr[index1] = arr[index2];</span><br><span class="line">    arr[index2] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      直接插入排序的优化
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="http://yoursite.com/2018/09/05/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/09/05/堆排序/</id>
    <published>2018-09-04T16:28:14.000Z</published>
    <updated>2018-09-04T16:33:00.064Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>1、构建大根堆，满足父大于子，堆顶为最大值<br>2、将堆顶与最后一位进行替换，将前n-1位调整为大根堆<br>3、对前n-1位大根堆重复过程2</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class HeapSort &#123;</span><br><span class="line"></span><br><span class="line">  public <span class="type">int</span>[] heapSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == null || arr.<span class="built_in">length</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建大根堆，使整棵树满足:父&gt;子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = arr.<span class="built_in">length</span> / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="comment">//每次调整，都要保证将后面所有的都调整一遍</span></span><br><span class="line">      headAdjust(arr, i, arr.<span class="built_in">length</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将堆顶（最大值）替换到第j个点，然后将前面j-1个点调整为大根堆，</span></span><br><span class="line">    <span class="comment">//对前j-1个点重复此过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=arr.<span class="built_in">length</span><span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">      swap(arr, <span class="number">0</span>, j);</span><br><span class="line">      headAdjust(arr, <span class="number">0</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//保证[index,length)单条支线上的点满足:父节点大于子节点</span></span><br><span class="line">  private <span class="type">void</span> headAdjust(<span class="type">int</span>[] arr, <span class="type">int</span> <span class="keyword">index</span>,<span class="type">int</span> <span class="built_in">length</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">index</span> &lt; <span class="built_in">length</span>) &#123;</span><br><span class="line">      <span class="type">int</span> left = <span class="number">2</span> * <span class="keyword">index</span> + <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> right = <span class="number">2</span> * <span class="keyword">index</span> + <span class="number">2</span>;</span><br><span class="line">      <span class="type">int</span> <span class="built_in">max</span> = <span class="keyword">index</span>;</span><br><span class="line">      <span class="keyword">if</span> (left &lt; <span class="built_in">length</span> &amp;&amp; arr[left] &gt; arr[<span class="keyword">index</span>]) &#123;</span><br><span class="line">        <span class="built_in">max</span> = left;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (right &lt; <span class="built_in">length</span> &amp;&amp; arr[right] &gt; arr[<span class="built_in">max</span>]) &#123;</span><br><span class="line">        <span class="built_in">max</span> = right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">index</span> == <span class="built_in">max</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(arr, <span class="keyword">index</span>, <span class="built_in">max</span>);</span><br><span class="line">      <span class="keyword">index</span> = <span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static <span class="type">void</span> swap(<span class="type">int</span>[] arr, <span class="type">int</span> index1, <span class="type">int</span> index2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index1 == index2) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tmp = arr[index1];</span><br><span class="line">    arr[index1] = arr[index2];</span><br><span class="line">    arr[index2] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      将数组作为堆结构进行处理
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://yoursite.com/2018/09/03/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/09/03/快速排序/</id>
    <published>2018-09-03T15:56:00.000Z</published>
    <updated>2018-09-03T15:59:43.943Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>选择任意一点，将元素划分为小于该值和大于该值的左右两部分，递归次过程</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> int[] <span class="built_in">quickSort</span>(int[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == null || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> void process(int[] arr, int <span class="keyword">left</span>, int <span class="keyword">right</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">left</span> &gt;= <span class="keyword">right</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    int random = <span class="keyword">left</span> + (int) <span class="type">Math</span>.random() * (<span class="keyword">right</span> - <span class="keyword">left</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">swap</span>(arr, random, <span class="keyword">right</span>);</span><br><span class="line">    int <span class="built_in">partition</span> = <span class="built_in">partition</span>(arr, <span class="keyword">left</span>, <span class="keyword">right</span>);</span><br><span class="line">    process(arr, <span class="keyword">left</span>, <span class="built_in">partition</span> - <span class="number">1</span>);</span><br><span class="line">    process(arr, <span class="built_in">partition</span> + <span class="number">1</span>, <span class="keyword">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将小于或等于right的元素替换到左边，大于right的元素保持不动</span></span><br><span class="line"><span class="comment">   * partition加一递增，指向最近一个被替换到左边的位置</span></span><br><span class="line"><span class="comment">   * 当数组遍历完，right处的元素被替换到partition所指的位置</span></span><br><span class="line"><span class="comment">   * partition左边的值全部小于或等于该值，右边的值全部大于该值</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> int <span class="built_in">partition</span>(int[] arr, int <span class="keyword">left</span>, int <span class="keyword">right</span>) &#123;</span><br><span class="line">    int <span class="built_in">partition</span> = <span class="keyword">left</span> - <span class="number">1</span>;</span><br><span class="line">    int index = <span class="keyword">left</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt;= <span class="keyword">right</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[index] &lt;= arr[<span class="keyword">right</span>]) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr, ++<span class="built_in">partition</span>, index);</span><br><span class="line">      &#125;</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">partition</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> void <span class="built_in">swap</span>(int[] arr, int index1, int index2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index1 == index2) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    int tmp = arr[index1];</span><br><span class="line">    arr[index1] = arr[index2];</span><br><span class="line">    arr[index2] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      选择任意一点，将元素划分为小于该值和大于该值的左右两部分，递归次过程
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="http://yoursite.com/2018/09/03/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/09/03/归并排序/</id>
    <published>2018-09-03T13:24:32.000Z</published>
    <updated>2018-09-04T16:40:48.825Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>二分后递归调用自身，然后对这两部分处理后的结果进行排序</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> MergeSort &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">int</span>[] mergeSort(<span class="built_in">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    divide(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    return arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> void divide(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">left</span> &gt;= <span class="built_in">right</span>) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>) / <span class="number">2</span>;</span><br><span class="line">    divide(arr, <span class="built_in">left</span>, <span class="built_in">mid</span>);</span><br><span class="line">    divide(arr, <span class="built_in">mid</span> + <span class="number">1</span>, <span class="built_in">right</span>);</span><br><span class="line">    merge(arr, <span class="built_in">left</span>, <span class="built_in">mid</span>, <span class="built_in">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> void merge(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">mid</span>, <span class="built_in">int</span> <span class="built_in">right</span>) &#123;</span><br><span class="line">    <span class="built_in">int</span>[] result = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="built_in">right</span> - <span class="built_in">left</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">int</span> i = <span class="built_in">left</span>, j = <span class="built_in">mid</span> + <span class="number">1</span>, index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= <span class="built_in">mid</span> &amp;&amp; j &lt;= <span class="built_in">right</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">        result[index++] = arr[i++];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result[index++] = arr[j++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= <span class="built_in">mid</span>) &#123;</span><br><span class="line">      result[index++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= <span class="built_in">right</span>) &#123;</span><br><span class="line">      result[index++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> k=<span class="number">0</span>;k&lt;result.length;k++) &#123;</span><br><span class="line">      arr[<span class="built_in">left</span> + k] = result[k];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      二分后递归调用自身，然后对这两部分处理后的结果进行排序
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>插入排序</title>
    <link href="http://yoursite.com/2018/09/02/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/09/02/插入排序/</id>
    <published>2018-09-02T15:10:00.000Z</published>
    <updated>2018-09-03T13:24:47.923Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>假设前面的数组已经有序，则找到改点合适的位置插入(该点下沉到合适的位置)</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InsertionSort</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">insertionSort</span>(<span class="params"><span class="keyword">int</span>[] arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> j = i;</span><br><span class="line">      <span class="keyword">while</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">          swap(arr, j, j - <span class="number">1</span>);</span><br><span class="line">          j--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span>(<span class="params"><span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      假设前面的数组已经有序，则找到改点合适的位置插入
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>选择排序</title>
    <link href="http://yoursite.com/2018/09/02/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/09/02/选择排序/</id>
    <published>2018-09-02T14:58:40.000Z</published>
    <updated>2018-09-02T15:10:08.521Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>选择最小值与第一个数字交换</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SelectSort</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">selectionSort</span>(<span class="params"><span class="keyword">int</span>[] arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> mini = i;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">        mini = arr[j] &lt; arr[mini] ? j : mini;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(arr, i, mini);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span>(<span class="params"><span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      选择最小值与第一个数字交换
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="http://yoursite.com/2018/09/02/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/09/02/冒泡排序/</id>
    <published>2018-09-02T14:49:03.000Z</published>
    <updated>2018-09-02T15:10:10.918Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>最大值上浮</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BubbleSort</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">bubbleSort</span>(<span class="params"><span class="keyword">int</span>[] arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=arr.length<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">          swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span>(<span class="params"><span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      最大值上浮
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>AQS</title>
    <link href="http://yoursite.com/2018/09/01/AQS/"/>
    <id>http://yoursite.com/2018/09/01/AQS/</id>
    <published>2018-09-01T06:14:14.000Z</published>
    <updated>2018-09-02T13:22:55.788Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在JDK1.5之前，一般是靠synchronized关键字来实现线程对共享变量的互斥访问。synchronized是在字节码上加指令，依赖于底层操作系统的Mutex Lock实现。<br>AQS定义了一套多线程访问共享资源的同步器框架，是整个java.util.concurrent包的基石，Lock、ReadWriteLock、CountDowndLatch、CyclicBarrier、Semaphore、ThreadPoolExecutor等都是在AQS的基础上实现的。</p><h1 id="同步队列-CLH"><a href="#同步队列-CLH" class="headerlink" title="同步队列(CLH)"></a>同步队列(CLH)</h1><p>AQS维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）</p><p><img src="/images/AQS同步队列模型.png"></p><p>AQS的内部队列是CLH同步锁的一种变形。其主要从两方面进行了改造，节点的结构与节点等待机制</p><ul><li>在结构上引入了头结点和尾节点，分别指向队列的头和尾，尝试获取锁、入队列、释放锁等实现都与头尾节点相关</li><li>为了可以处理timeout和cancel操作，每个node维护一个指向前驱的指针。如果一个node的前驱被cancel，这个node可以前向移动使用前驱的状态字段</li><li>在每个node里面使用一个状态字段来控制阻塞/唤醒，而不是自旋</li><li>head结点使用的是傀儡结点</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span>&#123;</span></span><br><span class="line"><span class="comment">//指向同步队列队头</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指向同步的队尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步状态，在不同的子类有不同的含义</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略其他代码......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h2><p>Node结点是对每一个访问同步代码的线程的封装，从图中的Node的数据结构也可看出，其包含了需要同步的线程本身以及线程的状态，如是否被阻塞，是否等待唤醒，是否已经被取消等。每个Node结点内部关联其前继结点prev和后继结点next，这样可以方便线程释放锁后快速唤醒下一个在等待的线程，Node是AQS的内部类，其数据结构如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">//共享模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">//独占模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标识线程已处于结束状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//等待被唤醒状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//条件状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//在共享模式中使用表示获得的同步状态会被传播</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待状态,存在CANCELLED、SIGNAL、CONDITION、PROPAGATE 4种</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同步队列中前驱结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">//同步队列中后继结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">//请求锁的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="comment">//等待队列中的后继结点，这个与Condition有关</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否为共享模式</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取前驱结点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中SHARED和EXCLUSIVE常量分别代表共享模式和独占模式，所谓共享模式是一个锁允许多条线程同时操作，如信号量Semaphore采用的就是基于AQS的共享模式实现的，而独占模式则是同一个时间段只能有一个线程对共享资源进行操作，多余的请求线程需要排队等待，如ReentranLock。变量waitStatus则表示当前被封装成Node结点的等待状态，共有4种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE</p><ul><li>CANCELLED：值为1，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node的结点，其结点的waitStatus为CANCELLED，即结束状态，进入该状态后的结点将不会再变化。</li><li>SIGNAL：值为-1，被标识为该等待唤醒状态的后继结点，当其前继结点的线程释放了同步锁或被取消，将会通知该后继结点的线程执行。说白了，就是处于唤醒状态，只要前继结点释放锁，就会通知标识为SIGNAL状态的后继结点的线程执行。</li><li>CONDITION：值为-2，与Condition相关，该标识的结点处于等待队列中，结点的线程等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。</li><li>PROPAGATE：值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态。</li><li>0状态：值为0，代表初始化状态。</li></ul><h2 id="AQS-lock-操作"><a href="#AQS-lock-操作" class="headerlink" title="AQS lock()操作"></a>AQS lock()操作</h2><p><img src="/images/AQS-lock.png"></p><h1 id="Sync与State实现"><a href="#Sync与State实现" class="headerlink" title="Sync与State实现"></a>Sync与State实现</h1><h2 id="state机制"><a href="#state机制" class="headerlink" title="state机制"></a>state机制</h2><p>volatile 变量 state;  用于同步线程之间的共享状态。通过 CAS 和 volatile 保证其原子性和可见性。<br>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步状态 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//CAS </span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this  </span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> unsafe.<span class="title">compareAndSwapInt</span><span class="params">(<span class="keyword">this</span>, stateOffset, expect, update)</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同实现类的Sync与State"><a href="#不同实现类的Sync与State" class="headerlink" title="不同实现类的Sync与State"></a>不同实现类的Sync与State</h2><p>基于AQS构建的Synchronizer包括ReentrantLock,Semaphore,CountDownLatch, ReetrantRead WriteLock,FutureTask等，这些Synchronizer实际上最基本的东西就是原子状态的获取和释放，只是条件不一样而已</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>需要记录当前线程获取原子状态的次数，如果次数为零，那么就说明这个线程放弃了锁（也有可能其他线程占据着锁从而需要等待），如果次数大于1，也就是获得了重进入的效果，而其他线程只能被park住，直到这个线程重进入锁次数变成0而释放原子状态。以下为ReetranLock的FairSync的tryAcquire实现代码解析</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公平获取锁</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//如果当前重进入数为0,说明有机会取得锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果是第一个等待者，并且设置重进入数成功，那么当前线程获得锁</span></span><br><span class="line">        <span class="keyword">if</span> (isFirst(current) &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="comment">//如果当前线程本身就持有锁，那么叠加重进入数，并且继续获得锁</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">     <span class="comment">//以上条件都不满足，那么线程进入等待队列。</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>信号量维护了一个许可集，我们在初始化Semaphore时需要为这个许可集传入一个数量值，该数量值代表同一时间能访问共享资源的线程数量。以下为Semaphore的FairSync实现</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> tryAcquireShared(<span class="keyword">int</span> acquires) &#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="built_in">for</span> (;;) &#123;</span><br><span class="line">         Thread first = getFirstQueuedThread();</span><br><span class="line">         <span class="comment">//如果当前等待队列的第一个线程不是当前线程，那么就返回-1表示当前线程需要等待</span></span><br><span class="line">         <span class="built_in">if</span> (first != null &amp;&amp; first != current)</span><br><span class="line">              <span class="built_in">return</span> <span class="number">-1</span>;</span><br><span class="line">         <span class="comment">//如果当前队列没有等待者，或者当前线程就是等待队列第一个等待者，那么先取得semaphore还有几个许可证，并且减去当前线程需要的许可证得到剩下的值</span></span><br><span class="line">         <span class="keyword">int</span> <span class="built_in">available</span> = getState();</span><br><span class="line">         <span class="keyword">int</span> remaining = <span class="built_in">available</span> - acquires;</span><br><span class="line">         <span class="comment">//如果remining&lt;0，那么反馈给AQS当前线程需要等待，如果remaining&gt;0，并且设置availble成功设置成剩余数，那么返回剩余值(&gt;0)，也就告知AQS当前线程拿到许可，可以继续执行。</span></span><br><span class="line">         <span class="built_in">if</span> (remaining &lt; <span class="number">0</span> ||compareAndSetState(<span class="built_in">available</span>, remaining))</span><br><span class="line">             <span class="built_in">return</span> remaining;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>闭锁则要保持其状态，在这个状态到达终止态之前，所有线程都会被park住，闭锁可以设定初始值，这个值的含义就是这个闭锁需要被countDown()几次，因为每次CountDown是sync.releaseShared(1),而一开始初始值为10的话，那么这个闭锁需要被countDown()十次，才能够将这个初始值减到0，从而释放原子状态，让等待的所有线程通过</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//await时候执行，只查看当前需要countDown数量减为0了，如果为0，说明可以继续执行，否则需要park住，等待countDown次数足够，并且unpark所有等待线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> getState() == <span class="number">0</span>? <span class="number">1</span> : -1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//countDown 时候执行，如果当前countDown数量为0，说明没有线程await，直接返回false而不需要唤醒park住线程，如果不为0，得到剩下需要 countDown的数量并且compareAndSet,最终返回剩下的countDown数量是否为0,供AQS判定是否释放所有await线程。</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         <span class="keyword">int</span> c = getState();</span><br><span class="line">         <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">int</span> nextc = c<span class="number">-1</span>;</span><br><span class="line">         <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">             <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>需要记录任务的执行状态，当调用其实例的get方法时,内部类Sync会去调用AQS的acquireSharedInterruptibly()方法，而这个方法会反向调用Sync实现的tryAcquireShared()方法，即让具体实现类决定是否让当前线程继续还是park,而FutureTask的tryAcquireShared方法所做的唯一事情就是检查状态，如果是RUNNING状态那么让当前线程park。而跑任务的线程会在任务结束时调用FutureTask 实例的set方法（与等待线程持相同的实例），设定执行结果，并且通过unpark唤醒正在等待的线程，返回结果</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get时待用，只检查当前任务是否完成或者被Cancel，如果未完成并且没有被cancel，那么告诉AQS当前线程需要进入等待队列并且park住</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> ignore)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> innerIsDone()? <span class="number">1</span> : -1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//判定任务是否完成或者被Cancel</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">innerIsDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ranOrCancelled(getState()) &amp;&amp;    runner == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//get时调用，对于CANCEL与其他异常进行抛错</span></span><br><span class="line"><span class="function">V <span class="title">innerGet</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquireSharedNanos(<span class="number">0</span>,nanosTimeout))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">    <span class="keyword">if</span> (getState() == CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(exception);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//任务的执行线程执行完毕调用（set(V v)）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">innerSet</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = getState();</span><br><span class="line">        <span class="comment">//如果线程任务已经执行完毕，那么直接返回（多线程执行任务？）</span></span><br><span class="line">        <span class="keyword">if</span> (s == RAN)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果被CANCEL了，那么释放等待线程，并且会抛错</span></span><br><span class="line">        <span class="keyword">if</span> (s == CANCELLED) &#123;</span><br><span class="line">            releaseShared(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">        <span class="comment">//如果成功设定任务状态为已完成，那么设定结果，unpark等待线程(调用get()方法而阻塞的线程),以及后续清理工作（一般由FutrueTask的子类实现）</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(s, RAN)) &#123;</span><br><span class="line">            result = v;</span><br><span class="line">            releaseShared(<span class="number">0</span>);</span><br><span class="line">            done();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><p>Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否锁定状态</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试获取资源，立即返回。成功则返回true，否则false。</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// 这里限定只能为1个量</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">//state为0才设置为1，不可重入！</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//设置为当前线程独占资源</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试释放资源，立即返回。成功则为true，否则false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// 限定为1个量</span></span><br><span class="line">    <span class="keyword">if</span> (getState() == <span class="number">0</span>)<span class="comment">//既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(<span class="number">0</span>);<span class="comment">//释放资源，放弃占有状态</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p><a href="https://blog.csdn.net/javazejian/article/details/75043422#aqs%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%A6%82%E8%A6%81" target="_blank" rel="noopener">深入剖析基于并发AQS的(独占锁)重入锁(ReetrantLock)及其Condition实现原理</a><br><a href="https://blog.csdn.net/javazejian/article/details/76167357" target="_blank" rel="noopener">剖析基于并发AQS的共享锁的实现(基于信号量Semaphore)</a><br><a href="https://blog.csdn.net/vernonzheng/article/details/8275624" target="_blank" rel="noopener">Java多线程（七）之同步器基础：AQS框架深入分析</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-jtp04186/" target="_blank" rel="noopener">非阻塞算法简介</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      AQS定义了一套多线程访问共享资源的同步器框架，是整个java.util.concurrent包的基石
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>KMP</title>
    <link href="http://yoursite.com/2018/08/30/KMP/"/>
    <id>http://yoursite.com/2018/08/30/KMP/</id>
    <published>2018-08-29T16:44:12.000Z</published>
    <updated>2018-09-02T14:40:31.120Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h1><p>字符串组成为</p><script type="math/tex; mode=display">p_0...p_k...p_i...p_{i+k}...p_j...p_{j+k}...p_m...p_{m+k}...</script><p>假设\(next_{[i+k]}==next_{[m+k]}\)，表示\(p_0…p_{i+k}=p_j…p_{m+k}\) </p><ul><li>如果\(p_{i+k+1}=p_{m+k+1}\)，则\(next_{[m+k+1]}==next_{[m+k]}+1\) </li><li>如果\(p_{i+k+1}!=p_{m+k+1}\)，有\(next_{[i+k]}=k\)，表示\(p_0…p_{k}=p_i…p_{i+k}=p_m…p_{m+k}\)，<ul><li>如果\(p_{m+k+1}=p_{k+1}\)，则\(next_{[m+k+1]}=next_{[k]}+1\)</li><li>如果\(p_{m+k+1}!=p_{k+1}\)，则有\(next_{[k]}=l\)，继续上面的过程</li></ul></li></ul><p>总结下来，若\(next_{[i]}==next_{[j]}\)</p><ul><li>if \(p_{i+1}=p_{j+1}\), then \(next_{[j+1]}==next_{[j]+1}\)</li><li>else \(i==next_{[i]}\),继续上一步</li></ul><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> KMP &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] getNextArr(<span class="keyword">char</span>[] pattern) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pattern == <span class="keyword">null</span> || pattern.length == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] <span class="keyword">next</span> = <span class="keyword">new</span> <span class="keyword">int</span>[pattern.length];</span><br><span class="line">    <span class="keyword">next</span>[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">next</span>[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> currentNext=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos &lt; pattern.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pattern[pos - <span class="number">1</span>] == pattern[currentNext]) &#123;</span><br><span class="line">        <span class="keyword">next</span>[pos++] = ++currentNext;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentNext &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        currentNext = <span class="keyword">next</span>[currentNext];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">next</span>[pos++] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> getIndexOf(String ori, String pattern) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ori.length() &lt; pattern.length()) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] oriArr = ori.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] patternArr = pattern.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> indexOfOri = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> indexOfPattern = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] <span class="keyword">next</span> = getNextArr(patternArr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (indexOfOri &lt; oriArr.length &amp;&amp; indexOfPattern &lt; patternArr.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oriArr[indexOfOri] == patternArr[indexOfPattern]) &#123;</span><br><span class="line">        indexOfOri++;</span><br><span class="line">        indexOfPattern++;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">next</span>[indexOfPattern] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        indexOfPattern = <span class="keyword">next</span>[indexOfPattern];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        indexOfOri++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> indexOfPattern == patternArr.length ? indexOfOri - indexOfPattern : -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      KMP算法
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串匹配" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>内存屏障</title>
    <link href="http://yoursite.com/2018/08/23/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"/>
    <id>http://yoursite.com/2018/08/23/内存屏障/</id>
    <published>2018-08-23T15:15:18.000Z</published>
    <updated>2018-08-23T17:20:20.571Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="内存屏障的目的"><a href="#内存屏障的目的" class="headerlink" title="内存屏障的目的"></a>内存屏障的目的</h1><p>每个CPU都会有自己的缓存（有的甚至L1,L2,L3），缓存的目的就是为了提高性能，避免每次都要向内存取。但是这样的弊端也很明显：不能实时的和内存发生信息交换，分在不同CPU执行的不同线程对同一个变量的缓存值不同</p><h1 id="内存屏障的作用"><a href="#内存屏障的作用" class="headerlink" title="内存屏障的作用"></a>内存屏障的作用</h1><p>硬件层的内存屏障分为两种：Load Barrier 和 Store Barrier即读屏障和写屏障</p><ul><li>对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据</li><li>对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见</li></ul><p>内存屏障有两个作用</p><ul><li>阻止屏障两侧的指令重排序</li><li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效</li></ul><h1 id="java内存屏障"><a href="#java内存屏障" class="headerlink" title="java内存屏障"></a>java内存屏障</h1><p>内存屏障可以被分为以下几种类型:</p><ul><li><code>LoadLoad屏障</code>：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li><li><code>StoreStore屏障</code>：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li><li><code>LoadStore屏障</code>：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li><li><code>StoreLoad屏障</code>：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</li></ul><h1 id="volatile语义中的内存屏障"><a href="#volatile语义中的内存屏障" class="headerlink" title="volatile语义中的内存屏障"></a>volatile语义中的内存屏障</h1><p>volatile的内存屏障策略非常严格、悲观</p><ul><li>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障</li><li>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障</li></ul><p>volatile重排序规则：</p><ul><li>volatile写与之前的读写不能重排序</li><li>volatile读与之后的读写不能重排序</li><li>相邻的volatile之间不能重排序</li></ul><p><img src="/images/reordering-table.png"></p><p>volatile内存屏障规则：</p><ul><li>volatile写之前，所有的读写都必须已经完成</li><li>volatile读结束后，所有的读写才能开始</li><li>相邻的volatile必须有序实行</li></ul><p><img src="/images/fences-table.png"></p><h1 id="final语义中的内存屏障"><a href="#final语义中的内存屏障" class="headerlink" title="final语义中的内存屏障"></a>final语义中的内存屏障</h1><ul><li><p>新建对象过程中，构造体中对final域的初始化写入和这个对象赋值给其他引用变量，这两个操作不能重排序</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x.<span class="attr">finalField</span> = v; ... ;构建方法边界<span class="attr">sharedRef</span> = x;</span><br><span class="line">v.<span class="attr">afield</span> = <span class="number">1</span>; x.<span class="attr">finalField</span> = v; ... ; 构建方法边界<span class="attr">sharedRef</span> = x;</span><br><span class="line">这两条语句中，构建方法边界前后的指令都不能重排序。</span><br></pre></td></tr></table></figure></li><li><p>初次读包含final域的对象引用和读取这个final域，这两个操作不能重排序</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">x</span> = sharedRef<span class="comment">; ... ; i = x.finalField;</span></span><br></pre></td></tr></table></figure></li><li><p>为了保证final字段的特殊语义，也会在下面的语句加入内存屏障</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.<span class="attr">finalField</span> = v; StoreStore; <span class="attr">sharedRef</span> = x;</span><br></pre></td></tr></table></figure></li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://www.jianshu.com/p/2ab5e3d7e510" target="_blank" rel="noopener">内存屏障</a></li><li><a href="https://www.cnblogs.com/chenyangyao/p/5269622.html" target="_blank" rel="noopener">JVM内存模型、指令重排、内存屏障概念解析</a></li><li><a href="https://blog.csdn.net/coslay/article/details/41955899" target="_blank" rel="noopener">java内存模型 内存屏障</a></li></ul>]]></content>
    
    <summary type="html">
    
      内存屏障原理解析
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java内存模型" scheme="http://yoursite.com/tags/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>volatile</title>
    <link href="http://yoursite.com/2018/08/23/volatile/"/>
    <id>http://yoursite.com/2018/08/23/volatile/</id>
    <published>2018-08-23T12:54:28.000Z</published>
    <updated>2018-08-23T17:20:24.513Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><p>volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值</p><p><code>线程写volatile变量的过程</code></p><ul><li>改变线程工作内存中volatile变量副本的值</li><li>将改变后的副本的值从工作内存刷新到主内存</li></ul><p><code>线程读volatile变量的过程</code></p><ul><li>从主内存中读取volatile变量的最新值到线程的工作内存中</li><li>从工作内存中读取volatile变量的副本</li></ul><h3 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h3><p>多线程版本(错误的)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> Helper helper = <span class="keyword">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Helper <span class="title">getHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (helper == <span class="keyword">null</span>) </span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (helper == <span class="keyword">null</span>) </span><br><span class="line">          helper = <span class="keyword">new</span> Helper();</span><br><span class="line">      &#125;    </span><br><span class="line">    <span class="keyword">return</span> helper;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// other functions and members...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>volatile关键字修改版<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Helper helper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Helper <span class="title">getHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (helper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (helper == <span class="keyword">null</span>)</span><br><span class="line">                    helper = <span class="keyword">new</span> Helper();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在给helper对象初始化的过程中，jvm做了下面3件事:</p><ul><li>给helper对象分配内存</li><li>调用构造函数</li><li>将helper对象指向分配的内存空间</li></ul><p>由于jvm的”优化”,指令2和指令3的执行顺序是不一定的，当执行完指定3后，此时的helper对象就已经不在是null的了,但此时指令2不一定已经被执行。</p><p>假设线程1和线程2同时调用getHelper()方法，此时线程1执行完指令1和指令3，线程2抢到了执行权，此时helper对象是非空的</p><ul><li>volatile关键字可以保证jvm执行的一定的“有序性”，在指令1和指令2执行完之前，指定3一定不会被执行</li><li>volatile变量被修改后立刻刷新会驻内存中</li></ul><h3 id="不保证复合操作的原子性"><a href="#不保证复合操作的原子性" class="headerlink" title="不保证复合操作的原子性"></a>不保证复合操作的原子性</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        final Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        System.<span class="keyword">out</span>.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程A读取最新的值并在工作内存修改后，还未更新到主存就耗尽cpu时间片，等再次获取时间片后主存的变量值已被线程B修改，但线程A并未感知，继续将值更新到主存，导致B的修改无效</p>]]></content>
    
    <summary type="html">
    
      volatile原理解析
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>hexo高级特性</title>
    <link href="http://yoursite.com/2018/08/19/cool/"/>
    <id>http://yoursite.com/2018/08/19/cool/</id>
    <published>2018-08-19T08:35:51.000Z</published>
    <updated>2018-09-08T16:06:53.521Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="网易云"><a href="#网易云" class="headerlink" title="网易云"></a>网易云</h1><h2 id="通过外链添加"><a href="#通过外链添加" class="headerlink" title="通过外链添加"></a>通过外链添加</h2><p>在网易云音乐的网页版生成歌单外链</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe <span class="attribute">frameborder</span>=<span class="string">"no"</span> <span class="attribute">border</span>=<span class="string">"0"</span> <span class="attribute">marginwidth</span>=<span class="string">"0"</span> <span class="attribute">marginheight</span>=<span class="string">"0"</span> <span class="attribute">width</span>=330 <span class="attribute">height</span>=450 <span class="attribute">src</span>=<span class="string">"//music.163.com/outchain/player?type=0&amp;id=2343741251&amp;auto=1&amp;height=430"</span>&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="450" src="//music.163.com/outchain/player?type=0&id=2343741251&auto=1&height=430"></iframe><h2 id="通过aplayer插件"><a href="#通过aplayer插件" class="headerlink" title="通过aplayer插件"></a>通过aplayer插件</h2><p><a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md#meingjs-%E6%94%AF%E6%8C%81-30-%E6%96%B0%E5%8A%9F%E8%83%BD" target="_blank" rel="noopener">MeingJS 支持</a><br>id为网页上url后面的id值<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% meting <span class="string">"468513829"</span> <span class="string">"netease"</span> <span class="string">"song"</span> <span class="string">"autoplay"</span> <span class="string">"mutex: true"</span> <span class="string">"listmaxheight:340px"</span> <span class="string">"preload:none"</span> <span class="string">"theme:#ad7a86"</span>%&#125;</span><br></pre></td></tr></table></figure></p>    <div id="aplayer-KUTfEzES" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="468513829" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="none" data-theme="#ad7a86"></div><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% meting <span class="string">"384485381"</span> <span class="string">"netease"</span> <span class="string">"playlist"</span> <span class="string">"autoplay"</span> <span class="string">"mutex: true"</span> <span class="string">"listmaxheight:340px"</span> <span class="string">"preload:none"</span> <span class="string">"theme:#ad7a86"</span>%&#125;</span><br></pre></td></tr></table></figure>    <div id="aplayer-JwqvVZYT" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="2384642500" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="340px" data-preload="none" data-theme="#ad7a86"></div><h2 id="行间公式"><a href="#行间公式" class="headerlink" title="行间公式"></a>行间公式</h2><script type="math/tex; mode=display">f(n)=\begin{cases}n/2, & \text{如果$ x<=2 $}\\3n+1, & \text{如果$ x>2 $}\end{cases}</script><h2 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h2><p>比如 \(x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}\)</p>]]></content>
    
    <summary type="html">
    
      测试hexo系统新特性
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="新特性" scheme="http://yoursite.com/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>mysql</title>
    <link href="http://yoursite.com/2018/08/19/mysql/"/>
    <id>http://yoursite.com/2018/08/19/mysql/</id>
    <published>2018-08-19T05:47:35.000Z</published>
    <updated>2018-08-19T05:55:49.435Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="mysql体系结构"><a href="#mysql体系结构" class="headerlink" title="mysql体系结构"></a>mysql体系结构</h2><p><img src="/images/mysql-server.jpg"></p><p><a href="https://www.cnblogs.com/Survivalist/p/7954977.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><div class="table-container"><table><thead><tr><th style="text-align:center">特点</th><th style="text-align:center">MyISAM</th><th style="text-align:center">BDB</th><th style="text-align:center">Memory</th><th style="text-align:center">InnoDB</th><th style="text-align:center">Archive</th></tr></thead><tbody><tr><td style="text-align:center">存储限制</td><td style="text-align:center">没有</td><td style="text-align:center">没有</td><td style="text-align:center">有</td><td style="text-align:center">64TB</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center">事务安全</td><td style="text-align:center"></td><td style="text-align:center">支持</td><td style="text-align:center"></td><td style="text-align:center">支持</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">锁机制</td><td style="text-align:center">表锁</td><td style="text-align:center">页锁</td><td style="text-align:center">表锁</td><td style="text-align:center">行锁</td><td style="text-align:center">行锁</td></tr><tr><td style="text-align:center">B数索引</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">哈希索引</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">全文索引</td><td style="text-align:center">支持</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">集群索引</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">支持</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">数据缓存</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">索引缓存</td><td style="text-align:center">支持</td><td style="text-align:center"></td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">数据可压缩</td><td style="text-align:center">支持</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">空间使用</td><td style="text-align:center">低</td><td style="text-align:center">低</td><td style="text-align:center">N/A</td><td style="text-align:center">高</td><td style="text-align:center">非常低</td></tr><tr><td style="text-align:center">内存使用</td><td style="text-align:center">低</td><td style="text-align:center">低</td><td style="text-align:center">中等</td><td style="text-align:center">高</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">批量插入的速度</td><td style="text-align:center">高</td><td style="text-align:center">高</td><td style="text-align:center">高</td><td style="text-align:center">低</td><td style="text-align:center">非常高</td></tr><tr><td style="text-align:center">支持外键</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">支持</td></tr></tbody></table></div><p><a href="https://blog.csdn.net/len9596/article/details/80206532" target="_blank" rel="noopener">InnoDB与MyISAM原理比较</a></p><p><a href="https://www.cnblogs.com/wangdake-qq/p/7358322.html" target="_blank" rel="noopener">InnoDB与MyISAM索引比较</a></p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h2><h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h3><p><a href="https://blog.csdn.net/mine_song/article/details/63251546" target="_blank" rel="noopener">参考链接</a><br>B树中关键字集合分布在整棵树中，叶节点中不包含任何关键字信息，而B+树关键字集合分布在叶子结点中，非叶节点只是叶子结点中关键字的索引</p><h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><p><a href="https://www.cnblogs.com/heiming/p/5865101.html" target="_blank" rel="noopener">B Tree索引和哈希索引的区别</a></p><p>缺点<br>不支持范围查询和排序、最左匹配规则</p><h3 id="空间-R-Tree-索引"><a href="#空间-R-Tree-索引" class="headerlink" title="空间(R-Tree)索引"></a>空间(R-Tree)索引</h3><p><img src="/images/RTree.jpg"></p><p><a href="https://blog.csdn.net/MongChia1993/article/details/69941783#toc_16" target="_blank" rel="noopener">参考链接</a></p><h3 id="全文-Full-text-索引"><a href="#全文-Full-text-索引" class="headerlink" title="全文(Full-text)索引"></a>全文(Full-text)索引</h3><p>类似es搜索的Lucene分词策略</p><p><a href="https://www.cnblogs.com/itxiongwei/p/7064252.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="索引策略"><a href="#索引策略" class="headerlink" title="索引策略"></a>索引策略</h2><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p><a href="https://blog.csdn.net/john1337/article/details/71081827" target="_blank" rel="noopener">高性能mysql章节</a></p><p>概念<br>使用该列开始的部分长度字符串作</p><p>注意<br>选择足够长的前缀以保证较高的选择性，同时又不能太长以便节约空间</p><p>缺点<br>mysql无法使用其前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描</p><h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p><a href="https://www.cnblogs.com/codeAB/p/6387148.html" target="_blank" rel="noopener">mysql多列索引的生效规则</a></p><h3 id="聚簇索引-Clustered-Indexes-及二级索引-辅助索引"><a href="#聚簇索引-Clustered-Indexes-及二级索引-辅助索引" class="headerlink" title="聚簇索引(Clustered Indexes)及二级索引(辅助索引)"></a>聚簇索引(Clustered Indexes)及二级索引(辅助索引)</h3><p><a href="https://www.linuxidc.com/Linux/2018-02/150809.htm" target="_blank" rel="noopener">高性能mysql章节</a></p><p><a href="https://blog.csdn.net/mine_song/article/details/63251546" target="_blank" rel="noopener">InnoDB与MyISAM的主键索引和二级索引的区别</a></p><ul><li><p>聚集索引<br>表数据按照索引的顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序一致。对于聚集索引，叶子结点即存储了真实的数据行，不再有另外单独的数据页。 在一张表上最多只能创建一个聚集索引，因为真实数据的物理顺序只能有一种</p></li><li><p>非聚集索引<br>表数据存储顺序与索引顺序无关。对于非聚集索引，叶结点包含索引字段值及指向数据页数据行的逻辑指针，其行数量与数据表行数据量一致</p></li></ul><h3 id="覆盖索引-Covering-Indexes"><a href="#覆盖索引-Covering-Indexes" class="headerlink" title="覆盖索引(Covering Indexes)"></a>覆盖索引(Covering Indexes)</h3><p>建立索引的字段正好是覆盖查询语句[select子句]与查询条件[Where子句]中所涉及的字段,数据列只用从索引中就能够取得，不必从数据表中读取<br>参考&lt;&lt;高性能mysql&gt;&gt;</p><p><a href="https://www.cnblogs.com/happyflyingpig/p/7662881.html" target="_blank" rel="noopener">参考链接</a><br><a href="https://www.cnblogs.com/Profound/p/8763022.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="压缩-前缀压缩-索引"><a href="#压缩-前缀压缩-索引" class="headerlink" title="压缩(前缀压缩)索引"></a>压缩(前缀压缩)索引</h3><p><a href="https://blog.csdn.net/yirentianran/article/details/79423908" target="_blank" rel="noopener">参考链接</a></p><h3 id="重复索引"><a href="#重复索引" class="headerlink" title="重复索引"></a>重复索引</h3><p>相同列上按照相同的顺序创建的相同类型的索引    </p><h3 id="冗余索引"><a href="#冗余索引" class="headerlink" title="冗余索引"></a>冗余索引</h3><p>若存在索引(a,b),则(a)是冗余,因为a是前缀,(a,b)可以当成(a)使用;（b,a）和(b)不是冗余索引</p><h3 id="分形树-fractal-treeindex-索引"><a href="#分形树-fractal-treeindex-索引" class="headerlink" title="分形树(fractal treeindex)索引"></a>分形树(fractal treeindex)索引</h3><h3 id="块级别元数据"><a href="#块级别元数据" class="headerlink" title="块级别元数据"></a>块级别元数据</h3><p><img src="/images/ib.png"></p><p><a href="https://blog.csdn.net/hguisu/article/details/11848411" target="_blank" rel="noopener">Infobright高性能数据仓库</a></p><h1 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h1><h2 id="explain关键字"><a href="#explain关键字" class="headerlink" title="explain关键字"></a>explain关键字</h2><p><a href="https://www.cnblogs.com/butterfly100/archive/2018/01/15/8287569.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="查询路径"><a href="#查询路径" class="headerlink" title="查询路径"></a>查询路径</h2><p><img src="/images/mysql-query.png"></p><p><a href="https://www.cnblogs.com/yuyue2014/p/3826941.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p><a href="https://www.cnblogs.com/shengdimaya/p/7123069.html" target="_blank" rel="noopener">join原理</a></p><p>JOIN算法</p><ul><li>Nested-Loop Join<ul><li>Simple Nested-Loop Join</li><li>Index Nested-Loop Join</li><li>Block Nested-Loop Join    </li></ul></li><li>哈希关联</li><li>合并连接</li></ul><h1 id="mysql高级特性"><a href="#mysql高级特性" class="headerlink" title="mysql高级特性"></a>mysql高级特性</h1><h2 id="分库、分区、分表、分片"><a href="#分库、分区、分表、分片" class="headerlink" title="分库、分区、分表、分片"></a>分库、分区、分表、分片</h2><p><a href="http://langonggong.com/2018/07/14/mysql%E5%88%86%E5%BA%93-%E5%88%86%E5%8C%BA-%E5%88%86%E8%A1%A8-%E5%88%86%E7%89%87/" target="_blank" rel="noopener">参考链接</a></p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h2 id="内部存储代码"><a href="#内部存储代码" class="headerlink" title="内部存储代码"></a>内部存储代码</h2><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><h3 id="绑定变量"><a href="#绑定变量" class="headerlink" title="绑定变量"></a>绑定变量</h3><h3 id="XA"><a href="#XA" class="headerlink" title="XA"></a>XA</h3><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><h1 id="mvcc与锁"><a href="#mvcc与锁" class="headerlink" title="mvcc与锁"></a>mvcc与锁</h1><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p><a href="https://www.cnblogs.com/chenpingzhao/p/5065316.html" target="_blank" rel="noopener">原理</a></p><h3 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h3><h3 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h3><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><h3 id="Read-Uncommited"><a href="#Read-Uncommited" class="headerlink" title="Read Uncommited"></a>Read Uncommited</h3><h3 id="Read-Committed-RC"><a href="#Read-Committed-RC" class="headerlink" title="Read Committed (RC)"></a>Read Committed (RC)</h3><h3 id="Repeatable-Read-RR"><a href="#Repeatable-Read-RR" class="headerlink" title="Repeatable Read (RR)"></a>Repeatable Read (RR)</h3><h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><h2 id="InnoDB两种类型的行锁"><a href="#InnoDB两种类型的行锁" class="headerlink" title="InnoDB两种类型的行锁"></a>InnoDB两种类型的行锁</h2><h3 id="共享锁（S）—读锁"><a href="#共享锁（S）—读锁" class="headerlink" title="共享锁（S）—读锁"></a>共享锁（S）—读锁</h3><h3 id="排他锁（X）—写锁"><a href="#排他锁（X）—写锁" class="headerlink" title="排他锁（X）—写锁"></a>排他锁（X）—写锁</h3><h2 id="行锁的三种情形"><a href="#行锁的三种情形" class="headerlink" title="行锁的三种情形"></a>行锁的三种情形</h2><h3 id="Record-lock"><a href="#Record-lock" class="headerlink" title="Record lock"></a>Record lock</h3><h3 id="Gap-lock"><a href="#Gap-lock" class="headerlink" title="Gap lock"></a>Gap lock</h3><h3 id="Next-key-Lock"><a href="#Next-key-Lock" class="headerlink" title="Next-key Lock"></a>Next-key Lock</h3><h2 id="InnoDB表锁"><a href="#InnoDB表锁" class="headerlink" title="InnoDB表锁"></a>InnoDB表锁</h2><h3 id="意向共享锁（IS）"><a href="#意向共享锁（IS）" class="headerlink" title="意向共享锁（IS）"></a>意向共享锁（IS）</h3><h3 id="意向排他锁（IX）"><a href="#意向排他锁（IX）" class="headerlink" title="意向排他锁（IX）"></a>意向排他锁（IX）</h3><h2 id="InnoDB页面锁"><a href="#InnoDB页面锁" class="headerlink" title="InnoDB页面锁"></a>InnoDB页面锁</h2>]]></content>
    
    <summary type="html">
    
      《高性能mysql》读书笔记
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="DB" scheme="http://yoursite.com/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>spring cloud</title>
    <link href="http://yoursite.com/2018/08/19/springcloud/"/>
    <id>http://yoursite.com/2018/08/19/springcloud/</id>
    <published>2018-08-19T05:12:12.000Z</published>
    <updated>2018-08-19T05:46:13.326Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p><img src="/images/spring-cloud-architecture.png"></p><h2 id="四大神器"><a href="#四大神器" class="headerlink" title="四大神器"></a>四大神器</h2><ul><li>auto-configuration</li><li>starters<br>  <img src="/images/spring-cloud-stater.png"></li><li>cli：Spring Boot Commad Line    </li><li>Autuator监控</li></ul><h1 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h1><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p><img src="/images/aws-eureka.png"></p><p><a href="https://luyiisme.github.io/2017/04/22/spring-cloud-service-discovery-products/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">参考链接</a></p><div class="table-container"><table><thead><tr><th style="text-align:center">Feature</th><th style="text-align:center">Consul</th><th style="text-align:center">zookeeper</th><th style="text-align:center">etcd</th><th style="text-align:center">Eureka</th></tr></thead><tbody><tr><td style="text-align:center">服务健康检查</td><td style="text-align:center">服务状态，内存，硬盘等</td><td style="text-align:center">(弱)长连接，keepalive</td><td style="text-align:center">连接心跳</td><td style="text-align:center">可配支持</td></tr><tr><td style="text-align:center">多数据中心</td><td style="text-align:center">支持</td><td style="text-align:center">—</td><td style="text-align:center">—</td><td style="text-align:center">—</td></tr><tr><td style="text-align:center">kv存储服务</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">—</td></tr><tr><td style="text-align:center">一致性</td><td style="text-align:center">raft</td><td style="text-align:center">paxos</td><td style="text-align:center">raft</td><td style="text-align:center">—</td></tr><tr><td style="text-align:center">cap</td><td style="text-align:center">ca</td><td style="text-align:center">cp</td><td style="text-align:center">cp</td><td style="text-align:center">ap</td></tr><tr><td style="text-align:center">使用接口(多语言能力)</td><td style="text-align:center">支持http和dns</td><td style="text-align:center">客户端</td><td style="text-align:center">http/grpc</td><td style="text-align:center">http（sidecar）</td></tr><tr><td style="text-align:center">watch支持</td><td style="text-align:center">全量/支持long polling    支持</td><td style="text-align:center">支持</td><td style="text-align:center">long polling</td><td style="text-align:center">支持 long polling/大部分增量</td></tr><tr><td style="text-align:center">自身监控</td><td style="text-align:center">metrics</td><td style="text-align:center">—</td><td style="text-align:center">metrics</td><td style="text-align:center">metrics</td></tr><tr><td style="text-align:center">安全</td><td style="text-align:center">acl /https</td><td style="text-align:center">acl    https支持（弱）</td><td style="text-align:center">—</td></tr><tr><td style="text-align:center">spring cloud集成</td><td style="text-align:center">已支持</td><td style="text-align:center">已支持</td><td style="text-align:center">已支持</td><td style="text-align:center">已支持</td></tr></tbody></table></div><h2 id="CAP理论与BASE思想"><a href="#CAP理论与BASE思想" class="headerlink" title="CAP理论与BASE思想"></a>CAP理论与BASE思想</h2><h2 id="服务发现的方式"><a href="#服务发现的方式" class="headerlink" title="服务发现的方式"></a>服务发现的方式</h2><ul><li>客户端发现<br><img src="/images/client-find.png"></li><li>服务器端发现<br><img src="/images/server-find.png"></li></ul><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><h2 id="LB方案"><a href="#LB方案" class="headerlink" title="LB方案"></a>LB方案</h2><p><a href="https://www.cnblogs.com/mindwind/p/5339657.html" target="_blank" rel="noopener">参考链接1</a></p><p><a href="https://www.cnblogs.com/LittleHann/p/3963255.html" target="_blank" rel="noopener">参考链接2</a></p><p><img src="/images/lb-whole.jpg"></p><ul><li>硬负载</li><li>软负载</li><li>DNS负载</li><li>CDN负载</li></ul><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p><strong>核心组件</strong></p><ul><li>ServerList<br>  用于获取地址列表。它既可以是静态的(提供一组固定的地址)，也可以是动态的(从注册中心中定期查询地址列表)    </li><li>ServerListFilter<br>  仅当使用动态ServerList时使用，用于在原始的服务列表中使用一定策略过虑掉一部分地址    </li><li>IRule<br>  选择一个最终的服务地址作为LB结果。选择策略有轮询、根据响应时间加权、断路器(当Hystrix可用时)等    </li></ul><h1 id="rest调用"><a href="#rest调用" class="headerlink" title="rest调用"></a>rest调用</h1><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><h1 id="容错处理"><a href="#容错处理" class="headerlink" title="容错处理"></a>容错处理</h1><p><a href="http://blog.51cto.com/developerycj/1950881" target="_blank" rel="noopener">参考链接1</a><br><a href="https://www.cnblogs.com/leeSmall/p/8847652.html" target="_blank" rel="noopener">参考链接2</a></p><h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><ul><li>限流</li><li>降级</li><li>熔断</li></ul><h2 id="Dashboard-服务监控"><a href="#Dashboard-服务监控" class="headerlink" title="Dashboard 服务监控"></a>Dashboard 服务监控</h2><h2 id="Turbine-聚合监控"><a href="#Turbine-聚合监控" class="headerlink" title="Turbine 聚合监控"></a>Turbine 聚合监控</h2><h1 id="微服务网关"><a href="#微服务网关" class="headerlink" title="微服务网关"></a>微服务网关</h1><h2 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h2><h3 id="过滤器机制"><a href="#过滤器机制" class="headerlink" title="过滤器机制"></a>过滤器机制</h3><p><img src="/images/zuul-filter.png"></p><h3 id="标准过滤器类型"><a href="#标准过滤器类型" class="headerlink" title="标准过滤器类型"></a>标准过滤器类型</h3><ul><li>PRE<ul><li>鉴权</li><li>流量转发</li></ul></li><li>ROUTING</li><li>POST<ul><li>跨域</li><li>统计</li></ul></li><li>ERROR</li></ul><h3 id="request生命周期"><a href="#request生命周期" class="headerlink" title="request生命周期"></a>request生命周期</h3><p><img src="/images/zuul-filter-lifecyle.png"></p><p><a href="http://www.scienjus.com/api-gateway-and-netflix-zuul/#Netflix-Zuul" target="_blank" rel="noopener">参考链接1</a></p><p><a href="https://www.cnblogs.com/lexiaofei/p/7080257.html" target="_blank" rel="noopener">参考链接2</a></p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><ul><li>隔离机制</li><li>重试机制</li></ul><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul><li>验证与安全保障</li><li>审查与监控</li><li>动态路由</li><li>压力测试</li><li>负载分配</li><li>静态响应处理</li><li>多区域弹性</li></ul><h1 id="微服务配置"><a href="#微服务配置" class="headerlink" title="微服务配置"></a>微服务配置</h1><h2 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h2><p><img src="/images/spring-cloud-config.png"></p><h2 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h2><p><img src="/images/configbus2.jpg"></p><p><a href="https://www.cnblogs.com/ityouknow/p/6931958.html" target="_blank" rel="noopener">参考链接</a></p><ul><li>提交代码触发post请求给bus/refresh</li><li>server端接收到请求并发送给Spring Cloud Bus</li><li>Spring Cloud bus接到消息并通知给其它客户端</li><li>其它客户端接收到通知，请求Server端获取最新配置</li><li>全部客户端均获取到最新的配置</li></ul><h1 id="微服务跟踪"><a href="#微服务跟踪" class="headerlink" title="微服务跟踪"></a>微服务跟踪</h1><h2 id="Spring-Cloud-Sleuth"><a href="#Spring-Cloud-Sleuth" class="headerlink" title="Spring Cloud Sleuth"></a>Spring Cloud Sleuth</h2><h2 id="ZipKin"><a href="#ZipKin" class="headerlink" title="ZipKin"></a>ZipKin</h2><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2>]]></content>
    
    <summary type="html">
    
      微服务概念学习
    
    </summary>
    
      <category term="spring" scheme="http://yoursite.com/categories/spring/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="spring cloud" scheme="http://yoursite.com/tags/spring-cloud/"/>
    
      <category term="网关" scheme="http://yoursite.com/tags/%E7%BD%91%E5%85%B3/"/>
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>java-concurrency</title>
    <link href="http://yoursite.com/2018/08/19/java-concurrency/"/>
    <id>http://yoursite.com/2018/08/19/java-concurrency/</id>
    <published>2018-08-19T04:48:15.000Z</published>
    <updated>2018-08-19T05:07:22.078Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="concurrent包"><a href="#concurrent包" class="headerlink" title="concurrent包"></a>concurrent包</h1><p><img src="/images/concurrent-package.png"></p><h2 id="locks-锁"><a href="#locks-锁" class="headerlink" title="locks(锁)"></a>locks(锁)</h2><p><img src="/images/locks.png"></p><h3 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h3><p><a href="http://www.importnew.com/19472.html" target="_blank" rel="noopener">锁分类1</a><br><a href="https://www.cnblogs.com/qifengshi/p/6831055.html" target="_blank" rel="noopener">锁分类2</a></p><ul><li>公平锁/非公平锁</li><li>可重入锁</li><li>可中断锁</li><li>独享锁/共享锁</li><li>互斥锁/读写锁</li><li>乐观锁/悲观锁</li><li>分段锁</li><li>偏向锁/轻量级锁/重量级锁</li><li>自旋锁</li></ul><h3 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h3><p><a href="https://my.oschina.net/hosee/blog/615865" target="_blank" rel="noopener">锁的优化</a></p><ul><li>减少锁持有时间</li><li>减小锁粒度</li><li>锁分离</li><li>锁粗化</li><li>锁消除</li></ul><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>参考链接<br><a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">参考1</a><br><a href="https://segmentfault.com/a/1190000008471362" target="_blank" rel="noopener">参考2</a><br><a href="https://blog.csdn.net/javazejian/article/details/75043422" target="_blank" rel="noopener">AQS、ReetrantLock、Condition实现原理</a></p><p>重要方法:        </p><ul><li>isHeldExclusively()</li><li>tryAcquire(int)</li><li>tryRelease(int)</li><li>tryAcquireShared(int)</li><li>tryReleaseShared(int)</li></ul><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>参考链接<br><a href="https://www.cnblogs.com/aishangJava/p/6555291.html" target="_blank" rel="noopener">参考1</a><br><a href="https://www.cnblogs.com/dolphin0520/p/3923167.html" target="_blank" rel="noopener">参考2</a></p><p>重要方法</p><ul><li>lock()</li><li>lockInterruptibly() throws InterruptedException</li><li>tryLock()</li><li>tryLock(long time, TimeUnit unit) throws InterruptedException</li><li>unlock()</li><li>Condition newCondition()</li></ul><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p><img src="/images/ReentrantLock.gif"></p><p>参考链接<br>    <a href="https://www.cnblogs.com/onlywujun/articles/3531568.html" target="_blank" rel="noopener">参考1</a></p><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p><img src="/images/ReentrantReadWriteLock.jpg"></p><p>参考链接<br><a href="https://www.cnblogs.com/skywang12345/p/3505809.html" target="_blank" rel="noopener">参考1</a><br><a href="https://www.cnblogs.com/grefr/p/6094922.html" target="_blank" rel="noopener">参考2</a></p><h3 id="condition"><a href="#condition" class="headerlink" title="condition"></a>condition</h3><p><a href="https://blog.csdn.net/bohu83/article/details/51098106" target="_blank" rel="noopener">参考链接</a></p><p><a href="https://www.cnblogs.com/Ming8006/p/7243858.html" target="_blank" rel="noopener">生产者、消费者三种实现</a></p><h2 id="atomic-原子变量"><a href="#atomic-原子变量" class="headerlink" title="atomic(原子变量)"></a>atomic(原子变量)</h2><ul><li>AtomicInteger</li><li>AtomicLong</li><li>AtomicBoolean</li><li>AtomicReference</li><li>AtomicIntegerArray/AtomicLongArray/AtomicReferenceArray</li></ul><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h2 id="executor-线程池"><a href="#executor-线程池" class="headerlink" title="executor(线程池)"></a>executor(线程池)</h2><h3 id="框架类图"><a href="#框架类图" class="headerlink" title="框架类图"></a>框架类图</h3><p><img src="/images/Executor.png"></p><ul><li><p><strong>ThreadPoolExecutor</strong></p><p>  <a href="https://blog.csdn.net/qq_25806863/article/details/71126867" target="_blank" rel="noopener">构造方法和规则</a></p><p>  <a href="http://www.cnblogs.com/trust-freedom/p/6681948.html" target="_blank" rel="noopener">执行原理</a></p><p>  <a href="http://www.cnblogs.com/trust-freedom/p/6693601.html" target="_blank" rel="noopener">线程池终止</a></p><p>  关键参数</p><ul><li>workQueue(排队策略)</li><li>threadFactory</li><li><p>RejectedExecutionHandler(饱和策略)</p><p>常用方法</p></li></ul></li><li><p><strong>Executors</strong></p><p>  创建线程池</p><ul><li>newFixedThreadPool</li><li>newCachedThreadPool</li><li>newSingleThreadExecutor</li><li>newScheduledThreadPool</li></ul></li></ul><h2 id="collections-并发容器"><a href="#collections-并发容器" class="headerlink" title="collections(并发容器)"></a>collections(并发容器)</h2><h3 id="List和Set"><a href="#List和Set" class="headerlink" title="List和Set"></a>List和Set</h3><p><img src="/images/list&set.jpg"></p><ul><li><p>CopyOnWriteArrayList    </p><p>  <a href="http://www.cnblogs.com/skywang12345/p/3498483.html" target="_blank" rel="noopener">参考1</a></p></li><li><p>CopyOnWriteArraySet</p><p>  <a href="http://www.cnblogs.com/skywang12345/p/3498497.html" target="_blank" rel="noopener">参考1</a></p></li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><img src="/images/map.jpg"></p><ul><li><p>ConcurrentHashMap</p><p>  <a href="http://www.cnblogs.com/skywang12345/p/3498537.html" target="_blank" rel="noopener">参考</a></p></li><li><p>ConcurrentSkipListMap</p><p>  <a href="http://www.cnblogs.com/skywang12345/p/3498556.html" target="_blank" rel="noopener">参考</a></p></li><li><p>ConcurrentSkipListSet</p></li></ul><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p><img src="/images/queue.jpg"></p><ul><li><p>ArrayBlockingQueue</p>  <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure><p>  notEmpty和notFull是锁的两个Condition条件<br>  <a href="https://blog.csdn.net/javazejian/article/details/77410889" target="_blank" rel="noopener">实现原理</a></p></li><li><p>LinkedBlockingQueue</p></li><li>LinkedBlockingDeque</li><li>ConcurrentLinkedQueue</li><li>ConcurrentLinkedDeque</li></ul><h2 id="tools-同步工具"><a href="#tools-同步工具" class="headerlink" title="tools(同步工具)"></a>tools(同步工具)</h2><ul><li>CountDownLatch</li><li>CyclicBarrier</li><li>Semaphore</li></ul><h1 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h1><p><a href="https://blog.csdn.net/javazejian/article/details/72772461" target="_blank" rel="noopener">java内存模型</a><br><a href="https://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="noopener">synchronized原理</a></p><h2 id="内存模型概述"><a href="#内存模型概述" class="headerlink" title="内存模型概述"></a>内存模型概述</h2><p><img src="/images/jmm-summary.png"></p><ul><li>主内存</li><li>工作内存</li></ul><h2 id="Java内存模型与硬件内存架构的关系"><a href="#Java内存模型与硬件内存架构的关系" class="headerlink" title="Java内存模型与硬件内存架构的关系"></a>Java内存模型与硬件内存架构的关系</h2><p><img src="/images/jmm-hardware.png"></p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>原子性</li><li>可见性</li><li>有序性</li></ul><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><ul><li>指令重排</li><li>编译器重排</li></ul><h2 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h2><h2 id="happens-before-原则"><a href="#happens-before-原则" class="headerlink" title="happens-before 原则"></a>happens-before 原则</h2><ul><li>程序顺序原则</li><li>锁规则</li><li>volatile规则</li><li>线程启动规则</li><li>传递性</li><li>线程终止规则</li><li>线程中断规则</li><li>对象终结规则</li></ul><h2 id="volatile内存语义"><a href="#volatile内存语义" class="headerlink" title="volatile内存语义"></a>volatile内存语义</h2><ul><li>可见性</li><li>禁止重排优化</li></ul><h2 id="内存屏障（Memory-Barrier）"><a href="#内存屏障（Memory-Barrier）" class="headerlink" title="内存屏障（Memory Barrier）"></a>内存屏障（Memory Barrier）</h2><p><a href="http://ifeve.com/jmm-cookbook-mb/" target="_blank" rel="noopener">参考链接</a></p><ul><li>LoadLoad Barriers</li><li>StoreStore  Barriers</li><li>LoadStore Barriers</li><li>StoreLoad Barriers</li></ul>]]></content>
    
    <summary type="html">
    
      Java Concurrency in Practice读书笔记
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>

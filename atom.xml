<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>武汉旭神</title>
  
  <subtitle>路漫漫其修远兮，吾将上下而求索</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://langonggong.com/"/>
  <updated>2021-02-21T15:51:40.864Z</updated>
  <id>http://langonggong.com/</id>
  
  <author>
    <name>lanxu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hive学习</title>
    <link href="http://langonggong.com/2021/02/03/hive%E5%AD%A6%E4%B9%A0/"/>
    <id>http://langonggong.com/2021/02/03/hive学习/</id>
    <published>2021-02-02T16:53:41.000Z</published>
    <updated>2021-02-21T15:51:40.864Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>hive是facebook开源，并捐献给了apache组织，作为apache组织的顶级项目(hive.apache.org)。 hive是一个基于大数据技术的数据仓库(DataWareHouse)技术，主要是通过将用户书写的SQL语句翻译成MapReduce代码，然后发布任务给MR框架执行，完成SQL 到 MapReduce的转换。可以将结构化的数据文件映射为一张数据库表，并提供类SQL查询功能。</p><h2 id="为什么使用Hive"><a href="#为什么使用Hive" class="headerlink" title="为什么使用Hive"></a>为什么使用Hive</h2><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p><strong>直接使用hadoop所面临的问题</strong></p><ul><li>人员学习成本太高</li><li>项目周期要求太短</li><li>MapReduce实现复杂查询逻辑开发难度太大</li></ul><p><strong>优点</strong></p><ul><li>操作接口采用类SQL语法，提供快速开发的能力。</li><li>避免了去写MapReduce，减少开发人员的学习成本。</li><li>扩展功能很方便。</li></ul><h3 id="Hive的特点"><a href="#Hive的特点" class="headerlink" title="Hive的特点"></a>Hive的特点</h3><ul><li>可扩展<br>  Hive可以自由的扩展集群的规模，一般情况下不需要重启服务。</li><li>延展性<br>  Hive支持用户自定义函数，用户可以根据自己的需求来实现自己的函数。</li><li>容错<br>  良好的容错性，节点出现问题SQL仍可完成执行。</li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="/images/hive-jiagou.png"></p><ul><li>HDFS：用来存储hive仓库的数据文件</li><li>yarn：用来完成hive的HQL转化的MR程序的执行</li><li>MetaStore：保存管理hive维护的元数据</li><li>Hive：用来通过HQL的执行，转化为MapReduce程序的执行，从而对HDFS集群中的数据文件进行统计。</li></ul><p><strong>基本组成</strong></p><ul><li>用户接口：包括 CLI、JDBC/ODBC、WebGUI。</li><li>元数据存储：通常是存储在关系数据库如 mysql , derby中。</li><li>解释器、编译器、优化器、执行器。</li></ul><p><strong>各组件的基本功能</strong></p><ul><li>用户接口主要由三个：CLI、JDBC/ODBC和WebGUI。其中，CLI为shell命令行；JDBC/ODBC是Hive的JAVA实现，与传统数据库JDBC类似；WebGUI是通过浏览器访问Hive。</li><li>元数据存储：Hive 将元数据存储在数据库中。Hive 中的元数据包括表的名字，表的列和分区及其属性，表的属性（是否为外部表等），表的数据所在目录等。</li><li>解释器、编译器、优化器完成 HQL 查询语句从词法分析、语法分析、编译、优化以及查询计划的生成。生成的查询计划存储在 HDFS 中，并在随后有 MapReduce 调用执行。</li></ul><h2 id="读时模式"><a href="#读时模式" class="headerlink" title="读时模式"></a>读时模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一般的schema有两种创建方式，如图所示</p><p><strong>schema on write</strong><br><img src="/images/schema-on-write.png"><br>写时模型，作用于数据源到数据汇聚存储之间，典型使用就是传统数据库，数据在入库的时候需要预先设置schema，简单讲，就是表结构。</p><p><strong>schema on read</strong><br><img src="/images/schema-on-read.png"><br>读时模型，作用于数据汇聚存储到数据分析之间，数据先存储，然后在需要分析的时候再为数据设置schema</p><h3 id="两种模式对比"><a href="#两种模式对比" class="headerlink" title="两种模式对比"></a>两种模式对比</h3><p><strong>业务</strong><br>    数据是具有不同角色和不同业务之间的共享资产，相同的数据会因为业务的不同而获得不同的见解。对于一个成熟的业务，已有模型足够涵盖所有的数据集，变化较少，则可以使用写时模型，提前定义好所有数据模型（数仓作用）；<br>    对于一个新的或者探索性业务，由于业务需求不定，并且变动频繁，因此数据不适合绑定到预定的结构，则可以使用读时模式，快速迭代，尽快交付业务需求</p><p><strong>数据质量</strong><br>    写时模式，会对存储的数据质量进行检查或檫除（ETL），确保数据在某个业务场景下明确定义的、精确的和可信的。<br>    读时模式，因为数据没有受到严格的ETL和数据清理过程,也没有经过任何验证,该数据可能充斥着缺失或无效的数据,重复和一大堆其他问题，可能会导致不准确或    不完整的查询结果。如果在on read的时候进行ETL，由于同样数据不同schema，则会导致重复工作</p><p><strong>效率</strong><br>    写时模式更亲和读效率，因为数据存储在合适的地方，并做了类型安全和清理优化工作，通常更高效。但这是以数据摄入时，繁琐的预处理为代价换来的<br>    相反，读时模式更亲和写效率，数据摄入不需要做其它处理，简单，快捷；但是就会导致on read时，解析和解释数据效率低下</p><p><strong>功能与系统</strong><br>    写时模式更多用于对结构化数据的OLAP与OLTP，对应传统的数据库系统<br>    而读时模式基于非结构化数据，需要存储更多的数据，海量的分析需求，快速的需求响应，与大数据系统不谋而和</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>前面我们分三个部分，分别阐述了数据流程，schema意义，两种模式的定义和对比<br>关键的其实有以下三点：</p><ul><li>schema on read强调灵活自由，schema on write注重稳定和效率，两者对比几乎围绕这几点展开</li><li>schema on read与schema on write不是二者取一，而是相辅相成，互相协助</li><li>schema有其存在的意义，无论是结构化还是非结构数据分析挖掘，schema都是必须的过程</li></ul><h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><h2 id="表类型"><a href="#表类型" class="headerlink" title="表类型"></a>表类型</h2><h3 id="内表与外表"><a href="#内表与外表" class="headerlink" title="内表与外表"></a>内表与外表</h3><ul><li>内表：hive完全控制数据的生命周期。删除内部表，删除表元数据和数据</li><li>外表：只保存schema，不控制数据的生命周期。删除外部表，删除元数据，不删除数据</li></ul><p><strong>使用选择</strong></p><p>大多数情况，他们的区别不明显，如果数据的所有处理都在 Hive 中进行，那么倾向于选择内部表，但是如果 Hive 和其他工具要针对相同的数据集进行处理，外部表更合适。<br>　　使用外部表访问存储在 HDFS 上的初始数据，然后通过 Hive 转换数据并存到内部表中。使用外部表的场景是针对一个数据集有多个不同的 Schema。<br>　　通过外部表和内部表的区别和使用选择的对比可以看出来，hive 其实仅仅只是对存储在HDFS 上的数据提供了一种新的抽象。而不是管理存储在 HDFS 上的数据。所以不管创建内部表还是外部表，都可以对 hive 表的数据存储目录中的数据进行增删操作。</p><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>与传统数据库类似，只读，基于基本表创建</p><p><strong>特点</strong></p><ul><li>视图是一个虚表，一个逻辑概念，可以跨越多张表。表是物理概念，数据放在表中，视图是虚表，操作视图和操作表是一样的，所谓虚，是指视图下不存数据。</li><li>视图是建立在已有表的基础上，视图赖以建立的这些表称为基表</li><li>视图可以简化复杂的查询</li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>Hive的索引其实是一张索引表（Hive的物理表），在表里面存储索引列的值，该值对应的HDFS的文件路径，该值在数据文件中的偏移量。<br>当Hive通过索引列执行查询时，首先通过一个MR Job去查询索引表，根据索引列的过滤条件，查询出该索引列值对应的HDFS文件目录及偏移量，并且把这些数据输出到HDFS的一个文件中，然后再根据这个文件中去筛选原文件，作为查询Job的输入。</p><p><strong>优点</strong></p><ul><li>可以避免全表扫描和资源浪费</li><li>可以加快含有group by的语句的查询速度</li></ul><p><strong>缺点</strong></p><ul><li>使用过程繁琐</li><li>需用额外Job扫描索引表</li><li>不会自动刷新，如果表有数据变动，索引表需要手动刷新</li></ul><h2 id="分区与分桶"><a href="#分区与分桶" class="headerlink" title="分区与分桶"></a>分区与分桶</h2><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p><strong>作用</strong><br>如果一个表中数据很多，查询时就很慢，耗费大量时间，如果要查询其中部分数据，需要引入分区的概念</p><p><strong>原理</strong><br>在Hive中的数据仓库中，也有分区分桶的概念，在逻辑上，分区表与未分区表没有区别，在物理上分区表会将数据按照分区间的列值存储在表目录的子目录中，目录名=“分区键=键值”。其中需要注意的是分区键的列值存储在表目录的子目录中，目录名=“分区键=键值”。其中需要注意的是分区键的值不一定要基于表的某一列（字段），它可以指定任意值，只要查询的时候指定相应的分区键来查询即可。我们可以对分区进行添加、删除、重命名、清空等操作。</p><p>Hive中的分区表分为两种：静态分区和动态分区</p><p><strong>静态分区</strong></p><ul><li>可以根据PARTITIONED BY创建分区表，一个表可以拥有一个或者多个分区，每个分区以文件夹的形式单独存在表文件夹的目录下。</li><li>分区是以字段的形式在表结构中存在，通过describe table命令可以查看到字段存在，但是该字段不存放实际的数据内容，仅仅是分区的表示。</li><li>分区建表分为2种，一种是单分区，也就是说在表文件夹目录下只有一级文件夹目录。另外一种是多分区，表文件夹下出现多文件夹嵌套模式。</li></ul><p><strong>动态分区</strong></p><p>Static Partition (SP) columns 静态分区；<br>Dynamic Partition (DP) columns 动态分区。</p><ul><li>DP列的指定方式与SP列相同 - 在分区子句中（ Partition关键字后面），唯一的区别是，DP列没有值，而SP列有值（ Partition关键字后面只有key没有value）</li><li>在INSERT … SELECT …查询中，必须在SELECT语句中的列中最后指定动态分区列，并按PARTITION（）子句中出现的顺序进行排列</li><li>所有DP列 - 只允许在非严格模式下使用。 在严格模式下，我们应该抛出一个错误</li><li>如果动态分区和静态分区一起使用，必须是动态分区的字段在前，静态分区的字段在后。</li></ul><h3 id="分桶"><a href="#分桶" class="headerlink" title="分桶"></a>分桶</h3><p><strong>原理</strong><br>分桶则是指定分桶表的某一列，让该列数据按照哈希取模的方式随机、均匀的分发到各个桶文件中。因为分桶操作需要根据某一列具体数据来进行哈希取模操作，故指定的分桶列必须基于表中的某一列（字段）。分桶改变了数据的存储方式，它会把哈希取模相同或者在某一个区间的数据行放在同一个桶文件中。</p><p><strong>作用</strong></p><ul><li>提高join查询效率</li></ul><p>获得更高的查询处理效率。桶为表加上了额外的结构，Hive 在处理有些查询时能利用这个结构。具体而言，连接两个在（包含连接列的）相同列上划分了桶的表，可以使用 Map 端连接 （Map-side join）高效的实现。比如JOIN操作。对于JOIN操作两个表有一个相同的列，如果对这两个表都进行了桶操作。那么将保存相同列值的桶进行JOIN操作就可以，可以大大较少JOIN的数据量</p><ul><li>方便抽样</li></ul><p>使取样（sampling）更高效。在处理大规模数据集时，在开发和修改查询的阶段，如果能在数据集的一小部分数据上试运行查询，会带来很多方便</p><h1 id="文件存储格式"><a href="#文件存储格式" class="headerlink" title="文件存储格式"></a>文件存储格式</h1><h2 id="textfile"><a href="#textfile" class="headerlink" title="textfile"></a>textfile</h2><p>默认格式，数据不做压缩，磁盘开销大，数据解析开销大。可结合Gzip、Bzip2使用(系统自动检查，执行查询时自动解压)，但使用这种方式，hive不会对数据进行切分， 从而无法对数据进行并行操作。</p><h2 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h2><p>SequenceFile是Hadoop API提供的一种二进制文件支持，以<key,value>的形式序列化到文件中，其具有使用方便、可分割、可压缩的特点。 SequenceFile支持三种压缩选择：NONE，RECORD，BLOCK。Record压缩率低，一般建议使用BLOCK压缩。</key,value></p><h2 id="ORCFile"><a href="#ORCFile" class="headerlink" title="ORCFile"></a>ORCFile</h2><h3 id="概述历史"><a href="#概述历史" class="headerlink" title="概述历史"></a>概述历史</h3><ul><li>RCFile全称Record Columnar File，列式记录文件，是一种类似于SequenceFile的键值对（Key/Value Pairs）数据文件。</li><li>在当前的基于Hadoop系统的数据仓库中，数据存储格式是影响数据仓库性能的一个重要因素。Facebook于是提出了集行存储和列存储的优点于一身的RCFile文件存储格式。</li><li>为了提高存储空间利用率，Facebook各产品线应用产生的数据从2010年起均采用RCFile结构存储，按行存储（SequenceFile/TextFile）结构保存的数据集也转存为RCFile格式。</li><li>此外，Yahoo公司也在Pig数据分析系统中集成了RCFile，RCFile正在用于另一个基于Hadoop的数据管理系统Howl（<a href="http://wiki.apache.org/pig/Howl）。" target="_blank" rel="noopener">http://wiki.apache.org/pig/Howl）。</a></li><li>而且，根据Hive开发社区的交流，RCFile也成功整合加入其他基于MapReduce的数据分析平台。有理由相信，作为数据存储标准的RCFile，将继续在MapReduce环境下的大规模数据分析中扮演重要角色。</li></ul><h3 id="列式存储"><a href="#列式存储" class="headerlink" title="列式存储"></a>列式存储</h3><p><strong>基于行存储的优点和缺点</strong><br>下图为Hadoop block中的基于行存储的示例图<br><img src="/images/hadoop-row-file.png"></p><ul><li>优点：具备快速数据加载和动态负载的高适应能力，因为行存储保证了相同记录的所有域都在同一个集群节点</li><li>缺点：但是它不太满足快速的查询响应时间的要求，特别是在当查询仅仅针对所有列中的少数几列时，它就不能直接定位到所需列而跳过不需要的列，由于混合着不同数据值的列，行存储不易获得一个极高的压缩比。</li></ul><p><strong>基于列存储的优点和缺点</strong><br>下图为Hadoop block中的基于列存储的示例图<br><img src="/images/hadoop-col-file.png"></p><ul><li>优点：这种结构使得在查询时能够直接读取需要的列而避免不必要列的读取，并且对于相似数据也可以有一个更好的压缩比。</li><li>缺点：它并不能提供基于Hadoop系统的快速查询处理，也不能保证同一记录的所有列都存储在同一集群节点之上，也不适应高度动态的数据负载模式。</li></ul><p>RCFile设计思想<br><img src="/images/rcfile.png"></p><p>RCFile结合列存储和行存储的优缺点，Facebook于是提出了基于行列混合存储的RCFile，该存储结构遵循的是“先水平划分，再垂直划分”的设计理念。先将数据按行水平划分为行组，这样一行的数据就可以保证存储在同一个集群节点；然后在对行进行垂直划分。<br>RCFile是在Hadoop HDFS之上的存储结构，该结构强调： </p><ul><li>RCFile存储的表是水平划分的，分为多个行组，每个行组再被垂直划分，以便每列单独存储； </li><li>RCFile在每个行组中利用一个列维度的数据压缩，并提供一种Lazy解压（decompression）技术来在查询执行时避免不必要的列解压； </li><li>RCFile支持弹性的行组大小，行组大小需要权衡数据压缩性能和查询性能两方面。</li><li>RCFile的每个行组中，元数据头部和表格数据段（每个列被独立压缩）分别进行压缩，RCFile使用重量级的Gzip压缩算法，是为了获得较好的压缩比。另外在由于Lazy压缩策略，当处理一个行组时，RCFile只需要解压使用到的列，因此相对较高的Gzip解压开销可以减少。 </li><li>RCFile具备相当于行存储的数据加载速度和负载适应能力，在读数据时可以在扫描表格时避免不必要的列读取，它比其他结构拥有更好的性能，使用列维度的压缩能够有效提升存储空间利用率。</li></ul><h3 id="读写优化"><a href="#读写优化" class="headerlink" title="读写优化"></a>读写优化</h3><p><strong>数据读取和Lazy解压</strong><br>在MapReduce框架中，mapper将顺序处理HDFS块中的每个行组。当处理一个行组时，RCFile无需全部读取行组的全部内容到内存。相反，它仅仅读元数据头部和给定查询需要的列。因此，它可以跳过不必要的列以获得列存储的I/O优势。(例如，表tbl(c1, c2, c3, c4)有4个列，做一次查询“SELECT c1 FROM tbl WHERE c4 = 1”，对每个行组，RCFile仅仅读取c1和c4列的内容。).在元数据头部和需要的列数据加载到内存中后，它们需要解压。元数据头部总会解压并在内存中维护直到RCFile处理下一个行组。然而，RCFile不会解压所有加载的列，相反，它使用一种Lazy解压技术。</p><p>Lazy解压意味着列将不会在内存解压，直到RCFile决定列中数据真正对查询执行有用。由于查询使用各种WHERE条件，Lazy解压非常有用。如果一个WHERE条件不能被行组中的所有记录满足，那么RCFile将不会解压WHERE条件中不满足的列。例如，在上述查询中，所有行组中的列c4都解压了。然而，对于一个行组，如果列c4中没有值为1的域，那么就无需解压列c1。</p><p><strong>行组大小</strong><br>I/O性能是RCFile关注的重点，因此RCFile需要行组够大并且大小可变。行组大小和下面几个因素相关。</p><ul><li>行组大的话，数据压缩效率会比行组小时更有效。根据对Facebook日常应用的观察，当行组大小达到一个阈值后，增加行组大小并不能进一步增加Gzip算法下的压缩比。</li><li>行组变大能够提升数据压缩效率并减少存储量。因此，如果对缩减存储空间方面有强烈需求，则不建议选择使用小行组。需要注意的是，当行组的大小超过4MB，数据的压缩比将趋于一致。</li><li>尽管行组变大有助于减少表格的存储规模，但是可能会损害数据的读性能，因为这样减少了Lazy解压带来的性能提升。而且行组变大会占用更多的内存，这会影响并发执行的其他MapReduce作业。考虑到存储空间和查询效率两个方面，Facebook选择4MB作为默认的行组大小，当然也允许用户自行选择参数进行配置。</li></ul><h2 id="Parquet"><a href="#Parquet" class="headerlink" title="Parquet"></a>Parquet</h2><h3 id="数据模型-1"><a href="#数据模型-1" class="headerlink" title="数据模型"></a>数据模型</h3><p>每条记录中的字段可以包含三种类型：required, repeated, optional。最终由所有叶子节点来代表整个schema。</p><ul><li>元组的Schema可以转换成树状结构，根节点可以理解为repeated类型</li><li>所有叶子结点都是基本类型</li><li>没有Map、Array这样的复杂数据结构，但是可以通过repeated和group组合来实现这样的需求</li></ul><h3 id="Striping-Assembly算法"><a href="#Striping-Assembly算法" class="headerlink" title="Striping/Assembly算法"></a>Striping/Assembly算法</h3><p>Parquet的一条记录的数据如何分成多少列，又如何组装回来？是由Striping/Assembly算法决定的。</p><p>在该算法中，列的每一个值都包含三个部分：</p><ul><li>value : 字段值</li><li>repetition level : 重复级别</li><li>definition level : 定义级别</li></ul><h4 id="Repetition-Levels"><a href="#Repetition-Levels" class="headerlink" title="Repetition Levels"></a>Repetition Levels</h4><p>repetition level的设计目标是为了支持repeated类型的节点：</p><ul><li>在写入时该值等于它和前面的值从哪一层节点开始是不共享的。</li><li>在读取的时候根据该值可以推导出哪一层上需要创建一个新的节点。</li></ul><p>例子：对于这样的schema和两条记录：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message nested &#123;</span><br><span class="line"> repeated<span class="built_in"> group </span>leve1 &#123;</span><br><span class="line">  repeated string leve2;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r1:<span class="string">[[a,b,c,] , [d,e,f,g]]</span></span><br><span class="line">r2:<span class="string">[[h] , [i,j]]</span></span><br></pre></td></tr></table></figure><p>计算一下各个值的repetition level。<br>repetition level计算过程：</p><ul><li>value=a是一条记录的开始，和前面的值在根结点上是不共享的，因此repetition level=0</li><li>value=b和前面的值共享了level1这个节点，但是在level2这个节点上不共享，因此repetition level=2</li><li>同理，value=c的repetition value=2</li><li>value=d和前面的值共享了根节点，在level1这个节点是不共享的，因此repetition level=1</li><li>同理，value=e,f,g都和自己前面的占共享了level1，没有共享level2，因此repetition level=2</li><li>value=h属于另一条记录，和前面不共享任何节点，因此，repetition level=0</li><li>value=i跟前面的结点共享了根，但是没有共享level1节点，因此repetition level=1</li><li>value-j跟前面的节点共享了level1，但是没有共享level2，因此repetition level=2</li></ul><p>在读取时，会顺序读取每个值，然后根据它的repetition level创建对象</p><ul><li>当读取value=a时，repeatition level=0，表示需要创建一个新的根节点，</li><li>当读取value=b时，repeatition level=2，表示需要创建level2节点</li><li>当读取value=c时，repeatition level=2，表示需要创建level2节点</li><li>当读取value=d时，repeatition level=1，表示需要创建level1节点</li><li>剩下的节点依此类推</li></ul><p>几点规律：</p><ul><li>repetition level=0表示一条记录的开始</li><li>repetition level的值只是针对路径上repeated类型的节点，因此在计算时可以忽略非repeated类型的节点</li><li>在写入的时候将其理解为该节点和路径上的哪一个repeated节点是不共享的</li><li>读取的时候将其理解为需要在哪一层创建一个新的repeated节点</li></ul><h4 id="Definition-Levels"><a href="#Definition-Levels" class="headerlink" title="Definition Levels"></a>Definition Levels</h4><p>有了repetition levle就可以构造出一条记录了，那么为什么还需要definition level呢？</p><p>是因为repeated和optional类型的存在，可以一条记录中的某些列是没有值的，如果不记录这样的值，就会导致本该属于下一条记录的值被当做当前记录中的一部分，从而导致数据错误，因此，对于这种情况，需要一个占位符来表示。</p><p>definition level的值仅对空值是有效的，<strong>表示该值的路径上第几层开始是未定义的</strong>；对于非空值它是没有意义的，因为非空值在叶子节点上是有定义的，所有的父节点也一定是有定义的，因此它的值总是等于该列最大的definition level。<br>例子：对于这样的schema：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">message ExampleDefinitionLevel &#123;</span><br><span class="line"> optional<span class="built_in"> group </span>a &#123;</span><br><span class="line">  optional<span class="built_in"> group </span>b &#123;</span><br><span class="line">   optional string c;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它包含一个列a.b.c，这个列的的每一个节点都是optional类型的，当c被定义时a和b肯定都是已定义的，当c未定义时我们就需要标示出在从哪一层开始时未定义的<br>一条记录的definition level的几种可能的情况如下表：</p><p>| 服务健康检查 | 服务状态，内存，硬盘等 | (弱)长连接，keepalive | 连接心跳 | 可配支持 |</p><div class="table-container"><table><thead><tr><th style="text-align:center">Value</th><th style="text-align:center">Definition Level</th></tr></thead><tbody><tr><td style="text-align:center">a:null</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">a:{b:null}</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">a:{b:{c:null}}</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">a:{b:{c:”foo”}}</td><td style="text-align:center">3(全部定义了)</td></tr></tbody></table></div><p>由于definition level只需要考虑未定义的值，对于required类型的节点，只要父亲节点定义了，该节点就必须定义，因此计算时可以忽略路径上的required类型的节点，这样可以减少definition level的最大值，优化存储。</p><h4 id="一个完整的例子"><a href="#一个完整的例子" class="headerlink" title="一个完整的例子"></a>一个完整的例子</h4><p>下面使用<a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36632.pdf" target="_blank" rel="noopener">Dremel论文</a>中给的Document示例和给定的两个值展示计算repeated level和definition level的过程，这里把未定义的值记录为NULL，使用R表示repeated level，D表示definition level。</p><p>schema及数据示例：</p><p> <img src="/images/parquet-Dremel-paper-re-de-demo.png"><br> schema及levels对应关系：</p><p> <a href="https://github.com/julienledem/redelm/wiki/The-striping-and-assembly-algorithms-from-the-Dremel-paper" target="_blank" rel="noopener">详细求解过程</a></p><p> <img src="/images/parquet-demo-schema-levels.png"></p><ul><li>首先看DocId这一列，r1和r2都只有一值分别是：<ul><li>id1=10,由于它是记录开始，并且是已定义的，因此R=0,D=0</li><li>id2=20,由于是新记录的开始，并且是已经定义的，因此R=0,D=0</li><li>对于Name.Url这一列，r1中它有三个值，r2中有一个值分别是：</li><li>url1=’<a href="http://A’" target="_blank" rel="noopener">http://A’</a> ，它是r1中该列的第一个值，并且是定义的，所以R=0,D=2</li><li>url2=’<a href="http://B’" target="_blank" rel="noopener">http://B’</a> ，它跟上一个值在Name这层是不同的，并且是定义的，所以R=1,D=2</li><li>url3=NULL，它跟上一个值在Name这层是不同的，并且是未定义的，所以R=1,D=1</li><li>url4=’<a href="http://C’" target="_blank" rel="noopener">http://C’</a> ，它跟上一个值属于不同记录，并且是定义的，所以R=0,D=2</li><li>对于Links.Forward这一列，在r1中有三个值，在r2中有1个值，分别是：</li><li>value1=20，它是r1中该列的第一个值，并且是定义的，所以R=0,D=2</li><li>value2=40，它跟上一个值在Links这层是相同的，并且是定义的，所以R=1,D=2</li><li>value3=60，它跟上一个值在Links这层是相同的，并且是定义的，所以R=1,D=2</li><li>value4=80，它是一条新的记录，并且是定义的，所以R=0,D=2</li><li>对于Links.Backward这一列，在r1中有一个空值，在r2中两个值，分别是：</li><li>value1=NULL，它是一条新记录，并且是未定义的，父节点Links是定义的，所以R=0,D=1</li><li>value2=10，是一条新记录，并且是定义的，所以R=0,D=2</li><li>value3=30,跟上个值共享父节点，并且是定义的，所以R=1,D=2</li></ul></li></ul><h4 id="Parquet文件格式"><a href="#Parquet文件格式" class="headerlink" title="Parquet文件格式"></a>Parquet文件格式</h4><p> <img src="/images/parquet-file-struct.png"></p><p> Parquet文件是二进制方式存储的，文件中包含数据和元数据，可以直接进行解析。</p><p>先了解一下关于Parquet文件的几个基本概念：</p><ul><li>行组(Row Group)：每一个行组包含一定的行数，一般对应一个HDFS文件块，Parquet读写的时候会将整个行组缓存在内存中。</li><li>列块(Column Chunk)：在一个行组中每一列保存在一个列块中，一个列块中的值都是相同类型的，不同的列块可能使用不同的算法进行压缩。</li><li>页(Page)：每一个列块划分为多个页，一个页是最小的编码的单位，在同一个列块的不同页可能使用不同的编码方式。</li></ul><p>Parquet文件组成：</p><ul><li>文件开始和结束的4个字节都是Magic Code，用于校验它是否是一个Parquet文件</li><li>结束MagicCode前的Footer length是文件元数据的大小，通过该值和文件长度可以计算出元数据Footer的偏移量</li><li>再往前推是Footer文件的元数据，里面包含：<ul><li>文件级别的信息：版本，Schema，Extra key/value对等</li><li>每个行组的元信息，每个行组是由多个列块组成的：</li><li>每个列块的元信息：类型，路径，编码方式，第1个数据页的位置，第1个索引页的位置，压缩的、未压缩的尺寸，额外的KV</li></ul></li><li>文件中大部分内容是各个行组信息：<ul><li>一个行组由多个列块组成<ul><li>一个列块由多个页组成，在Parquet中有三种页：<ul><li>数据页：一个页由页头、repetition levels\definition levles\valus组成</li><li>字典页：存储该列值的编码字典，每一个列块中最多包含一个字典页</li><li>索引页：用来存储当前行组下该列的索引，目前Parquet中还不支持索引页，但是在后面的版本中增加</li></ul></li></ul></li></ul></li></ul><h4 id="计算时间优化"><a href="#计算时间优化" class="headerlink" title="计算时间优化"></a>计算时间优化</h4><p>Parquet的最大价值在于，它提供了一中把IO奉献给查询需要用到的数据。主要的优化有两种：</p><ul><li>映射下推(Project PushDown)</li><li>谓词下推(Predicate PushDown)</li></ul><p><strong>映射下推</strong><br>列式存储的最大优势是映射下推，它意味着在获取表中原始数据时只需要扫描查询中需要的列。</p><p>Parquet中原生就支持映射下推，执行查询的时候可以通过Configuration传递需要读取的列的信息，在扫描一个行组时，只扫描对应的列。</p><p>除此之外，Parquet在读取数据时，会考虑列的存储是否是连接的，对于连续的列，一次读操作就可以把多个列的数据读到内存。</p><p><strong>谓词下推</strong><br>在RDB中谓词下推是一项非常通用的技术，通过将一些过滤条件尽可能的在最底层执行可以减少每一层交互的数据量，从而提升性能。</p><p>例如，</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select <span class="built_in">count</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">from</span> A Join B</span><br><span class="line"><span class="keyword">on</span> A.<span class="built_in">id</span> = B.<span class="built_in">id</span></span><br><span class="line"><span class="keyword">where</span> A.a &gt; <span class="number">10</span> <span class="keyword">and</span> B.b &lt; <span class="number">100</span></span><br></pre></td></tr></table></figure><p>SQL查询中，如果把过滤条件A.a &gt; 10和B.b &lt; 100分别移到TableScan的时候执行，可以大大降低Join操作的输入数据。</p><p>无论是行式存储还是列式存储，都可以做到上面提到的将一些过滤条件尽可能的在最底层执行。</p><p>但是Parquet做了更进一步的优化，它对于每个行组中的列都在存储时进行了统计信息的记录，包括最小值，最大值，空值个数。通过这些统计值和该列的过滤条件可以直接判断此行组是否需要扫描。</p><p>另外，未来还会增加Bloom Filter和Index等优化数据，更加有效的完成谓词下推。</p><p>在使用Parquet的时候可以通过如下两种策略提升查询性能：</p><ul><li>类似于关系数据库的主键，对需要频繁过滤的列设置为有序的，这样在导入数据的时候会根据该列的顺序存储数据，这样可以最大化的利用最大值、最小值实现谓词下推。</li><li>减小行组大小和页大小，这样增加跳过整个行组的可能性，但是此时需要权衡由于压缩和编码效率下降带来的I/O负载。<h3 id="AVRO"><a href="#AVRO" class="headerlink" title="AVRO"></a>AVRO</h3></li></ul><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p><strong>优缺点</strong></p><ul><li>优点： <ul><li>减少存储磁盘空间，降低单节点的磁盘IO。</li><li>由于压缩后的数据占用的带宽更少，因此可以加快数据在Hadoop集群流动的速度。例如在不同节点创建3个replica的阶段，或是shuffle阶段。</li></ul></li><li>缺点： 需要花费额外的时间/CPU做压缩和解压缩计算</li></ul><p><strong>几种常见的压缩对比</strong></p><p><img src="/images/compress-compare.jpg"></p><p><strong>是否支持分割</strong></p><p><img src="/images/compress-split.png"></p><p>压缩格式文件是否是可分割的 也比较重要：<br>MapReduce 需要将非常大的输入文件分割成多个划分（通常一个文件块对应一个跨分没也就是64MB的倍数），<br>其中每个划分会被分发到一个单独的map进程中。<br>只有当Hadoop 知道文件中记录的边界才可以进行这样的分割。<br>GZip 跟 Snappy 将这些边界信息掩盖掉了。<br>BZip2和LZO提供了块(BLOCK)级别的压缩，也就是每个块都含有完整的记录信息，因此Hadoop 可以在块边界级别对这些文件进行划分。</p><p>需要注意一点：<br>虽然GZip 与 Snappy 文件不可分，但也有替代的方案。<br>当用户创建文件的时候，可以将文件分割成期望的文件大小，通常输出文件的个数等于Reducer 的个数。</p><p>用户使用了N个Reducer，通常就会得到N个输出文件</p><p><strong>压缩分析</strong></p><p>首先说明mapreduce哪些过程可以设置压缩：需要分析处理的数据在进入map前可以压缩，然后解压处理，map处理完成后的输出可以压缩，这样可以减少网络I/O(reduce通常和map不在同一节点上)，reduce拷贝压缩的数据后进行解压，处理完成后可以压缩存储在hdfs上，以减少磁盘占用量。<br><img src="/images/compress-stage.png"></p><h2 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h2><p>在进行测试之前，我们先看看HortonWork公司官网对这几种存储格式的比较分析：<br><img src="/images/HortonWork-hive-file-compare.png"><br>从图中很明显看到ORC存储格式和Parquet存储格式对文件的存储比Text格式小很多，也就是说压缩比大很多</p><p>实际性能对比测试：<br><a href="https://blog.csdn.net/henrrywan/article/details/90719015" target="_blank" rel="noopener">实验来源</a></p><p>我们从同一个源表新增数据到这六张测试表，为了体现存储数据的差异性，我们选取了一张数据量比较大的源表（源表数据量为30000000条）。<br>下面从存储空间和SQL查询两个方面进行比较。<br>其中SQL查询为包含group by的计量统计和不含group by的计量统计。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sql01:<span class="keyword">select</span> count<span class="comment">(*) from test_table;</span></span><br><span class="line"><span class="comment">sql02:select id,count(*)</span> <span class="keyword">from</span> test_table <span class="keyword">group</span> <span class="keyword">by</span> id;</span><br></pre></td></tr></table></figure><p>相关的查询结果如下（为了防止出现偶然性，我们每条SQL至少执行三次，取平均值）</p><div class="table-container"><table><thead><tr><th style="text-align:center">文件存储格式</th><th style="text-align:center">HDFS存储空间</th><th style="text-align:center">不含group by</th><th style="text-align:center">含group by</th></tr></thead><tbody><tr><td style="text-align:center">TextFile</td><td style="text-align:center">7.3 G</td><td style="text-align:center">105s</td><td style="text-align:center">370s</td></tr><tr><td style="text-align:center">Parquet</td><td style="text-align:center">769.0 M</td><td style="text-align:center"><strong>28s</strong></td><td style="text-align:center"><strong>195s</strong></td></tr><tr><td style="text-align:center">ORC</td><td style="text-align:center"><strong>246.0 M</strong></td><td style="text-align:center">34s</td><td style="text-align:center">310s</td></tr><tr><td style="text-align:center">Sequence</td><td style="text-align:center">7.8 G</td><td style="text-align:center">135s</td><td style="text-align:center">385s</td></tr><tr><td style="text-align:center">RC</td><td style="text-align:center">6.9 G</td><td style="text-align:center">92s</td><td style="text-align:center">330s</td></tr><tr><td style="text-align:center">AVRO</td><td style="text-align:center">8.0G</td><td style="text-align:center">240s</td><td style="text-align:center">530s</td></tr></tbody></table></div><h1 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h1><p><strong>作用</strong><br>官方解释：<a href="https://cwiki.apache.org/confluence/display/Hive/DeveloperGuide#DeveloperGuide-HiveSerDe" target="_blank" rel="noopener">Hive SerDe wiki </a></p><ul><li>SerDe is a short name for “Serializer and Deserializer.”</li><li>Hive uses SerDe (and FileFormat) to read and write table rows.</li><li>HDFS files —&gt; InputFileFormat —&gt; <key, value=""> —&gt; Deserializer —&gt; Row object</key,></li><li>Row object —&gt; Serializer —&gt; <key, value=""> —&gt; OutputFileFormat —&gt; HDFS files</key,></li></ul><p><strong>注册机制</strong><br>使用”STORED AS”关键字替代{SerDe, InputFormat, and OutputFormat}语法</p><p><img src="/images/hive-srede-replace.png"></p><h1 id="存储后端"><a href="#存储后端" class="headerlink" title="存储后端"></a>存储后端</h1><p>通过HIVE存储处理器，不但可以让hive基于hbase实现，还可以支持cassandra JDBC MongoDB 以及 Google Spreadsheets </p><p>HIVE存储器的实现原理基于HIVE以及Hadoop的可扩展性实现：</p><ul><li>输入格式化（input formats）</li><li>输出格式化（output formats）</li><li>序列化/反序列化包（serialization/deserialization librarises） </li></ul><p>除了依据以上可扩展性，存储处理器还需要实现新的元数据钩子接口，这个接口允许使用HIVE的DDL语句来定义和管理hive自己的元数据以及其它系统的目录（此目录个人理解为其它系统的元数据目录）</p><p>一些术语：</p><p>HIVE本身有的概念：</p><ul><li>被管理的表即内部表（managed）：元数据由hive管理，并且数据也存储在hive的体系里面</li><li>外部表（external table）：表的定义被外部的元数据目录所管理，数据也存储在外部系统中</li></ul><p>hive存储处理器的概念：</p><ul><li>本地（native）表：hive不需要借助存储处理器就可以直接管理和访问的表</li><li>非本地（non-native）表:需要通过存储处理器才能管理和访问的表</li></ul><p>内部表 外部表 和 本地表 非本地表 形成交叉，就有了下面四种形式的概念定义：</p><ul><li>managed native: what you get by default with CREATE TABLE</li><li>external native: what you get with CREATE EXTERNAL TABLE when no STORED BY clause is specified</li><li>managed non-native: what you get with CREATE TABLE when a STORED BY clause is specified; Hive stores the definition in its metastore, but does not create any files itself; instead, it calls the storage handler with a request to create a corresponding object structure</li><li>external non-native: what you get with CREATE EXTERNAL TABLE when a STORED BY clause is specified; Hive registers the definition in its metastore and calls the storage handler to check that it matches the primary definition in the other system</li></ul><h1 id="HQL"><a href="#HQL" class="headerlink" title="HQL"></a>HQL</h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="Join的实现原理"><a href="#Join的实现原理" class="headerlink" title="Join的实现原理"></a>Join的实现原理</h3><p>select u.name, o.orderid from order o join user u on o.uid = u.uid;</p><p>在map的输出value中为不同表的数据打上tag标记，在reduce阶段根据tag判断数据来源。MapReduce的过程如下（这里只是说明最基本的Join的实现，还有其他的实现方式）</p><p><img src="/images/hql-join.png"></p><h3 id="Group-By的实现原理"><a href="#Group-By的实现原理" class="headerlink" title="Group By的实现原理"></a>Group By的实现原理</h3><p>select rank, isonline, count(*) from city group by rank, isonline;</p><p>将GroupBy的字段组合为map的输出key值，利用MapReduce的排序，在reduce阶段保存LastKey区分不同的key。MapReduce的过程如下（当然这里只是说明Reduce端的非Hash聚合过程）</p><p><img src="/images/hql-groupby.png"></p><h3 id="Distinct的实现原理"><a href="#Distinct的实现原理" class="headerlink" title="Distinct的实现原理"></a>Distinct的实现原理</h3><p>select dealid, count(distinct uid) num from order group by dealid;</p><p>当只有一个distinct字段时，如果不考虑Map阶段的Hash GroupBy，只需要将GroupBy字段和Distinct字段组合为map输出key，利用mapreduce的排序，同时将GroupBy字段作 为reduce的key，在reduce阶段保存LastKey即可完成去重</p><p><img src="/images/hql-distinct.png"></p><p>如果有多个distinct字段呢，如下面的SQL</p><p>select dealid, count(distinct uid), count(distinct date) from order group by dealid;</p><p>实现方式有两种：</p><p>（1）如果仍然按照上面一个distinct字段的方法，即下图这种实现方式，无法跟据uid和date分别排序，也就无法通过LastKey去重，仍然需要在reduce阶段在内存中通过Hash去重</p><p><img src="/images/multi-distinct1.png"></p><p>2）第二种实现方式，可以对所有的distinct字段编号，每行数据生成n行数据，那么相同字段就会分别排序，这时只需要在reduce阶段记录LastKey即可去重。</p><p>这种实现方式很好的利用了MapReduce的排序，节省了reduce阶段去重的内存消耗，但是缺点是增加了shuffle的数据量。</p><p>需要注意的是，在生成reduce value时，除第一个distinct字段所在行需要保留value值，其余distinct数据行value字段均可为空。</p><p><img src="/images/multi-distinct2.png"></p><h3 id="SQL转化为MapReduce的过程"><a href="#SQL转化为MapReduce的过程" class="headerlink" title="SQL转化为MapReduce的过程"></a>SQL转化为MapReduce的过程</h3><p>了解了MapReduce实现SQL基本操作之后，我们来看看Hive是如何将SQL转化为MapReduce任务的，整个编译过程分为六个阶段：</p><ul><li>Antlr定义SQL的语法规则，完成SQL词法，语法解析，将SQL转化为抽象语法树AST Tree</li><li>遍历AST Tree，抽象出查询的基本组成单元QueryBlock</li><li>遍历QueryBlock，翻译为执行操作树OperatorTree</li><li>逻辑层优化器进行OperatorTree变换，合并不必要的ReduceSinkOperator，减少shuffle数据量</li><li>遍历OperatorTree，翻译为MapReduce任务</li><li>物理层优化器进行MapReduce任务的变换，生成最终的执行计划</li></ul><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>ive执行引擎会将HQL“翻译”成为map-reduce任务，如果多张表使用同一列做join则将被翻译成一个reduce，否则将被翻译成多个map-reduce任务。</p><p>如：<br>hive执行引擎会将HQL“翻译”成为map-reduce任务，如果多张表使用同一列做join则将被翻译成一个reduce，否则将被翻译成多个map-reduce任务。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT <span class="selector-tag">a</span><span class="selector-class">.val</span>, <span class="selector-tag">b</span><span class="selector-class">.val</span>, c<span class="selector-class">.val</span> FROM <span class="selector-tag">a</span> JOIN <span class="selector-tag">b</span> ON (<span class="selector-tag">a</span><span class="selector-class">.key</span> = <span class="selector-tag">b</span>.key1) JOIN c ON (c<span class="selector-class">.key</span> = <span class="selector-tag">b</span>.key1)</span><br></pre></td></tr></table></figure><p>将被翻译成1个map-reduce任务</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT <span class="selector-tag">a</span><span class="selector-class">.val</span>, <span class="selector-tag">b</span><span class="selector-class">.val</span>, c<span class="selector-class">.val</span> FROM <span class="selector-tag">a</span> JOIN <span class="selector-tag">b</span> ON (<span class="selector-tag">a</span><span class="selector-class">.key</span> = <span class="selector-tag">b</span>.key1) JOIN c ON (c<span class="selector-class">.key</span> = <span class="selector-tag">b</span>.key2)</span><br></pre></td></tr></table></figure><p>将被翻译成2个map-reduce任务<br>这个很好理解，一般来说（map side join除外），map过程负责分发数据，具体的join操作在reduce完成，因此，如果多表基于不同的列做join，则无法在一轮map-reduce任务中将所有相关数据shuffle到统一个reducer<br>对于多表join，hive会将前面的表缓存在reducer的内存中，然后后面的表会流式的进入reducer和reducer内存中其它的表做join.<br>为了防止数据量过大导致oom，将数据量最大的表放到最后，或者通过“STREAMTABLE”显示指定reducer流式读入的表</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>1、内关联（[inner] join）：只返回关联上的结果</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select <span class="keyword">a</span>.id,<span class="keyword">a</span>.name,b.age <span class="built_in">from</span> rdb_a <span class="keyword">a</span> inner join rdb_b b <span class="keyword">on</span> <span class="title">a</span>.<span class="title">id</span>=<span class="title">b</span>.<span class="title">id</span>;</span><br><span class="line"> </span><br><span class="line">Total MapReduce CPU Time Spent: <span class="number">2</span> <span class="built_in">seconds</span> <span class="number">560</span> msec</span><br><span class="line">OK</span><br><span class="line"><span class="number">1</span>       lucy    <span class="number">12</span></span><br><span class="line"><span class="number">2</span>       jack    <span class="number">22</span></span><br><span class="line">Time taken: <span class="number">47.419</span> <span class="built_in">seconds</span>, Fetched: <span class="number">2</span> row(s)</span><br></pre></td></tr></table></figure><p>2、左关联（left [outer] join）：以左表为主</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select <span class="keyword">a</span>.id,<span class="keyword">a</span>.name,b.age <span class="built_in">from</span> rdb_a <span class="keyword">a</span> left join rdb_b b <span class="keyword">on</span> <span class="title">a</span>.<span class="title">id</span>=<span class="title">b</span>.<span class="title">id</span>;</span><br><span class="line"> </span><br><span class="line">Total MapReduce CPU Time Spent: <span class="number">1</span> <span class="built_in">seconds</span> <span class="number">240</span> msec</span><br><span class="line">OK</span><br><span class="line"><span class="number">1</span>       lucy    <span class="number">12</span></span><br><span class="line"><span class="number">2</span>       jack    <span class="number">22</span></span><br><span class="line"><span class="number">3</span>       tony    <span class="literal">NULL</span></span><br><span class="line">Time taken: <span class="number">33.42</span> <span class="built_in">seconds</span>, Fetched: <span class="number">3</span> row(s)</span><br></pre></td></tr></table></figure><p>3、右关联（right [outer] join）：以右表为主</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select <span class="keyword">a</span>.id,<span class="keyword">a</span>.name,b.age <span class="built_in">from</span> rdb_a <span class="keyword">a</span> <span class="literal">right</span> join rdb_b b <span class="keyword">on</span> <span class="title">a</span>.<span class="title">id</span>=<span class="title">b</span>.<span class="title">id</span>;</span><br><span class="line"> </span><br><span class="line">Total MapReduce CPU Time Spent: <span class="number">2</span> <span class="built_in">seconds</span> <span class="number">130</span> msec</span><br><span class="line">OK</span><br><span class="line"><span class="number">1</span>       lucy    <span class="number">12</span></span><br><span class="line"><span class="number">2</span>       jack    <span class="number">22</span></span><br><span class="line"><span class="literal">NULL</span>    <span class="literal">NULL</span>    <span class="number">32</span></span><br><span class="line">Time taken: <span class="number">32.7</span> <span class="built_in">seconds</span>, Fetched: <span class="number">3</span> row(s)</span><br></pre></td></tr></table></figure><p>4、全关联（full [outer] join）：以两个表的记录为基准，返回两个表的记录去重之和，关联不上的字段为NULL。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select <span class="keyword">a</span>.id,<span class="keyword">a</span>.name,b.age <span class="built_in">from</span> rdb_a <span class="keyword">a</span> full join rdb_b b <span class="keyword">on</span> <span class="title">a</span>.<span class="title">id</span>=<span class="title">b</span>.<span class="title">id</span>;</span><br><span class="line"> </span><br><span class="line">Total MapReduce CPU Time Spent: <span class="number">5</span> <span class="built_in">seconds</span> <span class="number">540</span> msec</span><br><span class="line">OK</span><br><span class="line"><span class="number">1</span>       lucy    <span class="number">12</span></span><br><span class="line"><span class="number">2</span>       jack    <span class="number">22</span></span><br><span class="line"><span class="number">3</span>       tony    <span class="literal">NULL</span></span><br><span class="line"><span class="literal">NULL</span>    <span class="literal">NULL</span>    <span class="number">32</span></span><br><span class="line">Time taken: <span class="number">42.938</span> <span class="built_in">seconds</span>, Fetched: <span class="number">4</span> row(s)</span><br></pre></td></tr></table></figure><p>5、left semi join：以LEFT SEMI JOIN关键字前面的表为主表，返回主表的KEY也在副表中的记录。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select a.<span class="built_in">id</span>,a.<span class="built_in">name</span> <span class="keyword">from</span> rdb_a a left semi join rdb_b b <span class="keyword">on</span> a.<span class="built_in">id</span>=b.<span class="built_in">id</span>;</span><br><span class="line"> </span><br><span class="line">Total MapReduce CPU Time Spent: <span class="number">3</span> seconds <span class="number">300</span> msec</span><br><span class="line">OK</span><br><span class="line"><span class="number">1</span>       lucy</span><br><span class="line"><span class="number">2</span>       jack</span><br><span class="line">Time taken: <span class="number">31.105</span> seconds, Fetched: <span class="number">2</span> row(s)</span><br><span class="line"> </span><br><span class="line">其实就相当于：select a.<span class="built_in">id</span>,a.<span class="built_in">name</span> <span class="keyword">from</span> rdb_a a <span class="keyword">where</span> a.<span class="built_in">id</span> <span class="keyword">in</span>(select b.<span class="built_in">id</span> <span class="keyword">from</span>  rdb_b b );</span><br></pre></td></tr></table></figure><p>6、笛卡尔积关联（cross join）：返回两个表的笛卡尔积结果，不需要指定关联键</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">select a.id,a.name,<span class="keyword">b.age </span>from rdb_a a cross <span class="keyword">join </span>rdb_b <span class="keyword">b;</span></span><br><span class="line"><span class="keyword"> </span></span><br><span class="line">Total MapReduce CPU Time Spent: <span class="number">1</span> seconds <span class="number">260</span> msec</span><br><span class="line">OK</span><br><span class="line"><span class="number">1</span>       lucy    <span class="number">12</span></span><br><span class="line"><span class="number">1</span>       lucy    <span class="number">22</span></span><br><span class="line"><span class="number">1</span>       lucy    <span class="number">32</span></span><br><span class="line"><span class="number">2</span>       <span class="keyword">jack </span>   <span class="number">12</span></span><br><span class="line"><span class="number">2</span>       <span class="keyword">jack </span>   <span class="number">22</span></span><br><span class="line"><span class="number">2</span>       <span class="keyword">jack </span>   <span class="number">32</span></span><br><span class="line"><span class="number">3</span>       tony    <span class="number">12</span></span><br><span class="line"><span class="number">3</span>       tony    <span class="number">22</span></span><br><span class="line"><span class="number">3</span>       tony    <span class="number">32</span></span><br><span class="line">Time taken: <span class="number">24</span>.<span class="number">727</span> seconds, Fetched: <span class="number">9</span> row(s)</span><br></pre></td></tr></table></figure><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>统的说，Hive中的Join可分为Common Join（Reduce阶段完成join）和Map Join（Map阶段完成join）。本文简单介绍一下两种join的原理和机制。</p><p><strong>Common Join</strong></p><ul><li><p>Map阶段</p><p>  读取源表的数据，Map输出时候以Join on条件中的列为key，如果Join有多个关联键，则以这些关联键的组合作为key;<br>  Map输出的value为join之后所关心的(select或者where中需要用到的)列；同时在value中还会包含表的Tag信息，用于标明此value对应哪个表；<br>  按照key进行排序</p></li><li>Shuffle阶段<br>根据key的值进行hash,并将key/value按照hash值推送至不同的reduce中，这样确保两个表中相同的key位于同一个reduce中</li><li>Reduce阶段<br>根据key的值完成join操作，期间通过Tag来识别不同表中的数据。</li></ul><p><img src="/images/common-join.jpeg"></p><p><strong>Map Join</strong></p><p>MapJoin通常用于一个很小的表和一个大表进行join的场景，具体小表有多小，由参数hive.mapjoin.smalltable.filesize来决定，该参数表示小表的总大小，默认值为25000000字节，即25M。<br>Hive0.7之前，需要使用hint提示 /+ mapjoin(table) /才会执行MapJoin,否则执行Common Join，但在0.7版本之后，默认自动会转换Map Join，由参数hive.auto.convert.join来控制，默认为true.<br>仍然以9.1中的HQL来说吧，假设a表为一张大表，b为小表，并且hive.auto.convert.join=true,那么Hive在执行时候会自动转化为MapJoin。</p><p><img src="/images/map-join.jpeg"></p><ul><li>如图中的流程，首先是Task A，它是一个Local Task（在客户端本地执行的Task），负责扫描小表b的数据，将其转换成一个HashTable的数据结构，并写入本地的文件中，之后将该文件加载到DistributeCache中，该HashTable的数据结构可以抽象为：</li><li>接下来是Task B，该任务是一个没有Reduce的MR，启动MapTasks扫描大表a,在Map阶段，根据a的每一条记录去和DistributeCache中b表对应的HashTable关联，并直接输出结果。</li></ul><p>由于MapJoin没有Reduce，所以由Map直接输出结果文件，有多少个Map Task，就有多少个结果文件。</p><h3 id="Hive-在倾斜表的Join优化"><a href="#Hive-在倾斜表的Join优化" class="headerlink" title="Hive 在倾斜表的Join优化"></a>Hive 在倾斜表的Join优化</h3><p>Join的过程中，Map结束之后，会将相同的Key的数据shuffle到同一个Reduce中，如果数据分布均匀的话，每个Reduce处理的数据量大体上是比较均衡的，但是若明显存在数据倾斜的时候，会出现某些Reducer处理的数据量过大，从而使得该节点的处理时间过长，成为瓶颈。</p><p>在已经知道数据的情况下，可以人为的进行语句的拆分。<br>如：表A与表B进行Join，在明知Id=1的数据明显的存在数据倾斜，可以将语句select A.id from A join B on A.id = B.id拆分为以下两条：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select A.<span class="built_in">id</span> <span class="keyword">from</span> A join B <span class="keyword">on</span> A.<span class="built_in">id</span> = B.<span class="built_in">id</span> <span class="keyword">where</span> A.<span class="built_in">id</span> &lt;&gt; <span class="number">1</span>;</span><br><span class="line">select A.<span class="built_in">id</span> <span class="keyword">from</span> A join B <span class="keyword">on</span> A.<span class="built_in">id</span> = B.<span class="built_in">id</span> <span class="keyword">where</span> A.<span class="built_in">id</span> = <span class="number">1</span> <span class="keyword">and</span> B.<span class="built_in">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>优点：<ul><li>针对只有少量的Key会产生数据倾斜的场景下非常的有用。</li></ul></li><li>缺点：<ul><li>表A和表B需要被读和处理两次。处理的结果也需要读和写两次。</li><li>需要人为的去找出这些产生数据倾斜的Key,并手动拆分处理。</li></ul></li></ul><p>Hive优化的方法：<br>首先读取表B，并将key为1的行存储为HashTable,放入到分布式缓存中（为了使用MapJoin），然后运行一些Map任务去读表A，并按照以下流程进行处理：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">If <span class="keyword">it</span> has key <span class="number">1</span>, <span class="keyword">then</span> use <span class="keyword">the</span> hashed <span class="built_in">version</span> <span class="keyword">of</span> B <span class="built_in">to</span> compute <span class="keyword">the</span> <span class="built_in">result</span>.</span><br><span class="line">For all other <span class="built_in">keys</span>, <span class="built_in">send</span> <span class="keyword">it</span> <span class="built_in">to</span> <span class="keyword">a</span> reducer which does <span class="keyword">the</span> join. This reducer will <span class="built_in">get</span> rows <span class="keyword">of</span> B also <span class="built_in">from</span> <span class="keyword">a</span> mapper.</span><br></pre></td></tr></table></figure><p>这种方法可以避免读取B两次，表A中的倾斜Key会使用MapJoin方式进行处理。</p><p>以上的这些假设是针对B有少量的行的key与表A中的倾斜Key相同，因此这些行可以加载进内存中。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><strong>order by</strong></p><p>order by会对输入做全局排序，因此只有一个Reducer(多个Reducer无法保证全局有序)，然而只有一个Reducer，会导致当输入规模较大时，消耗较长的计算时间。</p><p><strong>sort by</strong></p><p>sort by不是全局排序，其在数据进入reducer前完成排序，因此，如果用sort by进行排序，并且设置mapred.reduce.tasks&gt;1，则sort by只会保证每个reducer的输出有序，并不保证全局有序。sort by不同于order by，它不受hive.mapred.mode属性的影响，sort by的数据只能保证在同一个reduce中的数据可以按指定字段排序。使用sort by你可以指定执行的reduce个数(通过set mapred.reduce.tasks=n来指定)，对输出的数据再执行归并排序，即可得到全部结果。</p><p><strong>distribute by</strong></p><p>distribute by是控制在map端如何拆分数据给reduce端的。hive会根据distribute by后面列，对应reduce的个数进行分发，默认是采用hash算法。sort by为每个reduce产生一个排序文件。在有些情况下，你需要控制某个特定行应该到哪个reducer，这通常是为了进行后续的聚集操作。distribute by刚好可以做这件事。因此，distribute by经常和sort by配合使用。</p><p>注：Distribute by和sort by的使用场景</p><ul><li>Map输出的文件大小不均。</li><li>Reduce输出文件大小不均。</li><li>.小文件过多。</li><li>文件超大。</li></ul><p><strong>cluster by</strong></p><p>cluster by除了具有distribute by的功能外还兼具sort by的功能。但是排序只能是倒叙排序，不能指定排序规则为ASC或者DESC。</p><h1 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h1><p>hive调优是比较大的专题，需要结合实际的业务，数据的类型，分布，质量状况等来实际的考虑如何进行系统性的优化，hive底层是mapreduce，所以hadoop调优也是hive调优的一个基础,hvie调优可以分为几个模块进行考虑，数据的压缩与存储，sql的优化，hive参数的优化，解决数据的倾斜等。</p><h2 id="数据的压缩与存储格式"><a href="#数据的压缩与存储格式" class="headerlink" title="数据的压缩与存储格式"></a>数据的压缩与存储格式</h2><p> 压缩可以节约磁盘的空间，基于文本的压缩率可达40%+; 压缩可以增加吞吐量和性能量(减小载入内存的数据量)，但是在压缩和解压过程中会增加CPU的开销。所以针对IO密集型的jobs(非计算密集型)可以使用压缩的方式提高性能。</p><p> 选择压缩算法的时候需要考虑到是否可以分割，如果不支持分割（切片的时候需要确定一条数据的完整性），则一个map需要执行完一个文件，如果文件很大，则效率很低。一般情况下hdfs一个块（128M）就是一个map的输入切片，而block是按物理切割的，可能一条数据会被切到两个块中去，而mapde 切片如何确保一条数据在一个切片中呢？这就是看压缩算法支不支持分割了，具体的实现机制需要看源码研究。</p><p>可以使用列裁剪，分区裁剪，orc，parquet等这些列式存储格式，因为列式存储的表，每一列的数据在物理上是存储在一起的，Hive查询时会只遍历需要列数据，大大减少处理的数据量。</p><p>Hive支持ORCfile，这是一种新的表格存储格式，通过诸如谓词下推，压缩等技术来提高执行速度提升。对于每个HIVE表使用ORCfile应该是一件容易的事情，并且对于获得HIVE查询的快速响应时间非常有益。　　</p><h2 id="hive参数优化"><a href="#hive参数优化" class="headerlink" title="hive参数优化"></a>hive参数优化</h2><p>1、fetch task 为执行hive时，不用执行MapReduce，如select * from emp；<br>2、并行执行</p><pre><code><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启任务并行执行</span></span><br><span class="line"> <span class="built_in">set</span> hive.<span class="built_in">exec</span>.parallel=<span class="literal">true</span>;</span><br><span class="line"> <span class="comment">// 同一个sql允许并行任务的最大线程数 </span></span><br><span class="line"><span class="built_in">set</span> hive.<span class="built_in">exec</span>.parallel.thread.number=<span class="number">8</span>;</span><br></pre></td></tr></table></figure></code></pre><p>3、jvm 重用<br> JVM重用对hive的性能具有非常大的 影响，特别是对于很难避免小文件的场景或者task特别多的场景，这类场景大多数执行时间都很短。jvm的启动过程可能会造成相当大的开销，尤其是执行的job包含有成千上万个task任务的情况。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">set</span> mapred.job.reuse.jvm.num.<span class="attribute">tasks</span>=10;</span><br></pre></td></tr></table></figure><p>JVM的一个缺点是，开启JVM重用将会一直占用使用到的task插槽，以便进行重用，直到任务完成后才能释放。如果某个“不平衡“的job中有几个 reduce task 执行的时间要比其他reduce task消耗的时间多得多的话，那么保留的插槽就会一直空闲着却无法被其他的job使用，直到所有的task都结束了才会释放。</p><p>4、设置reduce的数目<br>reduce个数的设定极大影响任务执行效率，不指定reduce个数的情况下，Hive会猜测确定一个reduce个数，基于以下两个设定： hive.exec.reducers.bytes.per.reducer（每个reduce任务处理的数据量，在Hive 0.14.0版本之前默认值是1G(1,000,000,000)；而从Hive 0.14.0开始，默认值变成了256M(256,000,000) ） hive.exec.reducers.max（每个任务最大的reduce数，在Hive 0.14.0版本之前默认值是999；而从Hive 0.14.0开始，默认值变成了1009 ） 计算reducer数的公式很简单N=min(参数2，总输入数据量/参数1) 即，如果reduce的输入（map的输出）总大小不超过1G,那么只会有一个reduce任务；</p><p>  reduce个数并不是越多越好； 同map一样，启动和初始化reduce也会消耗时间和资源； 另外，有多少个reduce,就会有多少个输出文件，如果生成了很多个小文件，那么如果这些小文件作为下一个任务的输入，则也会出现小文件过多的问题 -</p><p>5、推测执行<br>所谓的推测执行，就是当所有task都开始运行之后，Job Tracker会统计所有任务的平均进度，如果某个task所在的task node机器配置比较低或者CPU load很高（原因很多），导致任务执行比总体任务的平均执行要慢，此时Job Tracker会启动一个新的任务（duplicate task），原有任务和新任务哪个先执行完就把另外一个kill掉</p><h2 id="数据倾斜"><a href="#数据倾斜" class="headerlink" title="数据倾斜"></a>数据倾斜</h2><p>表现：任务进度长时间维持在99%（或100%），查看任务监控页面，发现只有少量（1个或几个）reduce子任务未完成。因为其处理的数据量和其他reduce差异过大。</p><p>原因：某个reduce的数据输入量远远大于其他reduce数据的输入量</p><ul><li>key分布不均匀</li><li>业务数据本身的特性</li><li>建表时考虑不周</li><li>某些SQL语句本身就有数据倾斜</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">关键词</th><th style="text-align:center">情形</th><th style="text-align:center">后果</th></tr></thead><tbody><tr><td style="text-align:center">join</td><td style="text-align:center">其中一个表较小，但是key集中</td><td style="text-align:center">分发到某一个或几个Reduce上的数据远高于平均值</td></tr><tr><td style="text-align:center">join</td><td style="text-align:center">大表与大表，但是分桶的判断字段0值或空值过多</td><td style="text-align:center">这些空值都由一个reduce处理，非常慢</td></tr><tr><td style="text-align:center">group by</td><td style="text-align:center">group by 维度过小，某值的数量过多</td><td style="text-align:center">处理某值的reduce非常耗时</td></tr><tr><td style="text-align:center">count distinct</td><td style="text-align:center">某特殊值过多</td><td style="text-align:center">处理此特殊值reduce耗时</td></tr></tbody></table></div><p>解决方案：</p><ul><li><p>参数调节</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启Map端聚合参数设置</span></span><br><span class="line">set hive<span class="selector-class">.map</span><span class="selector-class">.aggr</span>=true</span><br><span class="line"><span class="comment">// 有数据倾斜的时候进行负载均衡</span></span><br><span class="line">set hive<span class="selector-class">.groupby</span><span class="selector-class">.skewindata</span> = true</span><br></pre></td></tr></table></figure></li><li><p>熟悉数据的分布，优化sql的逻辑，找出数据倾斜的原因</p></li></ul><h2 id="小文件合并优化"><a href="#小文件合并优化" class="headerlink" title="小文件合并优化"></a>小文件合并优化</h2><p>小文件是如何产生的：</p><ul><li>动态分区插入数据，产生大量的小文件，从而导致map数量剧增；</li><li>reduce数量越多，小文件也越多（reduce的个数和输出文件是对应的）；</li><li>数据源本身就包含大量的小文件。</li></ul><p>小文件问题的影响：</p><ul><li>从Hive的角度看，小文件会开很多map，一个map开一个JVM去执行，所以这些任务的初始化，启动，执行会浪费大量的资源，严重影响性能。</li><li>在HDFS中，每个小文件对象约占150byte，如果小文件过多会占用大量内存。这样NameNode内存容量严重制约了集群的扩展。</li></ul><p>小文件问题的解决方案：</p><p>从小文件产生的途径就可以从源头上控制小文件数量，方法如下：</p><ul><li>使用Sequencefile作为表存储格式，不要用textfile，在一定程度上可以减少小文件；</li><li>减少reduce的数量（可以使用参数进行控制）；</li><li>少用动态分区，用时记得按distribute by分区；</li><li>选择合理的分区字段</li></ul><p>对于已有的小文件，我们可以通过以下几种方案解决：</p><ul><li>使用hadoop archive命令把小文件进行归档；</li><li>重建表，建表时减少reduce数量；</li><li>合并map、reduce输出的文件</li><li>控制map端split文件的大小</li></ul><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><p>1、列裁剪<br>Hive在读数据的时候，可以只读取查询中所需要用到的列，而忽略其他列</p><p>2、分区裁剪<br>可以在查询的过程中减少不必要的分区</p><p>3、COUNT(DISTINCT)<br>计算uv的时候，经常会用到COUNT(DISTINCT)，但在数据比较倾斜的时候COUNT(DISTINCT)会比较慢。这时可以尝试用GROUP BY改写代码计算uv。数据量小的时候无所谓，数据量大的情况下，由于COUNT DISTINCT操作需要用一个Reduce Task来完成，这一个Reduce需要处理的数据量太大，就会导致整个Job很难完成，一般COUNT DISTINCT使用先GROUP BY再COUNT的方式替换。</p><p>4、join操作</p><ul><li>空Key过滤</li><li>开启MapJoin</li><li><p>将条目少的表/子查询放在Join操作符的左边</p><p>  原因是在Join操作的Reduce阶段，位于Join操作符左边的表的内容会被加载进内存，将条目少的表放在左边，可以有效减少发生OOM错误的几率；再进一步，可以使用Group让小的维度表（1000条以下的记录条数）先进内存。在map端完成reduce。</p></li></ul><p>5、GROUP BY操作<br>默认情况下，Map阶段同一Key数据分发给一个reduce，当一个key数据过大时就倾斜了</p><p>Map端部分聚合：</p><p>事实上并不是所有的聚合操作都需要在reduce部分进行，很多聚合操作都可以先在Map端进行部分聚合，然后reduce端得出最终结果。</p><ul><li><p>开启Map端聚合参数设置</p><p>  set hive.map.aggr=true</p></li><li><p>在Map端进行聚合操作的条目数目</p><p>  set hive.grouby.mapaggr.checkinterval=100000</p></li></ul><p>有数据倾斜时进行负载均衡：</p><p>　　此处需要设定hive.groupby.skewindata，当选项设定为true时，生成的查询计划有两个MapReduce任务。在第一个MapReduce中，map的输出结果集合会随机分布到reduce中，每个reduce做部分聚合操作，并输出结果。这样处理的结果是，相同的Group By Key有可能分发到不同的reduce中，从而达到负载均衡的目的；第二个MapReduce任务再根据预处理的数据结果按照Group By Key分布到reduce中（这个过程可以保证相同的Group By Key分布到同一个reduce中），最后完成最终的聚合操作。</p><p>6、排序选择</p><ul><li>cluster by: 对同一字段分桶并排序，不能和sort by连用；</li><li>distribute by + sort by: 分桶，保证同一字段值只存在一个结果文件当中，结合sort by 保证每个reduceTask结果有序；</li><li>sort by: 单机排序，单个reduce结果有序</li><li>order by：全局排序，缺陷是只能使用一个reduce</li></ul><p>6、自定义UDAF函数优化</p><p>sum，count，max，min等UDAF，不怕数据倾斜问题，hadoop在map端汇总合并优化，使数据倾斜不成问题。</p><h2 id="分表、分区、分桶"><a href="#分表、分区、分桶" class="headerlink" title="分表、分区、分桶"></a>分表、分区、分桶</h2><ul><li><p>分区</p><p>  分区表相当于hive的索引，加快查询速度</p></li><li>分桶<ul><li>获得更高的查询处理效率。桶为表加上了额外的结构，Hive 在处理有些查询时能利用这个结构。具体而言，连接两个在（包含连接列的）相同列上划分了桶的表，可以使用 Map 端连接 （Map-side join）高效的实现。比如JOIN操作。对于JOIN操作两个表有一个相同的列，如果对这两个表都进行了桶操作。那么将保存相同列值的桶进行JOIN操作就可以，可以大大较少JOIN的数据量。</li><li>使取样（sampling）更高效。在处理大规模数据集时，在开发和修改查询的阶段，如果能在数据集的一小部分数据上试运行查询，会带来很多方便。</li></ul></li><li><p>分表</p><p>  当你需要对一个很大的表做分析的时候，但不是每个字段都需要用到，可以考虑拆分表，生成子表，减少输入的数据量。并且过滤掉无效的数据，或者合并数据，进一步减少分析的数据量</p></li></ul>]]></content>
    
    <summary type="html">
    
      Hive
    
    </summary>
    
      <category term="大数据" scheme="http://langonggong.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Hive" scheme="http://langonggong.com/tags/Hive/"/>
    
      <category term="Hadoop" scheme="http://langonggong.com/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Hbase学习</title>
    <link href="http://langonggong.com/2020/09/21/Hbase%E5%AD%A6%E4%B9%A0/"/>
    <id>http://langonggong.com/2020/09/21/Hbase学习/</id>
    <published>2020-09-21T12:29:28.000Z</published>
    <updated>2020-09-28T17:05:56.795Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><ul><li>RowKey<br>  用来表示唯一一行记录的主键，HBase的数据是按照RowKey的字典顺序进行全局排序的，所有的查询都只能依赖于这一个排序维度</li><li>稀疏矩阵<br>  每一行中，列的组成都是灵活的，行与行之间并不需要遵循相同的列定义， 也就是HBase数据表”schema-less“的特点。</li><li>Region<br>  HBase中采用了”Range分区”，将Key的完整区间切割成一个个的”Key Range” ，每一个”Key Range”称之为一个Region。<br>  也可以这么理解：将HBase中拥有数亿行的一个大表，横向切割成一个个”子表“，这一个个”子表“就是Region：<br>  <img src="/images/Regions.png"></li><li>Column Family<br>  如果将Region看成是一个表的横向切割，那么，一个Region中的数据列的纵向切割，称之为一个Column Family。每一个列，都必须归属于一个Column Family，这个归属关系是在写数据时指定的，而不是建表时预先定义。<br>  <img src="/images/RegionAndColumnFamilies.png"></li><li>KeyValue<br>  每一行中的每一列数据，都被包装成独立的拥有特定结构的KeyValue，KeyValue中包含了丰富的自我描述信息:<br>  <img src="/images/KeyValue.png"><br>  看的出来，KeyValue是支撑”稀疏矩阵”设计的一个关键点：一些Key相同的任意数量的独立KeyValue就可以构成一行数据。但这种设计带来的一个显而易见的缺点：每一个KeyValue所携带的自我描述信息，会带来显著的数据膨胀。</li><li>Cell<br>  rowkey, column Family:column, version 他们三个参数确定唯一一个Cell</li></ul><h1 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h1><p><img src="/images/hbase-jiagou.png"></p><ul><li>ZooKeeper<ul><li>ZooKeeper 为 HBase 提供 Failover 机制，选举 Master，避免单点 Master 单点故障问题</li><li>存储所有 Region 的寻址入口：-ROOT-表在哪台服务器上。-ROOT-这张表的位置信息</li><li>实时监控 RegionServer 的状态，将 RegionServer 的上线和下线信息实时通知给 Master</li><li>存储 HBase 的 Schema，包括有哪些 Table，每个 Table 有哪些 Column Family</li></ul></li><li>NameNode<br>  HDFS作为一个分布式文件系统，自然需要文件目录树的元数据信息，另外，在HDFS中每一个文件都是按照Block存储的，文件与Block的关联也通过元数据信息来描述。NameNode提供了这些元数据信息的存储。</li><li>DataNode<br>  HDFS的数据存放节点。</li><li>RegionServer<ul><li>RegionServer 维护 Master 分配给它的 Region，处理对这些 Region 的 IO 请求</li><li>RegionServer 负责 Split 在运行过程中变得过大的 Region，负责 Compact 操作<br>可以看到，client 访问 HBase 上数据的过程并不需要 master 参与（寻址访问 zookeeper 和 RegioneServer，数据读写访问 RegioneServer），Master 仅仅维护者 Table 和 Region 的元数据信息，负载很低。</li></ul></li><li>Master<br>  HBase的管理节点，通常在一个集群中设置一个主Master，一个备Master，主备角色的”仲裁”由ZooKeeper实现。 Master主要职责：<ul><li>为 RegionServer 分配 Region</li><li>负责 RegionServer 的负载均衡</li><li>发现失效的 RegionServer 并重新分配其上的 Region</li><li>HDFS 上的垃圾文件（HBase）回收</li><li>处理 Schema 更新请求（表的创建，删除，修改，列簇的增加等等）</li></ul></li></ul><h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><p><img src="/images/hbase-wulijiegou.png"></p><ul><li>HRegion<br>  table在行的方向上分隔为多个Region。Region是HBase中分布式存储和负载均衡的最小单元，即不同的region可以分别在不同的Region Server上，但同一个Region是不会拆分到多个server上。<br>Region按大小分隔，每个表一般是只有一个region。随着数据不断插入表，region不断增大，当region的某个列族达到一个阈值时就会分成两个新的region。<br>每个region由以下信息标识：&lt; 表名,startRowkey,创建时间&gt;<br>由目录表(-ROOT-和.META.)记录该region的endRowkey</li><li>Store<br>  每一个region由一个或多个store组成，至少是一个store，hbase会把一起访问的数据放在一个store里面，即为每个 ColumnFamily建一个store，如果有几个ColumnFamily，也就有几个Store。一个Store由一个memStore和0或者 多个StoreFile组成。 HBase以store的大小来判断是否需要切分region</li><li>MemStore<br>  memStore 是放在内存里的。保存修改的数据即keyValues。当memStore的大小达到一个阀值（默认128MB）时，memStore会被flush到文 件，即生成一个快照。目前hbase 会有一个线程来负责memStore的flush操作。</li><li>StoreFile<br>  memStore内存中的数据写到文件后就是StoreFile，StoreFile底层是以HFile的格式保存。当storefile文件的数量增长到一定阈值后，系统会进行合并（minor、major compaction），在合并过程中会进行版本合并和删除工作（majar），形成更大的storefile。</li><li>HFile<br>  HBase中KeyValue数据的存储格式，HFile是Hadoop的 二进制格式文件，实际上StoreFile就是对Hfile做了轻量级包装，即StoreFile底层就是HFile。HFile数据文件存在于底层的HDFS中。</li><li>HLog<br>  HLog(WAL log)：WAL意为write ahead log，用来做灾难恢复使用，HLog记录数据的所有变更，一旦region server 宕机，就可以从log中进行恢复。</li></ul><h1 id="写流程"><a href="#写流程" class="headerlink" title="写流程"></a>写流程</h1><h2 id="写入步骤"><a href="#写入步骤" class="headerlink" title="写入步骤"></a>写入步骤</h2><ul><li>客户端想RegionServer发送写入数据请求；</li><li>RegionServer先将数据写入HLog，即WAL，再讲数据写入MemStore；</li><li>当MemStore中的数据达到阈值的时候，会将数据Flush到硬盘中，并同时清空内存和HLog中的历史数据；</li><li>将硬盘中数据通过HFile来序列化，再讲数据传输到HDFS进行存储。并对HLog进行一次标记；</li><li>当HFile数量到达一定值的时候，会进行compact操作，合并成一个大的HFile；</li><li>如果一个region大小超过阈值时，会进行split操作，并将拆分后的region重新分配的不同的RegionServer进行管理；</li></ul><h2 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h2><p><strong><em>MVCC</em></strong><br>写入流程中涉及到MVCC多版本协议控制协议，主要是hbase解决读写一致性的解决方案。MVCC变量是region级别的，每个region之间的mvcc是相互独立的。<br>Hbase每次Put都会指定一个唯一ID，该ID是Region级递增的。每个Region得MVCC维护两个point：</p><ul><li>readpoint指向已经写入完成的ID；</li><li>writepoint指向正在写入的ID</li></ul><p>没有数据写入的时候，二者的位置是一样的，当有数据写入的时候，readpoint要比writepoint小，只有readpoint之前的数据能够读取到（只要成功写入HLog和Memstore的数据能够读取到，无需写入HFile中）</p><p><strong><em>Nonce</em></strong><br>Nonce机制，在网络不稳定的情况下，当客户端发送rpc请求给regionserver服务器的时候，如果服务器处理时间过长导致超时，会出现服务器处理完毕，而无法及时通知客户端，导致客户端重新发送写入请求，即多次发送append，会造成数据多次添加。为了防止类似的现象，Hbase引入了Nonce机制，ServerNonceManager负责管理该RegionServer的nonce。<br>客户端每次申请以及重复申请会使用同一个nonce，发送到服务端之后，服务端会判断该nonce是否存在，如果不存在则可以放心执行，否则会根据当前的nonce进行相应的回调处理：</p><ul><li>如果nonce处于WAIT状态，表示该nonce所对应的操作正在执行中，需要等待其执行结束，根据其执行结果进行下一步操作；</li><li>如果nonce处于PROCEED状态，则表明该nonce所对应的操作已经执行过了，只不过是已失败告终，可以重新执行；</li><li>如果noce处于DONT_PROCEED状态，无需做处理。因此，当nonce进入DONT_PROCEED状态以后，所有通过它来执行的操作都会被忽视掉，从而防止操作冗余的发生。</li></ul><h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><p><strong>初始化ZooKeeper Session</strong><br>因为meta Region的路由信息存放于ZooKeeper中，在第一次从ZooKeeper中读取META Region的地址时，需要先初始化一个ZooKeeper Session。ZooKeeper Session是ZooKeeper Client与ZooKeeper Server端所建立的一个会话，通过心跳机制保持长连接。</p><p><strong>获取Region路由信息</strong><br>通过前面建立的连接，从ZooKeeper中读取meta Region所在的RegionServer，这个读取流程，当前已经是异步的。获取了meta Region的路由信息以后，再从meta Region中定位要读写的RowKey所关联的Region信息。如下图所示：<br><img src="/images/get-region.jpg"><br>因为每一个用户表Region都是一个RowKey Range，meta Region中记录了每一个用户表Region的路由以及状态信息，以RegionName(包含表名，Region StartKey，Region ID，副本ID等信息)作为RowKey。基于一条用户数据RowKey，快速查询该RowKey所属的Region的方法其实很简单：只需要基于表名以及该用户数据RowKey，构建一个虚拟的Region Key，然后通过Reverse Scan的方式，读到的第一条Region记录就是该数据所关联的Region。</p><p>Region只要不被迁移，那么获取的该Region的路由信息就是一直有效的，因此，HBase Client有一个Cache机制来缓存Region的路由信息，避免每次读写都要去访问ZooKeeper或者meta Region。</p><p><strong>客户端侧的数据分组“打包”</strong><br>如果这条待写入的数据采用的是Single Put的方式，那么，该步骤可以略过（事实上，单条Put操作的流程相对简单，就是先定位该RowKey所对应的Region以及RegionServer信息后，Client直接发送写请求到RegionServer侧即可）。</p><p>但如果这条数据被混杂在其它的数据列表中，采用Batch Put的方式，那么，客户端在将所有的数据写到对应的RegionServer之前，会先分组”打包”，流程如下：</p><ul><li>按Region分组：遍历每一条数据的RowKey，然后，依据meta表中记录的Region信息，确定每一条数据所属的Region。此步骤可以获取到Region到RowKey列表的映射关系。</li><li>按RegionServer”打包”：因为Region一定归属于某一个RegionServer（注：本文内容中如无特殊说明，都未考虑Region Replica特性），那属于同一个RegionServer的多个Regions的写入请求，被打包成一个MultiAction对象，这样可以一并发送到每一个RegionServer中。</li></ul><p><img src="/images/client-region-data-pack.jpg"></p><p><strong>Client发送写数据请求到RegionServer</strong><br>类似于Client发送建表到Master的流程，Client发送写数据请求到RegionServer，也是通过RPC的方式。只是，Client到Master以及Client到RegionServer，采用了不同的RPC服务接口。</p><p><strong>RegionServer端处理：Region分发</strong><br>RegionServer的RPC Server侧，接收到来自Client端的RPC请求以后，将该请求交给Handler线程处理。</p><p>如果是single put，则该步骤比较简单，因为在发送过来的请求参数中，已经携带了这条记录所关联的Region，那么直接将该请求转发给对应的Region即可。</p><p>如果是batch puts，则接收到的请求参数为混合了这个RegionServer所持有的多个Region的写入请求，每一个Region的写入请求都被包装成了一个RegionAction对象。RegionServer接收到请求以后，遍历所有的RegionAction，而后写入到每一个Region中，此过程是串行的。</p><p>从这里可以看出来，并不是一个batch越大越好，大的batch size甚至可能导致吞吐量下降。</p><p><strong>Region内部处理：写WAL</strong><br>HBase也采用了LSM-Tree的架构设计：LSM-Tree利用了传统机械硬盘的“顺序读写速度远高于随机读写速度”的特点。随机写入的数据，如果直接去改写每一个Region上的数据文件，那么吞吐量是非常差的。因此，每一个Region中随机写入的数据，都暂时先缓存在内存中(HBase中存放这部分内存数据的模块称之为MemStore)，为了保障数据可靠性，将这些随机写入的数据顺序写入到一个称之为WAL(Write-Ahead-Log)的日志文件中，WAL中的数据按时间顺序组织：<br><img src="/images/write-wal.jpg"><br>在HBase中，默认一个RegionServer只有一个可写的WAL文件。</p><p><strong>Region内部处理：写MemStore</strong><br>每一个Column Family，在Region内部被抽象为了一个HStore对象，而每一个HStore拥有自身的MemStore，用来缓存一批最近被随机写入的数据，这是LSM-Tree核心设计的一部分。</p><p>MemStore中用来存放所有的KeyValue的数据结构，核心是一个ConcurrentSkipListMap，我们知道，ConcurrentSkipListMap是Java的跳表实现，数据按照Key值有序存放，而且在高并发写入时，性能远高于ConcurrentHashMap。</p><h1 id="文件合并"><a href="#文件合并" class="headerlink" title="文件合并"></a>文件合并</h1><p>MemStore中的数据，达到一定的阈值，被Flush成HDFS中的HFile文件。</p><p>HBase Compaction可以将一些HFile文件合并成较大的HFile文件，也可以把所有的HFile文件合并成一个大的HFile文件，这个过程可以理解为：将多个HFile的“交错无序状态”，变成单个HFile的“有序状态”，降低读取时延。小范围的HFile文件合并，称之为Minor Compaction，一个列族中将所有的HFile文件合并，称之为Major Compaction。</p><p><img src="/images/FlushAndCompaction.png"></p><h2 id="Flush"><a href="#Flush" class="headerlink" title="Flush"></a>Flush</h2><p>MemStore由一个可写的Segment，以及一个或多个不可写的Segments构成。<br><img src="/images/InMemoryFlush.png"><br>MemStore中的数据先Flush成一个Immutable的Segment，多个Immutable Segments可以在内存中进行Compaction，当达到一定阈值以后才将内存中的数据持久化成HDFS中的HFile文件。</p><p><strong><em>为什么不能调小MemStore的大小，多次写入HFile，减小内存开销？</em></strong><br>如果MemStore中的数据被直接Flush成HFile，而多个HFile又被Compaction合并成了一个大HFile，随着一次次Compaction发生以后，一条数据往往被重写了多次，这带来显著的IO放大问题，另外，频繁的Compaction对IO资源的抢占，其实也是导致HBase查询时延大毛刺的罪魁祸首之一。</p><p><strong><em>为何不直接调大MemStore的大小,减少Compaction的次数</em></strong><br>ConcurrentSkipListMap在存储的数据量达到一定大小以后，写入性能将会出现显著的恶化。</p><h2 id="Compaction"><a href="#Compaction" class="headerlink" title="Compaction"></a>Compaction</h2><p><strong><em>目的</em></strong></p><ul><li>减少HFile文件数量，减少文件句柄数量，降低读取时延</li><li>Major Compaction可以帮助清理集群中不再需要的数据（过期数据，被标记删除的数据，版本数溢出的数据）</li></ul><p>如果有多个HFiles文件，如果想基于RowKey读取一行数据，则需要查看多个文件，因为不同的HFile文件的RowKey Range可能是重叠的，此时，Compaction对于降低读取时延是非常必要的。</p><p>很多HBase用户在集群中关闭了自动Major Compaction，为了降低Compaction对IO资源的抢占，但出于清理数据的需要，又不得不在一些非繁忙时段手动触发Major Compaction，这样既可以有效降低存储空间，也可以有效降低读取时延。</p><p><strong><em>弊端</em></strong><br>Compaction会导致写入放大<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在<span class="selector-tag">Facebook</span> <span class="selector-tag">Messages</span>系统中，业务读写比为99<span class="selector-pseudo">:1</span>，而最终反映到磁盘中，读写比却变为了36<span class="selector-pseudo">:64</span>。</span><br><span class="line"><span class="selector-tag">WAL</span>，<span class="selector-tag">HDFS</span> <span class="selector-tag">Replication</span>，<span class="selector-tag">Compaction</span>以及<span class="selector-tag">Caching</span>，共同导致了磁盘写<span class="selector-tag">IO</span>的显著放大。</span><br></pre></td></tr></table></figure></p><p><img src="/images/write-amplification.png"><br>随着不断的执行Minor Compaction以及Major Compaction，可以看到，这条数据被反复读取/写入了多次，这是导致写放大的一个关键原因，这里的写放大，涉及到网络IO与磁盘IO，因为数据在HDFS中默认有三个副本。</p><p>而关于如何合理的执行Compaction，我们需要结合业务数据特点，不断的权衡如下两点：</p><ul><li>不能太少：避免因文件数不断增多导致读取时延出现明显增大</li><li>不能太多：合理控制写入放大</li></ul><h1 id="读流程"><a href="#读流程" class="headerlink" title="读流程"></a>读流程</h1><h2 id="读取模式"><a href="#读取模式" class="headerlink" title="读取模式"></a>读取模式</h2><p><strong><em>Get</em></strong><br>Get是指基于确切的RowKey去获取一行数据，通常被称之为随机点查，这正是HBase所擅长的读取模式。<br>发送Get请求的接口获取到的一行记录，被封装成一个Result对象：</p><ul><li>关联一行数据，一定不可能包含跨行的结果</li><li>包含一个或多个被请求的列。有可能包含这行数据的所有列，也有可能仅包含部分列</li></ul><p>也定义了Batch Get的接口，这样可以在一次网络请求中同时获取多行数据。获取到的Result列表中的结果的顺序，与给定的RowKey顺序是一致的。</p><p><strong><em>Scan</em></strong><br>HBase中的数据表通过划分成一个个的Region来实现数据的分片，每一个Region关联一个RowKey的范围区间，而每一个Region中的数据，按RowKey的字典顺序进行组织。<br>正是基于这种设计，使得HBase能够轻松应对这类查询：”指定一个RowKey的范围区间，获取该区间的所有记录”， 这类查询在HBase被称之为Scan。</p><ul><li>如果StartRow未指定，则本次Scan将从表的第一行数据开始读取。</li><li>如果StopRow未指定，而且在不主动停止本次Scan操作的前提下，本次Scan将会一直读取到表的最后一行记录。</li><li>如果StartRow与StopRow都未指定，那本次Scan就是一次全表扫描操作。</li><li>同Get类似，Scan也可以主动指定返回的列族或列:</li></ul><h2 id="读取步骤"><a href="#读取步骤" class="headerlink" title="读取步骤"></a>读取步骤</h2><p><img src="/images/hbase-read-steps.png"></p><ul><li>Client先访问zookeeper，从meta表读取region的位置，然后读取meta表中的数据。meta中又存储了用户表的region信息；</li><li>根据namespace、表名和rowkey在meta表中找到对应的region信息；</li><li>找到这个region对应的regionserver；</li><li>查找对应的region；</li><li>先从MemStore找数据，如果没有，再到BlockCache里面读；</li><li>BlockCache还没有，再到StoreFile上读(为了读取的效率)；</li><li>如果是从StoreFile里面读取的数据，不是直接返回给客户端，而是先写入BlockCache，再返回给客户端。</li></ul><h1 id="HFile"><a href="#HFile" class="headerlink" title="HFile"></a>HFile</h1><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p><img src="/images/HFileV2.png"></p><p>从以上图片可以看出HFile主要分为四个部分：</p><ul><li>Scanned Block Section: 顺序扫描HFile，这个section的所有数据块都被读取，包括Leaf Index Block 和 Bloom Block</li><li>Non-Scanned Block Section: 顺序扫描HFile，这个section的数据不会被读取，主要包括元数据数据块等</li><li>Load-On-Open-Section: 这部分数据在HRegionServer启动时候，实例化HRegion并创建HStore的时候会将所有HFile的Load-On-Open-Section里的数据加载进内存，主要存放了Root Data Index, Meta Index，FileInfo以及BloomFilter的元数据等</li><li>Trailer: 这部分主要记录HFile的一些基本信息，各个部分的偏移量和寻址信息</li></ul><p><strong><em>Data Block</em></strong><br>Data Block是HBase中数据存储的最小单元，它存储的是用户KeyValue数据，数据结构如图所示：<br><img src="/images/data_block.png"></p><p>Key Type：存储Key类型Key Type，占1字节，Type分为Put、Delete、DeleteColumn、DeleteFamilyVersion、DeleteFamily等类型，标记这个KeyValue的类型</p><p><strong><em>Bloom Block</em></strong><br>BloomFilter对于HBase随机读的性能至关重要，他可以避免读取一些不会用到HFile,减少实际的IO次数，提高随机读的性能。<br>下图中集合S只有两个元素x和y，分别被3个hash函数进行映射，映射到的位置分别为（0，2，6）和（4，7，10），对应的位会被置为1:<br><img src="/images/BloomFilter.png"><br>现在假如要判断另一个元素是否是在此集合中，只需要被这3个hash函数进行映射，查看对应的位置是否有0存在，如果有的话，表示此元素肯定不存在于这个集合，否则有可能存在。下图所示就表示z肯定不在集合｛x，y｝中：<br><img src="/images/BloomFilter_z.png"></p><h2 id="文件特点"><a href="#文件特点" class="headerlink" title="文件特点"></a>文件特点</h2><p><strong><em>分层索引</em></strong><br>无论是Data Block Index还是Bloom Filter，都采用了分层索引的设计。</p><p>Data Block的索引，在HFile V2中做多可支持三层索引：最底层的Data Block Index称之为Leaf Index Block，可直接索引到Data Block；中间层称之为Intermediate Index Block，最上层称之为Root Data Index，Root Data index存放在一个称之为”Load-on-open Section“区域，Region Open时会被加载到内存中。基本的索引逻辑为：由Root Data Index索引到Intermediate Block Index，再由Intermediate Block Index索引到Leaf Index Block，最后由Leaf Index Block查找到对应的Data Block。在实际场景中，Intermediate Block Index基本上不会存在，因此，索引逻辑被简化为：由Root Data Index直接索引到Leaf Index Block，再由Leaf Index Block查找到的对应的Data Block。</p><p>Bloom Filter也被拆成了多个Bloom Block，在”Load-on-open Section”区域中，同样存放了所有Bloom Block的索引数据。</p><p><strong><em>交叉存放</em></strong><br>在”Scanned Block Section“区域，Data Block(存放用户数据KeyValue)、存放Data Block索引的Leaf Index Block(存放Data Block的索引)与Bloom Block(Bloom Filter数据)交叉存在。</p><p><strong><em>按需读取</em></strong><br>无论是Data Block的索引数据，还是Bloom Filter数据，都被拆成了多个Block，基于这样的设计，无论是索引数据，还是Bloom Filter，都可以按需读取，避免在Region Open阶段或读取阶段一次读入大量的数据，有效降低时延。</p><h2 id="数据索引"><a href="#数据索引" class="headerlink" title="数据索引"></a>数据索引</h2><p>Root Index Block、Leaf Index Block、Data Block所处的位置以及索引关系（忽略Bloom过滤器）：<br><img src="/images/RootBlockIndex-B.png"></p><p>混合了BloomFilter Block以后的HFile构成如下图所示：<br><img src="/images/index-BloomFilter.png"></p><h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><p><strong><em>Hbase宕机处理</em></strong></p><ul><li>Zookeeper会监控RegionServer的上下线情况，当ZK发现某个RegionServer宕机之后，会通知HMaster；</li><li>该RegionServer会停止对外提供服务，即该Region服务器下的region对外都无法访问；</li><li>HMaster会将该RegionServer所负责的region转移到其他RegionServer上，并且会对RegionServer上存在MemStore中未持久化到硬盘的数据进行恢复；</li><li>这个恢复操作工作由读取WAL文件完成：<ul><li>宕机发生时，读取该RegionServer所对应的路径下的WAL文件，然后根据不同的region切分成不同的recover.edits；</li><li>当region被分配到其他RegionServer时，RegionServer读取region时会进行是否存在recover.edits，如果有则进行恢复。</li></ul></li></ul><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><p><strong>什么样的数据适合用HBase来存储？</strong></p><ul><li>以实体为中心的数据<ul><li>自然人／账户／手机号／车辆相关数据</li><li>用户画像数据（含标签类数据）</li><li>图数据（关系类数据）<br>描述这些实体的，可以有基础属性信息、实体关系(图数据)、所发生的事件(如交易记录、车辆轨迹点)等等。</li></ul></li><li>以事件为中心的数据<ul><li>监控数据</li><li>时序数据</li><li>实时位置类数据</li><li>消息/日志类数据<br>上面所描述的这些数据，有的是结构化数据，有的是半结构化或非结构化数据。HBase的“稀疏矩阵”设计，使其应对非结构化数据存储时能够得心应手，但在我们的实际用户场景中，结构化数据存储依然占据了比较重的比例。由于HBase仅提供了基于RowKey的单维度索引能力，在应对一些具体的场景时，依然还需要基于HBase之上构建一些专业的能力。</li></ul></li></ul><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p><strong>关于行级别的ACID</strong></p><ul><li>如果多个线程写入同一行的不同列族，是不需要互斥的</li><li>多个线程写同一行的相同列族，也不需要互斥，即使是写相同的列，也完全可以通过HBase的MVCC机制来控制数据的一致性</li><li>CAS操作(如checkAndPut)或increment操作，依然需要独占的行锁</li></ul>]]></content>
    
    <summary type="html">
    
      Hbase
    
    </summary>
    
      <category term="大数据" scheme="http://langonggong.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Hbase" scheme="http://langonggong.com/tags/Hbase/"/>
    
      <category term="消息队列" scheme="http://langonggong.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>kafka</title>
    <link href="http://langonggong.com/2020/08/19/kafka/"/>
    <id>http://langonggong.com/2020/08/19/kafka/</id>
    <published>2020-08-19T12:34:51.000Z</published>
    <updated>2020-09-21T14:29:58.796Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>对比：<br><img src="/images/mq_diff.png"></p><h1 id="主要组件介绍"><a href="#主要组件介绍" class="headerlink" title="主要组件介绍"></a>主要组件介绍</h1><p><img src="/images/kafka-whole.png"></p><ul><li>生产者（producers）：将消息写入到kakfa服务端的称之为生产者。Producers将消息发布到指定的Topic中,同时Producer也能决定将此消息归属于哪个partition</li><li>代理（Broker）：已发布的消息保存在一组服务节点中，每个节点称之为一个broker，所有的broker组成一个kafka集群。</li><li>消费者（customers）：将消息从kakfa服务端取出使用的称之为消费者。如果所有的consumer都具有相同的group,这种情况和队列模式很像，消息将会在consumers之间负载均衡；如果所有的consumer都具有不同的group,那这就是”发布-订阅”，消息将会广播给所有的消费者。</li><li>主题（topic）：一个topic可以认为是一类消息。</li><li>分区（partition）：每个topic可以分为多个分区，存储到集群的不同节点，同时可以设置副本的个数来达到可容错的效果。</li><li><p>复制备份（replication）：kafka将每个partition数据复制到多个server上，任何一个partition有一个leader和多个follower(可以没有)，备份的个数可以通过broker配置文件来设定。<br>leader处理所有的read-write请求，follower需要和leader保持同步。Follower和consumer一样,消费消息并保存在本地日志中；leader负责跟踪所有的follower状态，如果follower”落后”太多或者失效，leader将会把它从replicas同步列表中删除。当所有的follower都将一条消息保存成功，此消息才被认为是”committed”，那么此时consumer才能消费它。即使只有一个replicas实例存活，仍然可以保证消息的正常发送和接收，只要zookeeper集群存活即可。(不同于其他分布式存储,比如hbase需要”多数派”存活才行)<br>当leader失效时，需在followers中选取出新的leader，可能此时follower落后于leader，因此需要选择一个”up-to-date”的follower。选择follower时需要兼顾一个问题,就是新leader上所已经承载的partition leader的个数,如果一个server上有过多的partition leader,意味着此server将承受着更多的IO压力.在选举新leader,需要考虑到”负载均衡”。</p></li><li><p>消费组（consumer group）<br>我们从Kafka中读取消息，并且进行检查，最后产生结果数据。我们可以创建一个消费者实例去做这件事情，但如果生产者写入消息的速度比消费者读取的速度快怎么办呢？这样随着时间增长，消息堆积越来越严重。对于这种场景，我们需要增加多个消费者来进行水平扩展。</p></li></ul><p><img src="/images/4-5consumer-group.png"></p><p>我们可以通过增加消费组的消费者来进行水平扩展提升消费能力，消费者的数量不应该比分区数多，因为多出来的消费者是空闲的。一个分区的数据只会被一个消费者消费。<br>当新的消费者加入消费组，它会消费一个或多个分区，而这些分区之前是由其他消费者负责的；另外，当消费者离开消费组（比如重启、宕机等）时，它所消费的分区会分配给其他消费者。这种现象称为重平衡（rebalance）。重平衡是Kafka一个很重要的性质，这个性质保证了高可用和水平扩展。不过也需要注意到，在重平衡期间，所有消费者都不能消费消息，因此会造成整个消费组短暂的不可用。而且，将分区进行重平衡也会导致原来的消费者状态过期，从而导致消费者需要重新更新状态，这段期间也会降低消费性能。</p><h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><p>Kafka这款分布式消息队列使用文件系统和操作系统的页缓存（page cache）分别存储和缓存消息，摒弃了Java的堆缓存机制，同时将随机写操作改为顺序写，再结合Zero-Copy的特性极大地改善了IO性能。而提起磁盘的文件系统，相信很多对硬盘存储了解的同学都知道：“一块SATA RAID-5阵列磁盘的线性写速度可以达到几百M/s，而随机写的速度只能是100多KB/s，线性写的速度是随机写的上千倍”，由此可以看出对磁盘写消息的速度快慢关键还是取决于我们的使用方法。鉴于此，Kafka的数据存储设计是建立在对文件进行追加的基础上实现的，因为是顺序追加，通过O(1)的磁盘数据结构即可提供消息的持久化，并且这种结构对于即使是数以TB级别的消息存储也能够保持长时间的稳定性能。在理想情况下，只要磁盘空间足够大就一直可以追加消息。此外，Kafka也能够通过配置让用户自己决定已经落盘的持久化消息保存的时间，提供消息处理更为灵活的方式。本文将主要介绍Kafka中数据的存储消息结构、存储方式以及如何通过offset来查找消息等内容。</p><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>Kafka中的消息是以主题（Topic）为基本单位进行组织的，各个主题之间相互独立。在这里主题只是一个逻辑上的抽象概念，而在实际数据文件的存储中，Kafka中的消息存储在物理上是以一个或多个分区（Partition）构成，每个分区对应本地磁盘上的一个文件夹，每个文件夹内包含了日志索引文件（“.index”和“.timeindex”）和日志数据文件（“.log”）两部分。分区数量可以在创建主题时指定，也可以在创建Topic后进行修改。（ps：Topic的Partition数量只能增加而不能减少，这点内容超出本篇幅的减少范围，大家可以先思考下）。<br>在Kafka中正是因为使用了分区（Partition）的设计模型，通过将主题（Topic）的消息打散到多个分区，并分布保存在不同的Kafka Broker节点上实现了消息处理的高吞吐量。其生产者和消费者都可以多线程地并行操作，而每个线程处理的是一个分区的数据。</p><p><img src="/images/anatomy-of-topic.png"></p><p>同时，Kafka为了实现集群的高可用性，在每个Partition中可以设置有一个或者多个副本（Replica），分区的副本分布在不同的Broker节点上。同时，从副本中会选出一个副本作为Leader，Leader副本负责与客户端进行读写操作。而其他副本作为Follower会从Leader副本上进行数据同步。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>在三台虚拟机上搭建完成Kafka的集群后（Kafka Broker节点数量为3个）</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./kafka-topics.sh</span> <span class="params">--create</span> <span class="params">--zookeeper</span> 10.154.0.73<span class="function">:2181</span> <span class="params">--replication-factor</span> 3 <span class="params">--partitions</span>  3 <span class="params">--topic</span> kafka-topic-01</span><br></pre></td></tr></table></figure><p>创建完主题、分区和副本后可以查到出主题的状态（该方式主要列举了主题所有分区对应的副本以及ISR列表信息）：</p><p><img src="/images/replication-state.png"></p><p>在每个分区目录下存在很多对应的日志数据文件和日志索引文件文件，具体如下：</p><p><img src="/images/kafka-files.png"></p><p>由上面可以看出，每个分区在物理上对应一个文件夹，分区的命名规则为主题名后接“—”连接符，之后再接分区编号，分区编号从0开始，编号的最大值为分区总数减1。每个分区又有1至多个副本，分区的副本分布在集群的不同代理上，以提高可用性。从存储的角度上来说，分区的每个副本在逻辑上可以抽象为一个日志（Log）对象，即分区副本与日志对象是相对应的。下图是在三个Kafka Broker节点所组成的集群中分区的主/备份副本的物理分布情况图：</p><h2 id="文件内容"><a href="#文件内容" class="headerlink" title="文件内容"></a>文件内容</h2><p>在Kafka中，每个Log对象又可以划分为多个LogSegment文件，每个LogSegment文件包括一个日志数据文件和两个索引文件（偏移量索引文件和消息时间戳索引文件）。其中，每个LogSegment中的日志数据文件大小均相等（该日志数据文件的大小可以通过在Kafka Broker的config/server.properties配置文件的中的“log.segment.bytes”进行设置，默认为1G大小（1073741824字节），在顺序写入消息时如果超出该设定的阈值，将会创建一组新的日志数据和索引文件）。<br>Kafka将日志文件封装成一个FileMessageSet对象，将偏移量索引文件和消息时间戳索引文件分别封装成OffsetIndex和TimerIndex对象。Log和LogSegment均为逻辑概念，Log是对副本在Broker上存储文件的抽象，而LogSegment是对副本存储下每个日志分段的抽象，日志与索引文件才与磁盘上的物理存储相对应；下图为Kafka日志存储结构中的对象之间的对应关系图：</p><p><img src="/images/kafka-file-content.png"></p><p>为了进一步查看“.index”偏移量索引文件、“.timeindex”时间戳索引文件和“.log”日志数据文件，可以执行下面的命令将二进制分段的索引和日志数据文件内容转换为字符型文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、执行下面命令即可将日志数据文件内容dump出来</span></span><br><span class="line"><span class="string">./kafka-run-class.sh</span> <span class="string">kafka.tools.DumpLogSegments</span> <span class="bullet">--files</span> <span class="string">/apps/svr/Kafka/kafkalogs/kafka-topic-01-0/00000000000022372103.log</span> <span class="bullet">--print-data-log</span> <span class="string">&gt; 00000000000022372103_txt.log</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#2、dump出来的具体日志数据内容</span></span><br><span class="line"><span class="string">Dumping /apps/svr/Kafka/kafkalogs/kafka-topic-01-0/00000000000022372103.log</span></span><br><span class="line"><span class="string">Starting offset: 22372103</span></span><br><span class="line"><span class="string"></span><span class="attr">offset:</span> <span class="number">22372103</span> <span class="attr">position:</span> <span class="number">0</span> <span class="attr">CreateTime:</span> <span class="number">1532433067157</span> <span class="attr">isvalid:</span> <span class="literal">true</span> <span class="attr">keysize:</span> <span class="number">4</span> <span class="attr">valuesize:</span> <span class="number">36</span> <span class="attr">magic:</span> <span class="number">2</span> <span class="attr">compresscodec:</span> <span class="string">NONE</span> <span class="attr">producerId:</span> <span class="bullet">-1</span> <span class="attr">producerEpoch:</span> <span class="bullet">-1</span> <span class="attr">sequence:</span> <span class="bullet">-1</span> <span class="attr">isTransactional:</span> <span class="literal">false</span> <span class="attr">headerKeys:</span> <span class="string">[]</span> <span class="attr">key:</span> <span class="number">1</span> <span class="attr">payload:</span> <span class="number">5</span><span class="string">d2697c5-d04a-4018-941d-881ac72ed9fd</span></span><br><span class="line"><span class="attr">offset:</span> <span class="number">22372104</span> <span class="attr">position:</span> <span class="number">0</span> <span class="attr">CreateTime:</span> <span class="number">1532433067159</span> <span class="attr">isvalid:</span> <span class="literal">true</span> <span class="attr">keysize:</span> <span class="number">4</span> <span class="attr">valuesize:</span> <span class="number">36</span> <span class="attr">magic:</span> <span class="number">2</span> <span class="attr">compresscodec:</span> <span class="string">NONE</span> <span class="attr">producerId:</span> <span class="bullet">-1</span> <span class="attr">producerEpoch:</span> <span class="bullet">-1</span> <span class="attr">sequence:</span> <span class="bullet">-1</span> <span class="attr">isTransactional:</span> <span class="literal">false</span> <span class="attr">headerKeys:</span> <span class="string">[]</span> <span class="attr">key:</span> <span class="number">1</span> <span class="attr">payload:</span> <span class="number">0</span><span class="string">ecaae7d-aba5-4dd5-90df-597c8b426b47</span></span><br><span class="line"><span class="attr">offset:</span> <span class="number">22372105</span> <span class="attr">position:</span> <span class="number">0</span> <span class="attr">CreateTime:</span> <span class="number">1532433067159</span> <span class="attr">isvalid:</span> <span class="literal">true</span> <span class="attr">keysize:</span> <span class="number">4</span> <span class="attr">valuesize:</span> <span class="number">36</span> <span class="attr">magic:</span> <span class="number">2</span> <span class="attr">compresscodec:</span> <span class="string">NONE</span> <span class="attr">producerId:</span> <span class="bullet">-1</span> <span class="attr">producerEpoch:</span> <span class="bullet">-1</span> <span class="attr">sequence:</span> <span class="bullet">-1</span> <span class="attr">isTransactional:</span> <span class="literal">false</span> <span class="attr">headerKeys:</span> <span class="string">[]</span> <span class="attr">key:</span> <span class="number">1</span> <span class="attr">payload:</span> <span class="number">87709</span><span class="string">dd9-596b-4cf4-80fa-d1609d1f2087</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">offset:</span> <span class="number">22372444</span> <span class="attr">position:</span> <span class="number">16365</span> <span class="attr">CreateTime:</span> <span class="number">1532433067166</span> <span class="attr">isvalid:</span> <span class="literal">true</span> <span class="attr">keysize:</span> <span class="number">4</span> <span class="attr">valuesize:</span> <span class="number">36</span> <span class="attr">magic:</span> <span class="number">2</span> <span class="attr">compresscodec:</span> <span class="string">NONE</span> <span class="attr">producerId:</span> <span class="bullet">-1</span> <span class="attr">producerEpoch:</span> <span class="bullet">-1</span> <span class="attr">sequence:</span> <span class="bullet">-1</span> <span class="attr">isTransactional:</span> <span class="literal">false</span> <span class="attr">headerKeys:</span> <span class="string">[]</span> <span class="attr">key:</span> <span class="number">1</span> <span class="attr">payload:</span> <span class="number">8</span><span class="string">d52ec65-88cf-4afd-adf1-e940ed9a8ff9</span></span><br><span class="line"><span class="attr">offset:</span> <span class="number">22372445</span> <span class="attr">position:</span> <span class="number">16365</span> <span class="attr">CreateTime:</span> <span class="number">1532433067168</span> <span class="attr">isvalid:</span> <span class="literal">true</span> <span class="attr">keysize:</span> <span class="number">4</span> <span class="attr">valuesize:</span> <span class="number">36</span> <span class="attr">magic:</span> <span class="number">2</span> <span class="attr">compresscodec:</span> <span class="string">NONE</span> <span class="attr">producerId:</span> <span class="bullet">-1</span> <span class="attr">producerEpoch:</span> <span class="bullet">-1</span> <span class="attr">sequence:</span> <span class="bullet">-1</span> <span class="attr">isTransactional:</span> <span class="literal">false</span> <span class="attr">headerKeys:</span> <span class="string">[]</span> <span class="attr">key:</span> <span class="number">1</span> <span class="attr">payload:</span> <span class="number">5</span><span class="string">f5f6646-d0f5-4ad1-a257-4e3c38c74a92</span></span><br><span class="line"><span class="attr">offset:</span> <span class="number">22372446</span> <span class="attr">position:</span> <span class="number">16365</span> <span class="attr">CreateTime:</span> <span class="number">1532433067168</span> <span class="attr">isvalid:</span> <span class="literal">true</span> <span class="attr">keysize:</span> <span class="number">4</span> <span class="attr">valuesize:</span> <span class="number">36</span> <span class="attr">magic:</span> <span class="number">2</span> <span class="attr">compresscodec:</span> <span class="string">NONE</span> <span class="attr">producerId:</span> <span class="bullet">-1</span> <span class="attr">producerEpoch:</span> <span class="bullet">-1</span> <span class="attr">sequence:</span> <span class="bullet">-1</span> <span class="attr">isTransactional:</span> <span class="literal">false</span> <span class="attr">headerKeys:</span> <span class="string">[]</span> <span class="attr">key:</span> <span class="number">1</span> <span class="attr">payload:</span> <span class="number">51</span><span class="string">dd1da4-053e-4507-9ef8-68ef09d18cca</span></span><br><span class="line"><span class="attr">offset:</span> <span class="number">22372447</span> <span class="attr">position:</span> <span class="number">16365</span> <span class="attr">CreateTime:</span> <span class="number">1532433067168</span> <span class="attr">isvalid:</span> <span class="literal">true</span> <span class="attr">keysize:</span> <span class="number">4</span> <span class="attr">valuesize:</span> <span class="number">36</span> <span class="attr">magic:</span> <span class="number">2</span> <span class="attr">compresscodec:</span> <span class="string">NONE</span> <span class="attr">producerId:</span> <span class="bullet">-1</span> <span class="attr">producerEpoch:</span> <span class="bullet">-1</span> <span class="attr">sequence:</span> <span class="bullet">-1</span> <span class="attr">isTransactional:</span> <span class="literal">false</span> <span class="attr">headerKeys:</span> <span class="string">[]</span> <span class="attr">key:</span> <span class="number">1</span> <span class="attr">payload:</span> <span class="number">80</span><span class="string">d50a8e-0098-4748-8171-fd22d6af3c9b</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">offset:</span> <span class="number">22372785</span> <span class="attr">position:</span> <span class="number">32730</span> <span class="attr">CreateTime:</span> <span class="number">1532433067174</span> <span class="attr">isvalid:</span> <span class="literal">true</span> <span class="attr">keysize:</span> <span class="number">4</span> <span class="attr">valuesize:</span> <span class="number">36</span> <span class="attr">magic:</span> <span class="number">2</span> <span class="attr">compresscodec:</span> <span class="string">NONE</span> <span class="attr">producerId:</span> <span class="bullet">-1</span> <span class="attr">producerEpoch:</span> <span class="bullet">-1</span> <span class="attr">sequence:</span> <span class="bullet">-1</span> <span class="attr">isTransactional:</span> <span class="literal">false</span> <span class="attr">headerKeys:</span> <span class="string">[]</span> <span class="attr">key:</span> <span class="number">1</span> <span class="attr">payload:</span> <span class="string">db80eb79-8250-42e2-ad26-1b6cfccb5c00</span></span><br><span class="line"><span class="attr">offset:</span> <span class="number">22372786</span> <span class="attr">position:</span> <span class="number">32730</span> <span class="attr">CreateTime:</span> <span class="number">1532433067176</span> <span class="attr">isvalid:</span> <span class="literal">true</span> <span class="attr">keysize:</span> <span class="number">4</span> <span class="attr">valuesize:</span> <span class="number">36</span> <span class="attr">magic:</span> <span class="number">2</span> <span class="attr">compresscodec:</span> <span class="string">NONE</span> <span class="attr">producerId:</span> <span class="bullet">-1</span> <span class="attr">producerEpoch:</span> <span class="bullet">-1</span> <span class="attr">sequence:</span> <span class="bullet">-1</span> <span class="attr">isTransactional:</span> <span class="literal">false</span> <span class="attr">headerKeys:</span> <span class="string">[]</span> <span class="attr">key:</span> <span class="number">1</span> <span class="attr">payload:</span> <span class="number">51</span><span class="string">d95ab0-ab0d-4530-b1d1-05eeb9a6ff00</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="comment">#3、同样地，dump出来的具体偏移量索引内容</span></span><br><span class="line"><span class="string">Dumping</span> <span class="string">/apps/svr/Kafka/kafkalogs/kafka-topic-01-0/00000000000022372103.index</span></span><br><span class="line"><span class="attr">offset:</span> <span class="number">22372444</span> <span class="attr">position:</span> <span class="number">16365</span></span><br><span class="line"><span class="attr">offset:</span> <span class="number">22372785</span> <span class="attr">position:</span> <span class="number">32730</span></span><br><span class="line"><span class="attr">offset:</span> <span class="number">22373467</span> <span class="attr">position:</span> <span class="number">65460</span></span><br><span class="line"><span class="attr">offset:</span> <span class="number">22373808</span> <span class="attr">position:</span> <span class="number">81825</span></span><br><span class="line"><span class="attr">offset:</span> <span class="number">22374149</span> <span class="attr">position:</span> <span class="number">98190</span></span><br><span class="line"><span class="attr">offset:</span> <span class="number">22374490</span> <span class="attr">position:</span> <span class="number">114555</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="comment">#4、dump出来的时间戳索引文件内容</span></span><br><span class="line"><span class="string">Dumping</span> <span class="string">/apps/svr/Kafka/kafkalogs/kafka-topic-01-0/00000000000022372103.timeindex</span></span><br><span class="line"><span class="attr">timestamp:</span> <span class="number">1532433067174</span> <span class="attr">offset:</span> <span class="number">22372784</span></span><br><span class="line"><span class="attr">timestamp:</span> <span class="number">1532433067191</span> <span class="attr">offset:</span> <span class="number">22373466</span></span><br><span class="line"><span class="attr">timestamp:</span> <span class="number">1532433067206</span> <span class="attr">offset:</span> <span class="number">22373807</span></span><br><span class="line"><span class="attr">timestamp:</span> <span class="number">1532433067214</span> <span class="attr">offset:</span> <span class="number">22374148</span></span><br><span class="line"><span class="attr">timestamp:</span> <span class="number">1532433067222</span> <span class="attr">offset:</span> <span class="number">22374489</span></span><br><span class="line"><span class="attr">timestamp:</span> <span class="number">1532433067230</span> <span class="attr">offset:</span> <span class="number">22374830</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure><p>由上面dump出来的偏移量索引文件和日志数据文件的具体内容可以分析出来，偏移量索引文件中存储着大量的索引元数据，日志数据文件中存储着大量消息结构中的各个字段内容和消息体本身的值。索引文件中的元数据postion字段指向对应日志数据文件中message的实际位置（即为物理偏移地址）。<br>下面的表格先列举了Kakfa消息体结构中几个主要字段的说明：</p><p><img src="/images/kafka-message-schema.png"></p><h3 id="日志数据文件"><a href="#日志数据文件" class="headerlink" title="日志数据文件"></a>日志数据文件</h3><p>Kafka将生产者发送给它的消息数据内容保存至日志数据文件中，该文件以该段的基准偏移量左补齐0命名，文件后缀为“.log”。分区中的每条message由offset来表示它在这个分区中的偏移量，这个offset并不是该Message在分区中实际存储位置，而是逻辑上的一个值（Kafka中用8字节长度来记录这个偏移量），但它却唯一确定了分区中一条Message的逻辑位置，同一个分区下的消息偏移量按照顺序递增（这个可以类比下数据库的自增主键）。另外，从dump出来的日志数据文件的字符值中可以看到消息体的各个字段的内容值。</p><h3 id="偏移量索引文件"><a href="#偏移量索引文件" class="headerlink" title="偏移量索引文件"></a>偏移量索引文件</h3><p>如果消息的消费者每次fetch都需要从1G大小（默认值）的日志数据文件中来查找对应偏移量的消息，那么效率一定非常低，在定位到分段后还需要顺序比对才能找到。Kafka在设计数据存储时，为了提高查找消息的效率，故而为分段后的每个日志数据文件均使用稀疏索引的方式建立索引，这样子既节省空间又能通过索引快速定位到日志数据文件中的消息内容。偏移量索引文件和数据文件一样也同样也以该段的基准偏移量左补齐0命名，文件后缀为“.index”。<br>从上面dump出来的偏移量索引内容可以看出，索引条目用于将偏移量映射成为消息在日志数据文件中的实际物理位置，每个索引条目由offset和position组成，每个索引条目可以唯一确定在各个分区数据文件的一条消息。其中，Kafka采用稀疏索引存储的方式，每隔一定的字节数建立了一条索引，可以通过“index.interval.bytes”设置索引的跨度；<br>有了偏移量索引文件，通过它，Kafka就能够根据指定的偏移量快速定位到消息的实际物理位置。具体的做法是，根据指定的偏移量，使用二分法查询定位出该偏移量对应的消息所在的分段索引文件和日志数据文件。然后通过二分查找法，继续查找出小于等于指定偏移量的最大偏移量，同时也得出了对应的position（实际物理位置），根据该物理位置在分段的日志数据文件中顺序扫描查找偏移量与指定偏移量相等的消息。下面是Kafka中分段的日志数据文件和偏移量索引文件的对应映射关系图（其中也说明了如何按照起始偏移量来定位到日志数据文件中的具体消息）。</p><p><img src="/images/kafka-index-data-file.png"></p><h3 id="时间戳索引文件"><a href="#时间戳索引文件" class="headerlink" title="时间戳索引文件"></a>时间戳索引文件</h3><p>从上面一节的分区目录中，我们还可以看到存在一些以“.timeindex”的时间戳索引文件。这种类型的索引文件是Kafka从0.10.1.1版本开始引入的的一个基于时间戳的索引文件，它们的命名方式与对应的日志数据文件和偏移量索引文件名基本一样，唯一不同的就是后缀名。从上面dump出来的该种类型的时间戳索引文件的内容来看，每一条索引条目都对应了一个8字节长度的时间戳字段和一个4字节长度的偏移量字段，其中时间戳字段记录的是该LogSegment到目前为止的最大时间戳，后面对应的偏移量即为此时插入新消息的偏移量。<br>另外，时间戳索引文件的时间戳类型与日志数据文件中的时间类型是一致的，索引条目中的时间戳值及偏移量与日志数据文件中对应的字段值相同（ps：Kafka也提供了通过时间戳索引来访问消息的方法）。</p><h1 id="offset管理"><a href="#offset管理" class="headerlink" title="offset管理"></a>offset管理</h1><p>Kafka中的每个partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到partition中。partition中的每个消息都有一个连续的序号，用于partition唯一标识一条消息。<br>Offset记录着下一条将要发送给Consumer的消息的序号。<br>Offset从语义上来看拥有两种：Current Offset和Committed Offset。</p><p><strong>Current Offset</strong><br>Current Offset保存在Consumer客户端中，它表示Consumer希望收到的下一条消息的序号。它仅仅在poll()方法中使用。例如，Consumer第一次调用poll()方法后收到了20条消息，那么Current Offset就被设置为20。这样Consumer下一次调用poll()方法时，Kafka就知道应该从序号为21的消息开始读取。这样就能够保证每次Consumer poll消息时，都能够收到不重复的消息。</p><p><strong>Committed Offset</strong><br>Committed Offset保存在Broker上，它表示Consumer已经确认消费过的消息的序号。主要通过<br>commitSync和commitAsync<br>API来操作。举个例子，Consumer通过poll() 方法收到20条消息后，此时Current Offset就是20，经过一系列的逻辑处理后，并没有调用consumer.commitAsync()<br>或consumer.commitSync()来提交Committed Offset，那么此时Committed Offset依旧是0。<br>Committed Offset主要用于Consumer Rebalance。在Consumer Rebalance的过程中，一个partition被分配给了一个Consumer，那么这个Consumer该从什么位置开始消费消息呢？答案就是Committed Offset。另外，如果一个Consumer消费了5条消息（poll并且成功commitSync）之后宕机了，重新启动之后它仍然能够从第6条消息开始消费，因为Committed Offset已经被Kafka记录为5。<br>总结一下，Current Offset是针对Consumer的poll过程的，它可以保证每次poll都返回不重复的消息；而Committed Offset是用于Consumer Rebalance过程的，它能够保证新的Consumer能够从正确的位置开始消费一个partition，从而避免重复消费。<br>在Kafka 0.9前，Committed Offset信息保存在zookeeper的[consumers/{group}/offsets/{topic}/{partition}]目录中（zookeeper其实并不适合进行大批量的读写操作，尤其是写操作）。而在0.9之后，所有的offset信息都保存在了Broker上的一个名为__consumer_offsets的topic中。<br>Kafka集群中offset的管理都是由Group Coordinator中的Offset Manager完成的。</p><h2 id="Group-Coordinator"><a href="#Group-Coordinator" class="headerlink" title="Group Coordinator"></a>Group Coordinator</h2><p>Group Coordinator是运行在Kafka集群中每一个Broker内的一个进程。它主要负责Consumer Group的管理，Offset位移管理以及Consumer Rebalance。<br>对于每一个Consumer Group，Group Coordinator都会存储以下信息：</p><ul><li>订阅的topics列表</li><li>Consumer Group配置信息，包括session timeout等</li><li>组中每个Consumer的元数据。包括主机名，consumer id</li><li>每个Group正在消费的topic partition的当前offsets</li><li>artition的ownership元数据，包括consumer消费的partitions映射关系</li></ul><h2 id="Offset存储模型"><a href="#Offset存储模型" class="headerlink" title="Offset存储模型"></a>Offset存储模型</h2><p>由于一个partition只能固定的交给一个消费者组中的一个消费者消费，因此Kafka保存offset时并不直接为每个消费者保存，而是以groupid-topic-partition -&gt; offset的方式保存。<br>Kafka在保存Offset的时候，实际上是将Consumer Group和partition对应的offset以消息的方式保存在<strong>consumers_offsets这个topic中。</strong>consumers_offsets默认拥有50个partition，可以通过</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Math</span><span class="selector-class">.abs</span>(<span class="selector-tag">groupId</span><span class="selector-class">.hashCode</span>() % <span class="selector-tag">offsets</span><span class="selector-class">.topic</span><span class="selector-class">.num</span><span class="selector-class">.partitions</span>)</span><br></pre></td></tr></table></figure><p>的方式来查询某个Consumer Group的offset信息保存在<strong>consumers_offsets的哪个partition中。下图展示了</strong>consumers_offsets中保存的offset消息的格式：</p><p><img src="/images/offset_content.png"></p><h2 id="Offset查询"><a href="#Offset查询" class="headerlink" title="Offset查询"></a>Offset查询</h2><p>前面我们已经描述过offset的存储模型，它是按照groupid-topic-partition -&gt; offset的方式存储的。然而Kafka只提供了根据offset读取消息的模型，并不支持根据key读取消息的方式。那么Kafka是如何支持Offset的查询呢？<br>答案就是Offsets Cache！！</p><p><img src="/images/offset_cache.png"></p><p>如图所示，Consumer提交offset时，Kafka Offset Manager会首先追加一条条新的commit消息到<strong>consumers_offsets topic中，然后更新对应的缓存。读取offset时从缓存中读取，而不是直接读取</strong>consumers_offsets这个topic。</p><h2 id="Log-Compaction"><a href="#Log-Compaction" class="headerlink" title="Log Compaction"></a>Log Compaction</h2><p>我们已经知道，Kafka使用groupid-topic-partition -&gt; offset*的消息格式，将Offset信息存储在__consumers_offsets topic中。请看下面一个例子：</p><p><img src="/images/log_compaction.png"></p><p>如图，对于audit-consumer这个Consumer Group来说，上面的存储了两条具有相同key的记录：PageViewEvent-0 -&gt; 240和PageViewEvent-0 -&gt; 323。事实上，这就是一种无用的冗余。因为对于一个partition来说，我们实际上只需要它当前最新的Offsets。因此这条旧的PageViewEvent-0 -&gt; 240记录事实上是无用的。<br>为了消除这样的过期数据，Kafka为__consumers_offsets topic设置了Log Compaction功能。Log Compaction意味着对于有相同key的的不同value值，只保留最后一个版本。如果应用只关心key对应的最新value值，可以开启Kafka的Log Compaction功能，Kafka会定期将相同key的消息进行合并，只保留最新的value值。<br>这张图片生动的阐述了Log Compaction的过程：</p><p><img src="/images/log_ompaction_guocheng.png"></p><p>下图阐释了__consumers_offsets topic中的数据在Log Compaction下的变化：</p><p><img src="/images/log_ompaction_shuju.png"></p><p>在新建topic时添加</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log<span class="selector-class">.cleanup</span><span class="selector-class">.policy</span>=compact</span><br></pre></td></tr></table></figure><p>参数就可以为topic开启Log Compaction功能。</p><h2 id="auto-offset-reset"><a href="#auto-offset-reset" class="headerlink" title="auto.offset.reset"></a>auto.offset.reset</h2><p>表示如果Kafka中没有存储对应的offset信息的话（有可能offset信息被删除），消费者从何处开始消费消息。它拥有三个可选值：</p><ul><li>earliest：从最早的offset开始消费</li><li>latest：从最后的offset开始消费</li><li>none：直接抛出exception给consumer</li></ul><p>看一下下面两个场景：</p><ul><li>Consumer消费了5条消息后宕机了，重启之后它读取到对应的partition的Committed Offset为5，因此会直接从第6条消息开始读取。此时完全依赖于Committed Offset机制，和auto.offset.reset配置完全无关。</li><li>新建了一个新的Group，并添加了一个Consumer，它订阅了一个已经存在的Topic。此时Kafka中还没有这个Consumer相应的Offset信息，因此此时Kafka就会根据auto.offset.reset配置来决定这个Consumer从何处开始消费消息。</li></ul><h1 id="消息语义"><a href="#消息语义" class="headerlink" title="消息语义"></a>消息语义</h1><p>现在我们对于 producer 和 consumer 的工作原理已将有了一点了解，让我们接着讨论 Kafka 在 producer 和 consumer 之间提供的语义保证。显然，Kafka可以提供的消息交付语义保证有多种：</p><ul><li>At most once——消息可能会丢失但绝不重传。</li><li>At least once——消息可以重传但绝不丢失。</li><li>Exactly once——这正是人们想要的, 每一条消息只被传递一次.</li></ul><p>值得注意的是，这个问题被分成了两部分：发布消息的持久性保证和消费消息的保证。<br>很多系统声称提供了“Exactly once”的消息交付语义, 然而阅读它们的细则很重要, 因为这些声称大多数都是误导性的 (即它们没有考虑 consumer 或 producer 可能失败的情况，以及存在多个 consumer 进行处理的情况，或者写入磁盘的数据可能丢失的情况。).</p><h2 id="producer语义"><a href="#producer语义" class="headerlink" title="producer语义"></a>producer语义</h2><p>在 0.11.0.0 之前的版本中, 如果 producer 没有收到表明消息已经被提交的响应, 那么 producer 除了将消息重传之外别无选择。 这里提供的是 at-least-once 的消息交付语义，因为如果最初的请求事实上执行成功了，那么重传过程中该消息就会被再次写入到 log 当中。 从 0.11.0.0 版本开始，Kafka producer新增了幂等性的传递选项，该选项保证重传不会在 log 中产生重复条目。 为实现这个目的, broker 给每个 producer 都分配了一个 ID ，并且 producer 给每条被发送的消息分配了一个序列号来避免产生重复的消息。 同样也是从 0.11.0.0 版本开始, producer 新增了使用类似事务性的语义将消息发送到多个 topic partition 的功能： 也就是说，要么所有的消息都被成功的写入到了 log，要么一个都没写进去。这种语义的主要应用场景就是 Kafka topic 之间的 exactly-once 的数据传递(如下所述)。<br>并非所有使用场景都需要这么强的保证。对于延迟敏感的应用场景，我们允许生产者指定它需要的持久性级别。如果 producer 指定了它想要等待消息被提交，则可以使用10ms的量级。然而， producer 也可以指定它想要完全异步地执行发送，或者它只想等待直到 leader 节点拥有该消息（follower 节点有没有无所谓）。</p><h2 id="consumer语义"><a href="#consumer语义" class="headerlink" title="consumer语义"></a>consumer语义</h2><p>现在让我们从 consumer 的视角来描述语义。 所有的副本都有相同的 log 和相同的 offset。consumer 负责控制它在 log 中的位置。如果 consumer 永远不崩溃，那么它可以将这个位置信息只存储在内存中。但如果 consumer 发生了故障，我们希望这个 topic partition 被另一个进程接管， 那么新进程需要选择一个合适的位置开始进行处理。假设 consumer 要读取一些消息——它有几个处理消息和更新位置的选项。</p><ul><li>Consumer 可以先读取消息，然后将它的位置保存到 log 中，最后再对消息进行处理。在这种情况下，消费者进程可能会在保存其位置之后，带还没有保存消息处理的输出之前发生崩溃。而在这种情况下，即使在此位置之前的一些消息没有被处理，接管处理的进程将从保存的位置开始。在 consumer 发生故障的情况下，这对应于“at-most-once”的语义，可能会有消息得不到处理。</li><li>Consumer 可以先读取消息，然后处理消息，最后再保存它的位置。在这种情况下，消费者进程可能会在处理了消息之后，但还没有保存位置之前发生崩溃。而在这种情况下，当新的进程接管后，它最初收到的一部分消息都已经被处理过了。在 consumer 发生故障的情况下，这对应于“at-least-once”的语义。 在许多应用场景中，消息都设有一个主键，所以更新操作是幂等的（相同的消息接收两次时，第二次写入会覆盖掉第一次写入的记录）。</li></ul><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="pagecache"><a href="#pagecache" class="headerlink" title="pagecache"></a>pagecache</h2><p>关于磁盘性能的关键事实是，磁盘的吞吐量和过去十年里磁盘的寻址延迟不同。因此，使用6个7200rpm、SATA接口、RAID-5的磁盘阵列在JBOD配置下的顺序写入的性能约为600MB/秒，但随机写入的性能仅约为100k/秒，相差6000倍以上。因为线性的读取和写入是磁盘使用模式中最有规律的，并且由操作系统进行了大量的优化。现代操作系统提供了 read-ahead 和 write-behind 技术，read-ahead 是以大的 data block 为单位预先读取数据，而 write-behind 是将多个小型的逻辑写合并成一次大型的物理磁盘写入。<br>为了弥补这种性能差异，现代操作系统在越来越注重使用内存对磁盘进行 cache。现代操作系统主动将所有空闲内存用作 disk caching，代价是在内存回收时性能会有所降低。所有对磁盘的读写操作都会通过这个统一的 cache。如果不使用直接I/O，该功能不能轻易关闭。因此即使进程维护了 in-process cache，该数据也可能会被复制到操作系统的 pagecache 中，事实上所有内容都被存储了两份。<br>此外，Kafka 建立在 JVM 之上，任何了解 Java 内存使用的人都知道两点：</p><ul><li>对象的内存开销非常高，通常是所存储的数据的两倍(甚至更多)。</li><li>随着堆中数据的增加，Java 的垃圾回收变得越来越复杂和缓慢。</li></ul><p>受这些因素影响，相比于维护 in-memory cache 或者其他结构，使用文件系统和 pagecache 显得更有优势—我们可以通过自动访问所有空闲内存将可用缓存的容量至少翻倍，并且通过存储紧凑的字节结构而不是独立的对象，有望将缓存容量再翻一番。 这样使得32GB的机器缓存容量可以达到28-30GB,并且不会产生额外的 GC 负担。此外，即使服务重新启动，缓存依旧可用，而 in-process cache 则需要在内存中重建(重建一个10GB的缓存可能需要10分钟)，否则进程就要从 cold cache 的状态开始(这意味着进程最初的性能表现十分糟糕)。 这同时也极大的简化了代码，因为所有保持 cache 和文件系统之间一致性的逻辑现在都被放到了 OS 中，这样做比一次性的进程内缓存更准确、更高效。如果你的磁盘使用更倾向于顺序读取，那么 read-ahead 可以有效的使用每次从磁盘中读取到的有用数据预先填充 cache。<br>这里给出了一个非常简单的设计：相比于维护尽可能多的 in-memory cache，并且在空间不足的时候匆忙将数据 flush 到文件系统，我们把这个过程倒过来。所有数据一开始就被写入到文件系统的持久化日志中，而不用在 cache 空间不足的时候 flush 到磁盘。实际上，这表明数据被转移到了内核的 pagecache 中。</p><h2 id="顺序读写"><a href="#顺序读写" class="headerlink" title="顺序读写"></a>顺序读写</h2><p>消息系统使用的持久化数据结构通常是和 BTree 相关联的消费者队列或者其他用于存储消息源数据的通用随机访问数据结构。BTree 是最通用的数据结构，可以在消息系统能够支持各种事务性和非事务性语义。 虽然 BTree 的操作复杂度是 O(log N)，但成本也相当高。通常我们认为 O(log N) 基本等同于常数时间，但这条在磁盘操作中不成立。磁盘寻址是每10ms一跳，并且每个磁盘同时只能执行一次寻址，因此并行性受到了限制。 因此即使是少量的磁盘寻址也会很高的开销。由于存储系统将非常快的cache操作和非常慢的物理磁盘操作混合在一起，当数据随着 fixed cache 增加时，可以看到树的性能通常是非线性的——比如数据翻倍时性能下降不只两倍。<br>所以直观来看，持久化队列可以建立在简单的读取和向文件后追加两种操作之上，这和日志解决方案相同。这种架构的优点在于所有的操作复杂度都是O(1)，而且读操作不会阻塞写操作，读操作之间也不会互相影响。这有着明显的性能优势，由于性能和数据大小完全分离开来——服务器现在可以充分利用大量廉价、低转速的1+TB SATA硬盘。 虽然这些硬盘的寻址性能很差，但他们在大规模读写方面的性能是可以接受的，而且价格是原来的三分之一、容量是原来的三倍。<br>在不产生任何性能损失的情况下能够访问几乎无限的硬盘空间，这意味着我们可以提供一些其它消息系统不常见的特性。例如：在 Kafka 中，我们可以让消息保留相对较长的一段时间(比如一周)，而不是试图在被消费后立即删除。正如我们后面将要提到的，这给消费者带来了很大的灵活性。</p><h2 id="批量处理"><a href="#批量处理" class="headerlink" title="批量处理"></a>批量处理</h2><p>小型的 I/O 操作发生在客户端和服务端之间以及服务端自身的持久化操作中。<br>为了避免这种情况，我们的协议是建立在一个 “消息块” 的抽象基础上，合理将消息分组。 这使得网络请求将多个消息打包成一组，而不是每次发送一条消息，从而使整组消息分担网络中往返的开销。Consumer 每次获取多个大型有序的消息块，并由服务端 依次将消息块一次加载到它的日志中。<br>这个简单的优化对速度有着数量级的提升。批处理允许更大的网络数据包，更大的顺序读写磁盘操作，连续的内存块等等，所有这些都使 KafKa 将随机流消息顺序写入到磁盘， 再由 consumers 进行消费。</p><h2 id="字节拷贝"><a href="#字节拷贝" class="headerlink" title="字节拷贝"></a>字节拷贝</h2><p>另一个低效率的操作是字节拷贝，在消息量少时，这不是什么问题。但是在高负载的情况下，影响就不容忽视。为了避免这种情况，我们使用 producer ，broker 和 consumer 都共享的标准化的二进制消息格式，这样数据块不用修改就能在他们之间传递。</p><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>broker 维护的消息日志本身就是一个文件目录，每个文件都由一系列以相同格式写入到磁盘的消息集合组成，这种写入格式被 producer 和 consumer 共用。保持这种通用格式可以对一些很重要的操作进行优化: 持久化日志块的网络传输。 现代的unix 操作系统提供了一个高度优化的编码方式，用于将数据从 pagecache 转移到 socket 网络连接中；在 Linux 中系统调用 sendfile 做到这一点。<br>为了理解 sendfile 的意义，了解数据从文件到套接字的常见数据传输路径就非常重要：</p><ul><li>操作系统从磁盘读取数据到内核空间的 pagecache</li><li>应用程序读取内核空间的数据到用户空间的缓冲区</li><li>应用程序将数据(用户空间的缓冲区)写回内核空间到套接字缓冲区(内核空间)</li><li>操作系统将数据从套接字缓冲区(内核空间)复制到通过网络发送的 NIC 缓冲区</li></ul><p>这显然是低效的，有四次 copy 操作和两次系统调用。使用 sendfile 方法，可以允许操作系统将数据从 pagecache 直接发送到网络，这样避免重新复制数据。所以这种优化方式，只需要最后一步的copy操作，将数据复制到 NIC 缓冲区。<br>我们期望一个普遍的应用场景，一个 topic 被多消费者消费。使用上面提交的 zero-copy（零拷贝）优化，数据在使用时只会被复制到 pagecache 中一次，节省了每次拷贝到用户空间内存中，再从用户空间进行读取的消耗。这使得消息能够以接近网络连接速度的 上限进行消费。<br>pagecache 和 sendfile 的组合使用意味着，在一个kafka集群中，大多数 consumer 消费时，您将看不到磁盘上的读取活动，因为数据将完全由缓存提供。</p><h2 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h2><p>在某些情况下，数据传输的瓶颈不是 CPU ，也不是磁盘，而是网络带宽。对于需要通过广域网在数据中心之间发送消息的数据管道尤其如此。当然，用户可以在不需要 Kakfa 支持下一次一个的压缩消息。但是这样会造成非常差的压缩比和消息重复类型的冗余，比如 JSON 中的字段名称或者是或 Web 日志中的用户代理或公共字符串值。高性能的压缩是一次压缩多个消息，而不是压缩单个消息。<br>Kafka 以高效的批处理格式支持一批消息可以压缩在一起发送到服务器。这批消息将以压缩格式写入，并且在日志中保持压缩，只会在 consumer 消费时解压缩。<br>Kafka 支持 GZIP，Snappy 和 LZ4 压缩协议</p><h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><h2 id="副本策略"><a href="#副本策略" class="headerlink" title="副本策略"></a>副本策略</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>Kafka 允许 topic 的 partition 拥有若干副本，你可以在server端配置partition 的副本数量。当集群中的节点出现故障时，能自动进行故障转移，保证数据的可用性。<br>创建副本的单位是 topic 的 partition ，正常情况下， 每个分区都有一个 leader 和零或多个 followers 。 总的副本数是包含 leader 的总和。 所有的读写操作都由 leader 处理，一般 partition 的数量都比 broker 的数量多的多，各分区的 leader 均 匀的分布在brokers 中。所有的 followers 节点都同步 leader 节点的日志，日志中的消息和偏移量都和 leader 中的一致。（当然, 在任何给定时间, leader 节点的日志末尾时可能有几个消息尚未被备份完成）。<br>Followers 节点就像普通的 consumer 那样从 leader 节点那里拉取消息并保存在自己的日志文件中。Followers 节点可以从 leader 节点那里批量拉取消息日志到自己的日志文件中。</p><h3 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h3><p>与大多数分布式系统一样，自动处理故障需要精确定义节点 “alive” 的概念。Kafka 判断节点是否存活有两种方式。</p><ul><li>节点必须可以维护和 ZooKeeper 的连接，Zookeeper 通过心跳机制检查每个节点的连接。</li><li>如果节点是个 follower ，它必须能及时的同步 leader 的写操作，并且延时不能太久。</li></ul><p>我们认为满足这两个条件的节点处于 “in sync” 状态，区别于 “alive” 和 “failed” 。 Leader会追踪所有 “in sync” 的节点。如果有节点挂掉了, 或是写超时, 或是心跳超时, leader 就会把它从同步副本列表中移除。 同步超时和写超时的时间由 replica.lag.time.max.ms 配置确定。分布式系统中，我们只尝试处理 “fail/recover” 模式的故障，即节点突然停止工作，然后又恢复（节点可能不知道自己曾经挂掉）的状况。Kafka 没有处理所谓的 “Byzantine” 故障，即一个节点出现了随意响应和恶意响应（可能由于 bug 或 非法操作导致）。</p><h3 id="消息同步"><a href="#消息同步" class="headerlink" title="消息同步"></a>消息同步</h3><p>现在, 我们可以更精确地定义, 只有当消息被所有的副本节点加入到日志中时, 才算是提交, 只有提交的消息才会被 consumer 消费, 这样就不用担心一旦 leader 挂掉了消息会丢失。另一方面， producer 也 可以选择是否等待消息被提交，这取决他们的设置在延迟时间和持久性之间的权衡，这个选项是由 producer 使用的 acks 设置控制。 请注意，Topic 可以设置同步备份的最小数量， producer 请求确认消息是否被写入到所有的备份时, 可以用最小同步数量判断。如果 producer 对同步的备份数没有严格的要求，即使同步的备份数量低于 最小同步数量（例如，仅仅只有 leader 同步了数据），消息也会被提交，然后被消费。<br>在所有时间里，Kafka 保证只要有至少一个同步中的节点存活，提交的消息就不会丢失。<br>节点挂掉后，经过短暂的故障转移后，Kafka将仍然保持可用性，但在网络分区（ network partitions ）的情况下可能不能保持可用性。</p><h2 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h2><h3 id="Quorum"><a href="#Quorum" class="headerlink" title="Quorum"></a>Quorum</h3><p>Kafka的核心是备份日志文件。备份日志文件是分布式数据系统最基础的要素之一，实现方法也有很多种。其他系统也可以用 kafka 的备份日志模块来实现状态机风格的分布式系统备份日志按照一系列有序的值(通常是编号为0、1、2、…)进行建模。有很多方法可以实现这一点，但最简单和最快的方法是由 leader 节点选择需要提供的有序的值，只要 leader 节点还存活，所有的 follower 只需要拷贝数据并按照 leader 节点的顺序排序。<br>当然，如果 leader 永远都不会挂掉，那我们就不需要 follower 了。 但是如果 leader crash，我们就需要从 follower 中选举出一个新的 leader。 但是 followers 自身也有可能落后或者 crash，所以 我们必须确保我们leader的候选者们 是一个数据同步 最新的 follower 节点。<br>如果选择写入时候需要保证一定数量的副本写入成功，读取时需要保证读取一定数量的副本，读取和写入之间有重叠。这样的读写机制称为 Quorum。<br>这种权衡的一种常见方法是对提交决策和 leader 选举使用多数投票机制。Kafka 没有采取这种方式，但是我们还是要研究一下这种投票机制，来理解其中蕴含的权衡。假设我们有2f + 1个副本，如果在 leader 宣布消息提交之前必须有f+1个副本收到 该消息，并且如果我们从这至少f+1个副本之中，有着最完整的日志记录的 follower 里来选择一个新的 leader，那么在故障次数少于f的情况下，选举出的 leader 保证具有所有提交的消息。这是因为在任意f+1个副本中，至少有一个副本一定包含 了所有提交的消息。该副本的日志将是最完整的，因此将被选为新的 leader。这个算法都必须处理许多其他细节（例如精确定义怎样使日志更加完整，确保在 leader down 掉期间, 保证日志一致性或者副本服务器的副本集的改变），但是现在我们将忽略这些细节。<br>这种大多数投票方法有一个非常好的优点：延迟是取决于最快的服务器。也就是说，如果副本数是3，则备份完成的等待时间取决于最快的 Follwer 。<br>这里有很多分布式算法，包含 ZooKeeper 的 Zab, Raft, 和 Viewstamped Replication. 我们所知道的与 Kafka 实际执行情况最相似的学术刊物是来自微软的 PacificA<br>大多数投票的缺点是，多数的节点挂掉让你不能选择 leader。要冗余单点故障需要三份数据，并且要冗余两个故障需要五份的数据。根据我们的经验，在一个系统中，仅仅靠冗余来避免单点故障是不够的，但是每写5次，对磁盘空间需求是5倍， 吞吐量下降到 1/5，这对于处理海量数据问题是不切实际的。这可能是为什么 quorum 算法更常用于共享集群配置（如 ZooKeeper ）， 而不适用于原始数据存储的原因，例如 HDFS 中 namenode 的高可用是建立在 基于投票的元数据 ，这种代价高昂的存储方式不适用数据本身。</p><h3 id="ISR"><a href="#ISR" class="headerlink" title="ISR"></a>ISR</h3><p>Kafka 采取了一种稍微不同的方法来选择它的投票集。 Kafka 不是用大多数投票选择 leader 。Kafka 动态维护了一个同步状态的备份的集合 （a set of in-sync replicas）， 简称 ISR ，在这个集合中的节点都是和 leader 保持高度一致的，只有这个集合的成员才 有资格被选举为 leader，一条消息必须被这个集合 所有 节点读取并追加到日志中了，这条消息才能视为提交。这个 ISR 集合发生变化会在 ZooKeeper 持久化，正因为如此，这个集合中的任何一个节点都有资格被选为 leader 。这对于 Kafka 使用模型中， 有很多分区和并确保主从关系是很重要的。因为 ISR 模型和 f+1 副本，一个 Kafka topic 冗余 f 个节点故障而不会丢失任何已经提交的消息。<br>我们认为对于希望处理的大多数场景这种策略是合理的。在实际中，为了冗余 f 节点故障，大多数投票和 ISR 都会在提交消息前确认相同数量的备份被收到（例如在一次故障生存之后，大多数的 quorum 需要三个备份节点和一次确认，ISR 只需要两个备份节点和一次确认），多数投票方法的一个优点是提交时能避免最慢的服务器。但是，我们认为通过允许客户端选择是否阻塞消息提交来改善，和所需的备份数较低而产生的额外的吞吐量和磁盘空间是值得的。<br>另一个重要的设计区别是，Kafka 不要求崩溃的节点恢复所有的数据，在这种空间中的复制算法经常依赖于存在 “稳定存储”，在没有违反潜在的一致性的情况下，出现任何故障再恢复情况下都不会丢失。 这个假设有两个主要的问题。首先，我们在持久性数据系统的实际操作中观察到的最常见的问题是磁盘错误，并且它们通常不能保证数据的完整性。其次，即使磁盘错误不是问题，我们也不希望在每次写入时都要求使用 fsync 来保证一致性， 因为这会使性能降低两到三个数量级。我们的协议能确保备份节点重新加入ISR 之前，即使它挂时没有新的数据, 它也必须完整再一次同步数据。</p><h3 id="leader恢复"><a href="#leader恢复" class="headerlink" title="leader恢复"></a>leader恢复</h3><p>请注意，Kafka 对于数据不会丢失的保证，是基于至少一个节点在保持同步状态，一旦分区上的所有备份节点都挂了，就无法保证了。但是，实际在运行的系统需要去考虑假设一旦所有的备份都挂了，怎么去保证数据不会丢失，这里有两种实现的方法</p><ul><li>等待一个 ISR 的副本重新恢复正常服务，并选择这个副本作为领 leader （它有极大可能拥有全部数据）。</li><li>选择第一个重新恢复正常服务的副本（不一定是 ISR 中的）作为leader。</li></ul><p>这是可用性和一致性之间的简单妥协，如果我只等待 ISR 的备份节点，那么只要 ISR 备份节点都挂了，我们的服务将一直会不可用，如果它们的数据损坏了或者丢失了，那就会是长久的宕机。另一方面，如果不是 ISR 中的节点恢复服务并且我们允许它成为 leader ， 那么它的数据就是可信的来源，即使它不能保证记录了每一个已经提交的消息。 kafka 默认选择第二种策略，当所有的 ISR 副本都挂掉时，会选择一个可能不同步的备份作为 leader ，可以配置属性 unclean.leader.election.enable 禁用此策略，那么就会使用第 一种策略即停机时间优于不同步。<br>这种困境不只有 Kafka 遇到，它存在于任何 quorum-based 规则中。例如，在大多数投票算法当中，如果大多数服务器永久性的挂了，那么您要么选择丢失100%的数据，要么违背数据的一致性选择一个存活的服务器作为数据可信的来源。</p><h3 id="消息提交"><a href="#消息提交" class="headerlink" title="消息提交"></a>消息提交</h3><p>向 Kafka 写数据时，producers 设置 ack 是否提交完成， 0：不等待broker返回确认消息,1: leader保存成功返回或, -1(all): 所有备份都保存成功返回.请注意. 设置 “ack = all” 并不能保证所有的副本都写入了消息。默认情况下，当 acks = all 时，只要 ISR 副本同步完成，就会返回消息已经写入。例如，一个 topic 仅仅设置了两个副本，那么只有一个 ISR 副本，那么当设置acks = all时返回写入成功时，剩下了的那个副本数据也可能数据没有写入。 尽管这确保了分区的最大可用性，但是对于偏好数据持久性而不是可用性的一些用户，可能不想用这种策略，因此，我们提供了两个topic 配置，可用于优先配置消息数据持久性：</p><ul><li>禁用 unclean leader 选举机制 - 如果所有的备份节点都挂了,分区数据就会不可用，直到最近的 leader 恢复正常。这种策略优先于数据丢失的风险， 参看上一节的 unclean leader 选举机制。</li><li>指定最小的 ISR 集合大小，只有当 ISR 的大小大于最小值，分区才能接受写入操作，以防止仅写入单个备份的消息丢失造成消息不可用的情况，这个设置只有在生产者使用 acks = all 的情况下才会生效，这至少保证消息被 ISR 副本写入。此设置是一致性和可用性 之间的折衷，对于设置更大的最小ISR大小保证了更好的一致性，因为它保证将消息被写入了更多的备份，减少了消息丢失的可能性。但是，这会降低可用性，因为如果 ISR 副本的数量低于最小阈值，那么分区将无法写入。</li></ul><h1 id="broker-controller"><a href="#broker-controller" class="headerlink" title="broker controller"></a>broker controller</h1><p>优化主从关系的选举过程也是重要的，这是数据不可用的关键窗口。原始的实现是当有节点挂了后，进行主从关系选举时，会对挂掉节点的所有partition 的领导权重新选举。相反，我们会选择一个 broker 作为 “controller”节点。controller 节点负责 检测 brokers 级别故障,并负责在 broker 故障的情况下更改这个故障 Broker 中的 partition 的 leadership 。这种方式可以批量的通知主从关系的变化，使得对于拥有大量partition 的broker ,选举过程的代价更低并且速度更快。如果 controller 节点挂了，其他 存活的 broker 都可能成为新的 controller 节点。<br>Kafka中的控制器选举的工作依赖于Zookeeper，成功竞选为控制器的broker会在Zookeeper中创建/controller这个临时（EPHEMERAL）节点。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>具备控制器身份的broker需要比其他普通的broker多一份职责，具体细节如下：</p><ul><li>监听partition相关的变化。处理分区重分配的动作、ISR集合变更的动作、优先副本的选举动作。</li><li>监听topic相关的变化，处理topic增减的变化、删除topic的动作。</li><li>监听broker相关的变化，处理broker增减的变化。</li><li>从Zookeeper中读取获取当前所有与topic、partition以及broker有关的信息并进行相应的管理。对于所有topic所对应的Zookeeper中的节点添加监听器，用来监听topic中的分区分配变化。</li><li>启动并管理分区状态机和副本状态机。</li><li>更新集群的元数据信息。</li><li>如果参数auto.leader.rebalance.enable设置为true，则还会开启一个名为“auto-leader-rebalance-task”的定时任务来负责维护分区的优先副本的均衡。</li></ul><p><img src="/images/broke-controller-zk.png"></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>在Kafka的早期版本中，并没有采用Kafka Controller这样一个概念来对分区和副本的状态进行管理，而是依赖于Zookeeper，每个broker都会在Zookeeper上为分区和副本注册大量的监听器（Watcher）。当分区或者副本状态变化时，会唤醒很多不必要的监听器，这种严重依赖于Zookeeper的设计会有脑裂、羊群效应以及造成Zookeeper过载的隐患。在目前的新版本的设计中，只有Kafka Controller在Zookeeper上注册相应的监听器，其他的broker极少需要再监听Zookeeper中的数据变化，这样省去了很多不必要的麻烦。不过每个broker还是会对/controller节点添加监听器的，以此来监听此节点的数据变化。</p>]]></content>
    
    <summary type="html">
    
      kafka
    
    </summary>
    
      <category term="大数据" scheme="http://langonggong.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="消息队列" scheme="http://langonggong.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="kafka" scheme="http://langonggong.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>HDFS</title>
    <link href="http://langonggong.com/2020/07/26/HDFS/"/>
    <id>http://langonggong.com/2020/07/26/HDFS/</id>
    <published>2020-07-26T13:17:31.000Z</published>
    <updated>2020-07-27T17:53:15.294Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;在现代的企业环境中，单机容量往往无法存储大量数据，需要跨机器存储。统一管理分布在集群上的文件系统称为分布式文件系统。而一旦在系统中，引入网络，就不可避免地引入了所有网络编程的复杂性，例如挑战之一是如果保证在节点不可用的时候数据不丢失。</p><p>&emsp;&emsp;传统的网络文件系统（NFS）虽然也称为分布式文件系统，但是其存在一些限制。由于NFS中，文件是存储在单机上，因此无法提供可靠性保证，当很多客户端同时访问NFS Server时，很容易造成服务器压力，造成性能瓶颈。另外如果要对NFS中的文件中进行操作，需要首先同步到本地，这些修改在同步到服务端之前，其他客户端是不可见的。某种程度上，NFS不是一种典型的分布式系统，虽然它的文件的确放在远端（单一）的服务器上面。</p><p><img src="/images/NFS架构.png"><br><img src="/images/NFS协议栈.png"></p><p>&emsp;&emsp;从NFS的协议栈可以看到，它事实上是一种VFS（操作系统对文件的一种抽象）实现。</p><p>&emsp;&emsp;HDFS，是Hadoop Distributed File System的简称，是Hadoop抽象文件系统的一种实现。Hadoop抽象文件系统可以与本地系统、Amazon S3等集成，甚至可以通过Web协议（webhsfs）来操作。HDFS的文件分布在集群机器上，同时提供副本进行容错及可靠性保证。例如客户端写入读取文件的直接操作都是分布在集群各个机器上的，没有单点性能压力。</p><h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><ul><li><strong>存储非常大的文件</strong><br>  这里非常大指的是几百M、G、或者TB级别。实际应用中已有很多集群存储的数据达到PB级别。根据Hadoop官网，Yahoo！的Hadoop集群约有10万颗CPU，运行在4万个机器节点上。更多世界上的Hadoop集群使用情况，参考Hadoop官网.</li><li><strong>采用流式的数据访问方式</strong><br>  HDFS基于这样的一个假设：最有效的数据处理模式是一次写入、多次读取数据集经常从数据源生成或者拷贝一次，然后在其上做很多分析工作<br>分析工作经常读取其中的大部分数据，即使不是全部。 因此读取整个数据集所需时间比读取第一条记录的延时更重要。</li><li><strong>运行于商业硬件上</strong><br>  Hadoop不需要特别贵的、reliable的机器，可运行于普通商用机器（可以从多家供应商采购） 商用机器不代表低端机器在集群中（尤其是大的集群），节点失败率是比较高的HDFS的目标是确保集群在节点失败的时候不会让用户感觉到明显的中断。</li></ul><h2 id="不适用的场景"><a href="#不适用的场景" class="headerlink" title="不适用的场景"></a>不适用的场景</h2><ul><li><strong>低延时的数据访问</strong><br> 对延时要求在毫秒级别的应用，不适合采用HDFS。HDFS是为高吞吐数据传输设计的,因此可能牺牲延时HBase更适合低延时的数据访问。</li><li><strong>大量小文件</strong><br>  文件的元数据（如目录结构，文件block的节点列表，block-node mapping）保存在NameNode的内存中， 整个文件系统的文件数量会受限于NameNode的内存大小。<br>经验而言，一个文件/目录/文件块一般占有150字节的元数据内存空间。如果有100万个文件，每个文件占用1个文件块，则需要大约300M的内存。因此十亿级别的文件数量在现有商用机器上难以支持。</li><li><strong>多方读写，需要任意的文件修改</strong><br>  HDFS采用追加（append-only）的方式写入数据。不支持文件任意offset的修改。不支持多个写入器（writer）。</li></ul><h1 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h1><p><img src="/images/HDFS架构图.png"></p><p>&emsp;&emsp;HDFS 是一个主从结构，一个 HDFS 集群有一个名字节点，它是一个管理文件命名空间和调节客户端访问文件的主服务器，当然还有一些数据节点，通常是一个节点一个机器，它来管理对应节点的存储。HDFS 对外开放文件命名空间并允许用户数据以文件形式存储。</p><p>&emsp;&emsp;内部机制是将一个文件分割成一个或多个块，这些块被存储在一组数据节点中。名字节点用来操作文件命名空间的文件或目录操作，如打开、关闭、重命名等等。它同时确定块与数据节点的映射。数据节点来负责来自文件系统客户的读写请求。数据节点同时还要执行块的创建、删除、和来自名字节点的块复制指令。</p><p>&emsp;&emsp;集群中只有一个名字节点极大地简单化了系统的体系结构。名字节点是仲裁者和所有 HDFS 元数据的仓库，用户的实际数据不经过名字节点。</p><h2 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h2><h3 id="Namenode"><a href="#Namenode" class="headerlink" title="Namenode"></a>Namenode</h3><p>&emsp;&emsp;Namenode存放文件系统树及所有文件、目录的元数据。元数据持久化为2种形式：</p><ul><li>namespcae image</li><li>edit log</li></ul><p>&emsp;&emsp;但是持久化数据中不包括Block所在的节点列表，及文件的Block分布在集群中的哪些节点上，这些信息是在系统重启的时候重新构建（通过Datanode汇报的Block信息）。在HDFS中，Namenode可能成为集群的单点故障，Namenode不可用时，整个文件系统是不可用的。HDFS针对单点故障提供了2种解决机制：</p><ul><li>备份持久化元数据<br>  将文件系统的元数据同时写到多个文件系统， 例如同时将元数据写到本地文件系统及NFS。这些备份操作都是同步的、原子的。</li><li>Secondary Namenode<br>  Secondary节点定期合并主Namenode的namespace image和edit log， 避免edit log过大，通过创建检查点checkpoint来合并。它会维护一个合并后的namespace image副本， 可用于在Namenode完全崩溃时恢复数据。<br>Secondary Namenode通常运行在另一台机器，因为合并操作需要耗费大量的CPU和内存。其数据落后于Namenode，因此当Namenode完全崩溃时，会出现数据丢失。 通常做法是拷贝NFS中的备份元数据到Second，将其作为新的主Namenode。<br>在HA中可以运行一个Hot Standby，作为热备份，在Active Namenode故障之后，替代原有Namenode成为Active Namenode。</li></ul><h3 id="Datanode"><a href="#Datanode" class="headerlink" title="Datanode"></a>Datanode</h3><p>&emsp;&emsp;数据节点负责存储和提取Block，读写请求可能来自namenode，也可能直接来自客户端。数据节点周期性向Namenode汇报自己节点上所存储的Block相关信息。</p><h2 id="副本技术"><a href="#副本技术" class="headerlink" title="副本技术"></a>副本技术</h2><p>&emsp;&emsp;副本技术即分布式数据复制技术，是分布式计算的一个重要组成部分。该技术允许数据在多个服务器端共享，一个本地服务器可以存取不同物理地点的远程服务器上的数据，也可以使所有的服务器均持有数据的拷贝。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>通过过副本技术可以有以下优点：</p><ul><li>提高系统可靠性<br>  系统不可避免的会产生故障和错误，拥有多个副本的文件系统不会导致无法访问的情况，从而提高了系统的可用性。另外，系统可以通过其他完好的副本对发生错误的副本进行修复，从而提高了系统的容错性。</li><li>负载均衡<br>  副本可以对系统的负载量进行扩展。多个副本存放在不同的服务器上，可有效的分担工作量，从而将较大的工作量有效的分布在不同的站点上。</li><li>提高访问效率<br>  将副本创建在访问频度较大的区域，即副本在访问节点的附近，相应减小了其通信开销，从而提高了整体的访问效率。</li></ul><h3 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h3><p>&emsp;&emsp;HDFS 设计成能可靠地在集群中大量机器之间存储大量的文件，它以块序列的形式存储文件。文件中除了最后一个块，其他块都有相同的大小。属于文件的块为了故障容错而被复制。块的大小和复制数是以文件为单位进行配置的，应用可以在文件创建时或者之后修改复制因子。HDFS 中的文件是一次写的，并且任何时候都只有一个写操作。<br>&emsp;&emsp;名字节点负责处理与所有的块复制相关的决策。它周期性地接受集群中数据节点的心跳和块报告。一个心跳的到达表示这个数据节点是正常的。一个块报告包括该数据节点上所有块的列表。</p><h3 id="副本放置策略"><a href="#副本放置策略" class="headerlink" title="副本放置策略"></a>副本放置策略</h3><p>&emsp;&emsp;块副本存放位置的选择严重影响 HDFS 的可靠性和性能。HDFS 采用机架敏感（rack awareness）的副本存放策略来提高数据的可靠性、可用性和网络带宽的利用率。</p><p><img src="/images/HDFS 副本放置策略图.png"></p><p>&emsp;&emsp;HDFS 运行在跨越大量机架的集群之上。两个不同机架上的节点是通过交换机实现通信的，在大多数情况下，相同机架上机器间的网络带宽优于在不同机架上的机器。<br>&emsp;&emsp;在开始的时候，每一个数据节点自检它所属的机架 id，然后在向名字节点注册的时候告知它的机架 id。HDFS 提供接口以便很容易地挂载检测机架标示的模块。一个简单但不是最优的方式就是将副本放置在不同的机架上，这就防止了机架故障时数据的丢失，并且在读数据的时候可以充分利用不同机架的带宽。这个方式均匀地将复制分散在集群中，这就简单地实现了组建故障时的负载均衡。然而这种方式增加了写的成本，因为写的时候需要跨越多个机架传输文件块。</p><p>&emsp;&emsp;HDFS的副本的存放策略是可靠性、写带宽、读带宽之间的权衡。默认策略如下：</p><ul><li>第一个副本放在客户端相同的机器上，如果机器在集群之外，随机选择一个（但是会尽可能选择容量不是太慢或者当前操作太繁忙的）</li><li>第二个副本随机放在不同于第一个副本的机架上。</li><li>第三个副本放在跟第二个副本同一机架上，但是不同的节点上，满足条件的节点中随机选择。</li><li>更多的副本在整个集群上随机选择，虽然会尽量便面太多副本在同一机架上。</li></ul><h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><p>&emsp;&emsp;在Hadoop 1.x 中，Namenode是集群的单点故障，一旦Namenode出现故障，整个集群将不可用，重启或者开启一个新的Namenode才能够从中恢复。值得一提的是，Secondary Namenode并没有提供故障转移的能力。集群的可用性受到影响表现在：</p><ul><li>当机器发生故障，如断电时，管理员必须重启Namenode才能恢复可用。</li><li>在日常的维护升级中，需要停止Namenode，也会导致集群一段时间不可用。</li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>&emsp;&emsp;Hadoop HA（High Available）通过同时配置两个处于Active/Passive模式的Namenode来解决上述问题，分别叫Active Namenode和Standby Namenode. Standby Namenode作为热备份，从而允许在机器发生故障时能够快速进行故障转移，同时在日常维护的时候使用优雅的方式进行Namenode切换。Namenode只能配置一主一备，不能多于两个Namenode。</p><p>&emsp;&emsp;主Namenode处理所有的操作请求（读写），而Standby只是作为slave，维护尽可能同步的状态，使得故障时能够快速切换到Standby。为了使Standby Namenode与Active Namenode数据保持同步，两个Namenode都与一组Journal Node进行通信。当主Namenode进行任务的namespace操作时，都会确保持久会修改日志到Journal Node节点中的大部分。Standby Namenode持续监控这些edit，当监测到变化时，将这些修改应用到自己的namespace。</p><p>&emsp;&emsp;当进行故障转移时，Standby在成为Active Namenode之前，会确保自己已经读取了Journal Node中的所有edit日志，从而保持数据状态与故障发生前一致。</p><p>&emsp;&emsp;为了确保故障转移能够快速完成，Standby Namenode需要维护最新的Block位置信息，即每个Block副本存放在集群中的哪些节点上。为了达到这一点，Datanode同时配置主备两个Namenode，并同时发送Block报告和心跳到两台Namenode。</p><p>&emsp;&emsp;确保任何时刻只有一个Namenode处于Active状态非常重要，否则可能出现数据丢失或者数据损坏。当两台Namenode都认为自己的Active Namenode时，会同时尝试写入数据（不会再去检测和同步数据）。为了防止这种脑裂现象，Journal Nodes只允许一个Namenode写入数据，内部通过维护epoch数来控制，从而安全地进行故障转移。</p><p>有两种方式可以进行edit log共享：</p><ul><li>使用NFS共享edit log（存储在NAS/SAN）</li><li>使用QJM共享edit log</li></ul><h2 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h2><p><img src="/images/NFS共享存储.png"></p><p>&emsp;&emsp;如图所示，NFS作为主备Namenode的共享存储。这种方案可能会出现脑裂（split-brain），即两个节点都认为自己是主Namenode并尝试向edit log写入数据，这可能会导致数据损坏。通过配置fencin脚本来解决这个问题，fencing脚本用于：</p><ul><li>将之前的Namenode关机</li><li>禁止之前的Namenode继续访问共享的edit log文件</li></ul><p>使用这种方案，管理员就可以手工触发Namenode切换，然后进行升级维护。但这种方式存在以下问题：</p><ul><li>只能手动进行故障转移，每次故障都要求管理员采取措施切换。</li><li>NAS/SAN设置部署复杂，容易出错，且NAS本身是单点故障。</li><li>Fencing 很复杂，经常会配置错误。</li><li>无法解决意外（unplanned）事故，如硬件或者软件故障</li></ul><p>因此需要另一种方式来处理这些问题：</p><ul><li>自动故障转移（引入ZooKeeper达到自动化）</li><li>移除对外界软件硬件的依赖（NAS/SAN）</li><li>同时解决意外事故及日常维护导致的不可用</li></ul><h2 id="Quorum-ZooKeeper"><a href="#Quorum-ZooKeeper" class="headerlink" title="Quorum + ZooKeeper"></a>Quorum + ZooKeeper</h2><p>&emsp;&emsp;QJM（Quorum Journal Manager）是Hadoop专门为Namenode共享存储开发的组件。其集群运行一组Journal Node，每个Journal 节点暴露一个简单的RPC接口，允许Namenode读取和写入数据，数据存放在Journal节点的本地磁盘。当Namenode写入edit log时，它向集群的所有Journal Node发送写入请求，当多数节点回复确认成功写入之后，edit log就认为是成功写入。例如有3个Journal Node，Namenode如果收到来自2个节点的确认消息，则认为写入成功。</p><p>&emsp;&emsp;而在故障自动转移的处理上，引入了监控Namenode状态的ZookeeperFailController（ZKFC）。ZKFC一般运行在Namenode的宿主机器上，与Zookeeper集群协作完成故障的自动转移。整个集群架构图如下：</p><p><img src="/images/QJM HA架构.png"></p><h3 id="QJM"><a href="#QJM" class="headerlink" title="QJM"></a>QJM</h3><p>&emsp;&emsp;Namenode使用QJM 客户端提供的RPC接口与Namenode进行交互。写入edit log时采用基于仲裁的方式，即数据必须写入JournalNode集群的大部分节点。服务端Journal运行轻量级的守护进程，暴露RPC接口供客户端调用。实际的edit log数据保存在Journal Node本地磁盘。架构图如下：</p><p><img src="/images/QJM提交过程.png"></p><p>&emsp;&emsp;Journal Node通过epoch数来解决脑裂的问题，称为JournalNode fencing。具体工作原理如下：</p><ul><li>当Namenode变成Active状态时，被分配一个整型的epoch数，这个epoch数是独一无二的，并且比之前所有Namenode持有的epoch number都高。</li><li>当Namenode向Journal Node发送消息的时候，同时也带上了epoch。当Journal Node收到消息时，将收到的epoch数与存储在本地的promised epoch比较，如果收到的epoch比自己的大，则使用收到的epoch更新自己本地的epoch数。如果收到的比本地的epoch小，则拒绝请求。</li><li>edit log必须写入大部分节点才算成功，也就是其epoch要比大多数节点的epoch高。</li></ul><p>这种方式解决了NFS方式的3个问题：</p><ul><li>不需要额外的硬件，使用原有的物理机</li><li>Fencing通过epoch数来控制，避免出错。</li><li>自动故障转移：Zookeeper处理该问题。</li></ul><h3 id="基于Zookeeper自动故障转移"><a href="#基于Zookeeper自动故障转移" class="headerlink" title="基于Zookeeper自动故障转移"></a>基于Zookeeper自动故障转移</h3><p>&emsp;&emsp;前面提到，为了支持故障转移，Hadoop引入两个新的组件：Zookeeper Quorum和ZKFailoverController process（简称ZKFC）。</p><p><img src="/images/NameNode的切换流程.png"></p><p>&emsp;&emsp;Zookeeper的任务包括：</p><ul><li>失败检测<br>  每个Namnode都在ZK中维护一个持久性session，如果Namnode故障，session过期，使用zk的事件机制通知其他Namenode需要故障转移。</li><li>Namenode选举<br>  如果当前Active namenode挂了，另一个namenode会尝试获取ZK中的一个排它锁，获取这个锁就表名它将成为下一个Active NN。</li></ul><p>&emsp;&emsp;在每个Namenode守护进程的机器上，同时也会运行一个ZKFC，用于完成以下任务：</p><ul><li>Namenode健康健康</li><li>ZK Session管理</li><li>基于ZK的Namenode选举</li></ul><p>&emsp;&emsp;如果ZKFC所在机器的Namenode健康状态良好，并且用于选举的znode锁未被其他节点持有，则ZKFC会尝试获取锁,成功获取这个排它锁就代表获得选举，获得选举之后负责故障转移，如果有必要，会fencing掉之前的namenode使其不可用，然后将自己的namenode切换为Active状态。</p><h1 id="读写流程"><a href="#读写流程" class="headerlink" title="读写流程"></a>读写流程</h1><h2 id="读流程"><a href="#读流程" class="headerlink" title="读流程"></a>读流程</h2><p><img src="/images/HDFS读流程.png"></p><ul><li>客户端传递一个文件Path给FileSystem的open方法</li><li>DFS采用RPC远程获取文件最开始的几个block的datanode地址。Namenode会根据网络拓扑结构决定返回哪些节点（前提是节点有block副本），如果客户端本身是Datanode并且节点上刚好有block副本，直接从本地读取。</li><li>客户端使用open方法返回的FSDataInputStream对象读取数据（调用read方法）</li><li>DFSInputStream（FSDataInputStream实现了改类）连接持有第一个block的、最近的节点，反复调用read方法读取数据</li><li>第一个block读取完毕之后，寻找下一个block的最佳datanode，读取数据。如果有必要，DFSInputStream会联系Namenode获取下一批Block 的节点信息(存放于内存，不持久化），这些寻址过程对客户端都是不可见的。</li><li>数据读取完毕，客户端调用close方法关闭流对象</li></ul><p>&emsp;&emsp;在读数据过程中，如果与Datanode的通信发生错误，DFSInputStream对象会尝试从下一个最佳节点读取数据，并且记住该失败节点， 后续Block的读取不会再连接该节点。<br>&emsp;&emsp;读取一个Block之后，DFSInputStram会进行检验和验证，如果Block损坏，尝试从其他节点读取数据，并且将损坏的block汇报给Namenode。<br>&emsp;&emsp;客户端连接哪个datanode获取数据，是由namenode来指导的，这样可以支持大量并发的客户端请求，namenode尽可能将流量均匀分布到整个集群。<br>&emsp;&emsp;Block的位置信息是存储在namenode的内存中，因此相应位置请求非常高效，不会成为瓶颈。</p><h2 id="写流程"><a href="#写流程" class="headerlink" title="写流程"></a>写流程</h2><p><img src="/images/HDFS写流程.png"></p><ul><li>通过Client向远程的NameNode发送RPC请求；</li><li>接收到请求后NameNode会首先判断对应的文件是否存在以及用户是否有对应的权限，成功则会为文件创建一个记录，否则会让客户端抛出异常；</li><li>当客户端开始写入文件的时候，开发库会将文件切分成多个packets，并在内部以”data queue”的形式管理这些packets，并向Namenode申请新的blocks，获取用来存储replicas的合适的datanodes列表，列表的大小根据在Namenode中对replication的设置而定。</li><li>开始以pipeline（管道）的形式将packet写入所有的replicas中。开发库把packet以流的方式写入第一个 datanode，该datanode把该packet存储之后，再将其传递给在此pipeline中的下一个datanode，直到最后一个 datanode， 这种写数据的方式呈流水线的形式。</li><li>最后一个datanode成功存储之后会返回一个ack packet，在pipeline里传递至客户端，在客户端的开发库内部维护着 “ack queue”，成功收到datanode返回的ack packet后会从”ack queue”移除相应的packet。</li><li>如果传输过程中，有某个datanode出现了故障，那么当前的pipeline会被关闭，出现故障的datanode会从当前的 pipeline中移除，剩余的block会继续剩下的datanode中继续以pipeline的形式传输，同时Namenode会分配一个新的 datanode，保持replicas设定的数量。</li></ul><h3 id="DFSOutputStream"><a href="#DFSOutputStream" class="headerlink" title="DFSOutputStream"></a>DFSOutputStream</h3><p>&emsp;&emsp;打开一个DFSOutputStream流，Client会写数据到流内部的一个缓冲区中，然后数据被分解成多个Packet，每个Packet大小为64k字节，每个Packet又由一组chunk和这组chunk对应的checksum数据组成，默认chunk大小为512字节，每个checksum是对512字节数据计算的校验和数据。</p><p>&emsp;&emsp;当Client写入的字节流数据达到一个Packet的长度，这个Packet会被构建出来，然后会被放到队列dataQueue中，接着DataStreamer线程会不断地从dataQueue队列中取出Packet，发送到复制Pipeline中的第一个DataNode上，并将该Packet从dataQueue队列中移到ackQueue队列中。ResponseProcessor线程接收从Datanode发送过来的ack，如果是一个成功的ack，表示复制Pipeline中的所有Datanode都已经接收到这个Packet，ResponseProcessor线程将packet从队列ackQueue中删除。</p><p>&emsp;&emsp;在发送过程中，如果发生错误，所有未完成的Packet都会从ackQueue队列中移除掉，然后重新创建一个新的Pipeline，排除掉出错的那些DataNode节点，接着DataStreamer线程继续从dataQueue队列中发送Packet。</p><p>&emsp;&emsp;下面是DFSOutputStream的结构及其原理，如图所示：<br><img src="/images/DFSOutputStream.png"><br>从下面3个方面来描述内部流程：</p><ul><li>创建Packet<br>  Client写数据时，会将字节流数据缓存到内部的缓冲区中，当长度满足一个Chunk大小（512B）时，便会创建一个Packet对象，然后向该Packet对象中写Chunk Checksum校验和数据，以及实际数据块Chunk Data，校验和数据是基于实际数据块计算得到的。每次满足一个Chunk大小时，都会向Packet中写上述数据内容，直到达到一个Packet对象大小（64K），就会将该Packet对象放入到dataQueue队列中，等待DataStreamer线程取出并发送到DataNode节点。</li><li>发送Packet<br>  DataStreamer线程从dataQueue队列中取出Packet对象，放到ackQueue队列中，然后向DataNode节点发送这个Packet对象所对应的数据。</li><li>接收ack<br>  发送一个Packet数据包以后，会有一个用来接收ack的ResponseProcessor线程，如果收到成功的ack，则表示一个Packet发送成功。如果成功，则ResponseProcessor线程会将ackQueue队列中对应的Packet删除。</li></ul>]]></content>
    
    <summary type="html">
    
      大数据调度
    
    </summary>
    
      <category term="大数据" scheme="http://langonggong.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://langonggong.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="HDFS" scheme="http://langonggong.com/tags/HDFS/"/>
    
  </entry>
  
  <entry>
    <title>YARN</title>
    <link href="http://langonggong.com/2020/07/26/YARN/"/>
    <id>http://langonggong.com/2020/07/26/YARN/</id>
    <published>2020-07-26T05:48:00.000Z</published>
    <updated>2020-07-26T10:01:06.173Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="基本服务组件"><a href="#基本服务组件" class="headerlink" title="基本服务组件"></a>基本服务组件</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;YARN是Hadoop 2.0中的资源管理系统，它的基本设计思想是将MRv1中的JobTracker拆分成了两个独立的服务：一个全局的资源管理器ResourceManager和每个应用程序特有的ApplicationMaster。其中ResourceManager负责整个系统的资源管理和分配，而ApplicationMaster负责单个应用程序的管理。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;YARN总体上仍然是master/slave结构，在整个资源管理框架中，resourcemanager为master，nodemanager是slave。Resourcemanager负责对各个nademanger上资源进行统一管理和调度。当用户提交一个应用程序时，需要提供一个用以跟踪和管理这个程序的ApplicationMaster，它负责向ResourceManager申请资源，并要求NodeManger启动可以占用一定资源的任务。由于不同的ApplicationMaster被分布到不同的节点上，因此它们之间不会相互影响。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;YARN的基本组成结构，YARN主要由ResourceManager、NodeManager、ApplicationMaster和Container等几个组件构成。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;ResourceManager是Master上一个独立运行的进程，负责集群统一的资源管理、调度、分配等等；NodeManager是Slave上一个独立运行的进程，负责上报节点的状态；App Master和Container是运行在Slave上的组件，Container是yarn中分配资源的一个单位，包涵内存、CPU等等资源，yarn以Container为单位分配资源。Client向ResourceManager提交的每一个应用程序都必须有一个Application Master，它经过ResourceManager分配资源后，运行于某一个Slave节点的Container中，具体做事情的Task，同样也运行与某一个Slave节点的Container中。RM，NM，AM乃至普通的Container之间的通信，都是用RPC机制。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;YARN的架构设计使其越来越像是一个云操作系统，数据处理操作系统。</p><p><img src="/images/yarn架构2.png"></p><h2 id="Resourcemanager"><a href="#Resourcemanager" class="headerlink" title="Resourcemanager"></a>Resourcemanager</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;RM是一个全局的资源管理器，集群只有一个，负责整个系统的资源管理和分配，包括处理客户端请求、启动/监控APP master、监控nodemanager、资源的分配与调度。它主要由两个组件构成：调度器（Scheduler）和应用程序管理器（Applications Manager，ASM）。</p><ul><li>调度器<br>  调度器根据容量、队列等限制条件（如每个队列分配一定的资源，最多执行一定数量的作业等），将系统中的资源分配给各个正在运行的应用程序。需要注意的是，该调度器是一个“纯调度器”，它不再从事任何与具体应用程序相关的工作，比如不负责监控或者跟踪应用的执行状态等，也不负责重新启动因应用执行失败或者硬件故障而产生的失败任务，这些均交由应用程序相关的ApplicationMaster完成。调度器仅根据各个应用程序的资源需求进行资源分配，而资源分配单位用一个抽象概念“资源容器”（Resource Container，简称Container）表示，Container是一个动态资源分配单位，它将内存、CPU、磁盘、网络等资源封装在一起，从而限定每个任务使用的资源量。此外，该调度器是一个可插拔的组件，用户可根据自己的需要设计新的调度器，YARN提供了多种直接可用的调度器，比如Fair Scheduler和Capacity Scheduler等。</li><li>应用程序管理器<br>  应用程序管理器负责管理整个系统中所有应用程序，包括应用程序提交、与调度器协商资源以启动ApplicationMaster、监控ApplicationMaster运行状态并在失败时重新启动它等。</li></ul><h2 id="ApplicationMaster（AM）"><a href="#ApplicationMaster（AM）" class="headerlink" title="ApplicationMaster（AM）"></a>ApplicationMaster（AM）</h2><p>管理YARN内运行的应用程序的每个实例。<br>功能：</p><ul><li>数据切分</li><li>为应用程序申请资源并进一步分配给内部任务。</li><li>任务监控与容错</li><li>负责协调来自resourcemanager的资源，并通过nodemanager监视容易的执行和资源使用情况。</li></ul><h2 id="NodeManager（NM）"><a href="#NodeManager（NM）" class="headerlink" title="NodeManager（NM）"></a>NodeManager（NM）</h2><p>Nodemanager整个集群有多个，负责每个节点上的资源和使用。<br>功能：</p><ul><li>单个节点上的资源管理和任务。</li><li>处理来自于resourcemanager的命令。</li><li>处理来自域app master的命令。</li></ul><p>Nodemanager管理着抽象容器，这些抽象容器代表着一些特定程序使用针对每个节点的资源。<br>Nodemanager定时地向RM汇报本节点上的资源使用情况和各个Container的运行状态（cpu和内存等资源）</p><h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><p>Container是YARN中的资源抽象，它封装了某个节点上的多维度资源，如内存、CPU、磁盘、网络等，当AM向RM申请资源时，RM为AM返回的资源便是用Container表示的。YARN会为每个任务分配一个Container，且该任务只能使用该Container中描述的资源。需要注意的是，Container不同于MRv1中的slot，它是一个动态资源划分单位，是根据应用程序的需求动态生成的。目前为止，YARN仅支持CPU和内存两种资源，且使用了轻量级资源隔离机制Cgroups进行资源隔离。<br>功能：</p><ul><li>对task环境的抽象</li><li>描述一系列信息</li><li>任务运行资源的集合（cpu、内存、io等）</li><li>任务运行环境</li></ul><h1 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h1><p><img src="/images/yarn工作流程.png"></p><ol><li>客户端向RM中提交程序 </li><li>RM向NM中分配一个container，并在该container中启动AM </li><li>AM向RM注册，这样用户可以直接通过RM査看应用程序的运行状态(然后它将为各个任务申请资源，并监控它的运行状态，直到运行结束) </li><li>AM采用轮询的方式通过RPC协议向RM申请和领取资源，资源的协调通过异步完成 </li><li>AM申请到资源后，便与对应的NM通信，要求它启动任务 </li><li>NM为任务设置好运行环境(包括环境变量、JAR包、二进制程序等)后，将任务启动命令写到一个脚本中，并通过运行该脚本启动任务 </li><li>各个任务通过某个RPC协议向AM汇报自己的状态和进度，以让AM随时掌握各个任务的运行状态，从而可以在任务失败时重新启动任务 </li><li>应用程序运行完成后，AM向RM注销并关闭自己</li></ol><h1 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h1><h2 id="FIFO-Scheduler-先进先出调度器"><a href="#FIFO-Scheduler-先进先出调度器" class="headerlink" title="FIFO Scheduler(先进先出调度器)"></a>FIFO Scheduler(先进先出调度器)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;FIFO Scheduler把应用按提交的顺序排成一个队列，这是一个先进先出队列，在进行资源分配的时候，先给队列中最头上的应用进行分配资源，待最头上的应用需求满足后再给下一个分配，以此类推。FIFO Scheduler是最简单也是最容易理解的调度器，也不需要任何配置，但它并不适用于共享集群。大的应用可能会占用所有集群资源，这就导致其它应用被阻塞。在共享集群中，更适合采用Capacity Scheduler或Fair Scheduler，这两个调度器都允许大任务和小任务在提交的同时获得一定的系统资源。下面“Yarn调度器对比图”展示了这几个调度器的区别，从图中可以看出，在FIFO 调度器中，小任务会被大任务阻塞。</p><p><img src="/images/yarn-先进先出调度器.png"></p><h2 id="Capacity-Scheduler-容量调度器"><a href="#Capacity-Scheduler-容量调度器" class="headerlink" title="Capacity Scheduler(容量调度器)"></a>Capacity Scheduler(容量调度器)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;yarn-site.xml中默认配置的资源调度器。而对于Capacity调度器，有一个专门的队列用来运行小任务，但是为小任务专门设置一个队列会预先占用一定的集群资源，这就导致大任务的执行时间会落后于使用FIFO调度器时的时间。用这个资源调度器，就可以配置yarn资源队列，这个后面后介绍用到。</p><p><img src="/images/yarn-容量调度器.png"></p><h2 id="FairS-cheduler-公平调度器"><a href="#FairS-cheduler-公平调度器" class="headerlink" title="FairS cheduler(公平调度器)"></a>FairS cheduler(公平调度器)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Fair调度器的设计目标是为所有的应用分配公平的资源（对公平的定义可以通过参数来设置）。在上面的“Yarn调度器对比图”展示了一个队列中两个应用的公平调度；当然，公平调度在也可以在多个队列间工作。举个例子，假设有两个用户A和B，他们分别拥有一个队列。当A启动一个job而B没有任务时，A会获得全部集群资源；当B启动一个job后，A的job会继续运行，不过一会儿之后两个任务会各自获得一半的集群资源。如果此时B再启动第二个job并且其它job还在运行，则它将会和B的第一个job共享B这个队列的资源，也就是B的两个job会用于四分之一的集群资源，而A的job仍然用于集群一半的资源，结果就是资源最终在两个用户之间平等的共享。在Fair调度器中，我们不需要预先占用一定的系统资源，Fair调度器会为所有运行的job动态的调整系统资源。当第一个大job提交时，只有这一个job在运行，此时它获得了所有集群资源；当第二个小任务提交后，Fair调度器会分配一半资源给这个小任务，让这两个任务公平的共享集群资源。</p><ul><li>公平调度器，就是能够共享整个集群的资源</li><li>不用预先占用资源，每一个作业都是共享的</li><li>每当提交一个作业的时候，就会占用整个资源。如果再提交一个作业，那么第一个作业就会分给第二个作业一部分资源，第一个作业也就释放一部分资源。再提交其他的作业时，也同理。。。。也就是说每一个作业进来，都有机会获取资源。</li></ul><p><img src="/images/yarn-公平调度器.png"></p><p>假设我们有如下层次的队列</p><ul><li>root<ul><li>prod</li><li>dev<ul><li>mapreduce</li><li>spark</li></ul></li></ul></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;下面是一个简单的 Capacity 调度器的配置文件，文件名为 capacity-scheduler.xml。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;在这个配置中，在 root 队列下面定义了两个子队列 prod 和 dev，分别占 40%和 60%的容量。<br>需要注意，一个队列的配置是通过属性 yarn.sheduler.capacity.<queue-path>.<sub- property="">指定的，<queue-path>代表的是队列的继承树，如 root.prod 队列，<sub-property>一般指 capacity 和 maximum-capacity。</sub-property></queue-path></sub-></queue-path></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.capacity.root.queues<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>prod,dev<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.capacity.root.dev.queues<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce,spark<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.capacity.root.prod.capacity<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>40<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.capacity.root.dev.capacity<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>60<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.capacity.root.dev.maximum-capacity<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>75<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.capacity.root.dev.mapreduce.capacity<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>50<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.capacity.root.dev.spark.capacity<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>50<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;dev 队列又被分成了 mapreduce 和 spark 两个相同容量的子队列。dev的 maximum-capacity 属性被设置成了 75%，所以即使 prod 队列完全空闲 dev 也不会占用全部集群资源，也就是说，prod 队列仍有 25%的可用资源用来应急。我们注意到，mapreduce和 spark 两个队列没有设置 maximum-capacity 属性，也就是说 mapreduce 或 spark 队列中的 job 可能会用到整个 dev 队列的所有资源（最多为集群的 75%）。而类似的，prod 由于没有设置 maximum-capacity 属性，它有可能会占用集群全部资源。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;关于队列的设置，这取决于我们具体的应用。比如，在 MapReduce 中，我们可以通过mapreduce.job.queuename 属性指定要用的队列。如果队列不存在，我们在提交任务时就会收到错误。如果我们没有定义任何队列，所有的应用将会放在一个 default 队列中。</p>]]></content>
    
    <summary type="html">
    
      大数据调度
    
    </summary>
    
      <category term="大数据" scheme="http://langonggong.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="YARN" scheme="http://langonggong.com/tags/YARN/"/>
    
      <category term="大数据" scheme="http://langonggong.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>spark简介</title>
    <link href="http://langonggong.com/2020/06/22/spark%E7%AE%80%E4%BB%8B/"/>
    <id>http://langonggong.com/2020/06/22/spark简介/</id>
    <published>2020-06-22T15:10:25.000Z</published>
    <updated>2020-06-22T16:46:30.308Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Spark 是使用 scala 实现的基于内存计算的大数据开源集群计算环境。提供了 java,scala, python,R 等语言的调用接口</p><h2 id="Hadoop-和-Spark-的关系"><a href="#Hadoop-和-Spark-的关系" class="headerlink" title="Hadoop 和 Spark 的关系"></a>Hadoop 和 Spark 的关系</h2><p>Google 在 2003 年和 2004 年先后发表了 Google 文件系统 GFS 和 MapReduce 编程模型两篇文章。 基于这两篇开源文档,06 年 Nutch 项目子项目之一的 Hadoop 实现了两个强有力的开源产品:HDFS 和 MapReduce. Hadoop 成为了典型的大数据批量处理架构,由 HDFS 负责静态数据的存储,并通过 MapReduce 将计算逻辑分配到各数据节点进行数据计算和价值发现。之后以 HDFS 和 MapReduce 为基础建立了很多项目，形成了 Hadoop 生态圈。<br>　　而 Spark 则是UC Berkeley AMP lab (加州大学伯克利分校AMP实验室)所开源的类Hadoop MapReduce的通用并行框架, 专门用于大数据量下的迭代式计算。是为了跟 Hadoop 配合而开发出来的，不是为了取代 Hadoop。Spark 运算比 Hadoop 的 MapReduce 框架快的原因是因为 Hadoop 在一次 MapReduce 运算之后，会将数据的运算结果从内存写入到磁盘中，第二次 Mapredue 运算时在从磁盘中读取数据，所以其瓶颈在2次运算间的多余 IO 消耗.。Spark 则是将数据一直缓存在内存中,直到计算得到最后的结果,再将结果写入到磁盘，所以多次运算的情况下，Spark 是比较快的。其优化了迭代式工作负载<br>　　<br><img src="/images/hadoop-vs-spark.png"></p><h2 id="基本模块"><a href="#基本模块" class="headerlink" title="基本模块"></a>基本模块</h2><p><img src="/images/spark-module.png"></p><ul><li>Spark Core：包含Spark的基本功能；尤其是定义RDD的API、操作以及这两者上的动作。其他Spark的库都是构建在RDD和Spark Core之上的</li><li>Spark SQL：提供通过Apache Hive的SQL变体Hive查询语言（HiveQL）与Spark进行交互的API。每个数据库表被当做一个RDD，Spark SQL查询被转换为Spark操作。</li><li>Spark Streaming：对实时数据流进行处理和控制。Spark Streaming允许程序能够像普通RDD一样处理实时数据</li><li>MLlib：一个常用机器学习算法库，算法被实现为对RDD的Spark操作。这个库包含可扩展的学习算法，比如分类、回归等需要对大量数据集进行迭代的操作。</li><li>GraphX：控制图、并行图操作和计算的一组算法和工具的集合。GraphX扩展了RDD API，包含控制图、创建子图、访问路径上所有顶点的操作</li></ul><p>Spark 的主要特点还包括:</p><ul><li>提供 Cache 机制来支持需要反复迭代计算或者多次数据共享,减少数据读取的 IO 开销;</li><li>提供了一套支持 DAG 图的分布式并行计算的编程框架,减少多次计算之间中间结果写到 Hdfs 的开销;</li><li>使用多线程池模型减少 Task 启动开稍, shuffle 过程中避免不必要的 sort 操作并减少磁盘 IO 操作。(Hadoop 的 Map 和 reduce 之间的 shuffle 需要 sort)</li></ul><h1 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h1><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><p>Spark 集群由集群管理器 Cluster Manager、工作节点 Worker、执行器 Executor、驱动器 Driver、应用程序 Application 等部分组成。</p><p><img src="/images/spark-framework.png"></p><p><strong>Cluter Manager</strong></p><p>Spark 的集群管理器，主要负责对整个集群资源的分配和管理。根据部署模式的不同，可以分为如下：</p><ul><li>Hadoop YARN: 主要是指 YARN 中的 ResourceManager。YARN 是 Hadoop2.0 中引入的集群管理器，可以让多种数据处理框架运行在一个共享的资源池上，让 Spark 运行在配置了 YARN 的集群上是一个非常好的选择，可以利用 YARN 来管理资源。</li><li>Apache Mesos：主要是指 Mesos Master。Mesos 起源于Berkeley AMP实验室，是一个通用的集群管理器。能够将CPU、内存、存储以及其它计算资源由设备（物理或虚拟）中抽象出来，形成一个池的逻辑概念，从而实现高容错与弹性分布式系统的轻松构建与高效运行。</li><li>Standalone：主要是指 Standalone Master。Standalone Master 是 spark 原生的资源管理，由Master负责资源的分配。</li></ul><p><strong>Worker</strong></p><p>Spark 的工作节点，用于执行提交的作业。在 YARN 部署模式下 Worker 由 NodeManager 代替。<br>Worker 有如下作用：</p><ul><li>通过注册机制向 Cluster Master 汇报自身的 cpu 和 memory 等资源</li><li>在 Master 的指示下创建启动 Executor，Executor 是执行真正计算的苦力</li><li>将资源和任务进一步分配给 Executor</li><li>同步资源信息、Executor 状态信息给 Cluster Master</li></ul><p><strong>Executor</strong><br>真正执行计算任务的组件。<br>Executor 是某个 Application 运行在 Worker 节点上的一个进程，该进程负责运行某些 Task， 并且负责将数据存到内存或磁盘上，每个 Application 都有各自独立的一批 Executor， 在 Spark on Yarn 模式下，其进程名称为 CoarseGrainedExecutor Backend。一个 CoarseGrainedExecutor Backend 有且仅有一个 Executor 对象， 负责将 Task 包装成 taskRunner，并从线程池中抽取一个空闲线程运行 Task， 每个 CoarseGrainedExecutorBackend 能并行运行 Task 的数量取决于分配给它的 CPU 的个数。</p><p><strong>Driver</strong><br>Application 的驱动程序。可以理解为使程序运行中的 main 函数，它会创建 SparkContext。Application 通过 Driver 与 Cluster Master 和 Executor 进行通信。Driver 可以运行在 Application 中，也可以由 Application 提交给 Cluster Master，由 Cluster Master 安排 Worker 运行。<br>Driver 的作用：</p><ul><li>运行应用程序的 main 函数</li><li>创建 Spark 的上下文</li><li>划分 RDD 并生成有向无环图（DAGScheduler）</li><li>与 Spark 中的其他组进行协调，协调资源等等（SchedulerBackend）</li><li>生成并发送 task 到 executor（taskScheduler）</li></ul><p><strong>Application</strong><br>用户使用 Spark API 编写的的应用程序，其中包括一个 Driver 功能的代码和分布在集群中多个节点上运行的 Executor 代码。<br>Application 通过 Spark API 创建 RDD，对 RDD 进行转换，创建 DAG，并通过 Driver 将 Application 注册到 Cluster Master。</p><h1 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h1><p><img src="/images/spark-run.png"></p><ul><li>构建Spark Application的运行环境，启动SparkContext</li><li>SparkContext向资源管理器（可以是Standalone，Mesos，Yarn）申请运行Executor资源，并启动StandaloneExecutorbackend，</li><li>Executor向SparkContext申请Task</li><li>SparkContext将应用程序分发给Executor</li><li>SparkContext构建成DAG图，将DAG图分解成Stage、将Taskset发送给Task Scheduler，最后由Task Scheduler将Task发送给Executor运行</li><li>Task在Executor上运行，运行完释放所有资源</li></ul><p>Spark运行特点：</p><ul><li>每个Application获取专属的executor进程，该进程在Application期间一直驻留，并以多线程方式运行Task。这种Application隔离机制是有优势的，无论是从调度角度看（每个Driver调度他自己的任务），还是从运行角度看（来自不同Application的Task运行在不同JVM中），当然这样意味着Spark Application不能跨应用程序共享数据，除非将数据写入外部存储系统</li><li>Spark与资源管理器无关，只要能够获取executor进程，并能保持相互通信就可以了</li><li>提交SparkContext的Client应该靠近Worker节点（运行Executor的节点），最好是在同一个Rack里，因为Spark Application运行过程中SparkContext和Executor之间有大量的信息交换</li><li>Task采用了数据本地性和推测执行的优化机制</li></ul><h1 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>RDD 是 Spark 提供的最重要的抽象概念，它是一种有容错机制的特殊数据集合，可以分布在集群的结点上，以函数式操作集合的方式进行各种并行操作。</p><p>通俗点来讲，可以将 RDD 理解为一个分布式对象集合，本质上是一个只读的分区记录集合。每个 RDD 可以分成多个分区，每个分区就是一个数据集片段。一个 RDD 的不同分区可以保存到集群中的不同结点上，从而可以在集群中的不同结点上进行并行计算。</p><p>如图展示了 RDD 的分区及分区与工作结点（Worker Node）的分布关系。</p><p><img src="/images/rdd-worknode.png"></p><p>RDD 具有容错机制，并且只读不能修改，可以执行确定的转换操作创建新的 RDD。具体来讲，RDD 具有以下几个属性。</p><ul><li>只读：不能修改，只能通过转换操作生成新的 RDD。</li><li>分布式：可以分布在多台机器上进行并行处理。</li><li>弹性：计算过程中内存不够时它会和磁盘进行数据交换。</li><li>基于内存：可以全部或部分缓存在内存中，在多次计算间重用。</li></ul><p>RDD 实质上是一种更为通用的迭代并行计算框架，用户可以显示控制计算的中间结果，然后将其自由运用于之后的计算。</p><p>在大数据实际应用开发中存在许多迭代算法，如机器学习、图算法等，和交互式数据挖掘工具。这些应用场景的共同之处是在不同计算阶段之间会重用中间结果，即一个阶段的输出结果会作为下一个阶段的输入。</p><p>RDD 正是为了满足这种需求而设计的。虽然 MapReduce 具有自动容错、负载平衡和可拓展性的优点，但是其最大的缺点是采用非循环式的数据流模型，使得在迭代计算时要进行大量的磁盘 I/O 操作。</p><p>通过使用 RDD，用户不必担心底层数据的分布式特性，只需要将具体的应用逻辑表达为一系列转换处理，就可以实现管道化，从而避免了中间结果的存储，大大降低了数据复制、磁盘 I/O 和数据序列化的开销。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>RDD 的操作分为转化（Transformation）操作和行动（Action）操作。转化操作就是从一个 RDD 产生一个新的 RDD，而行动操作就是进行实际的计算。</p><p>RDD 的操作是惰性的，当 RDD 执行转化操作的时候，实际计算并没有被执行，只有当 RDD 执行行动操作时才会促发计算任务提交，从而执行相应的计算操作。</p><h3 id="构建操作"><a href="#构建操作" class="headerlink" title="构建操作"></a>构建操作</h3><p>Spark 里的计算都是通过操作 RDD 完成的，学习 RDD 的第一个问题就是如何构建 RDD，构建 RDD 的方式从数据来源角度分为以下两类。</p><ul><li>从内存里直接读取数据。</li><li>从文件系统里读取数据，文件系统的种类很多，常见的就是 HDFS 及本地文件系统。</li></ul><p>第一类方式是从内存里构造 RDD，需要使用 makeRDD 方法，代码如下所示。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val rdd01 = sc.makeRDD(List(l,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br></pre></td></tr></table></figure><p>这个语句创建了一个由“1,2,3,4,5,6”六个元素组成的 RDD。</p><p>第二类方式是通过文件系统构造 RDD，代码如下所示。</p><p>val rdd:RDD[String] == sc.textFile(“file:///D:/sparkdata.txt”,1)</p><p>这里例子使用的是本地文件系统，所以文件路径协议前缀是 file://。</p><h3 id="转换操作"><a href="#转换操作" class="headerlink" title="转换操作"></a>转换操作</h3><p>RDD 的转换操作是返回新的 RDD 的操作。转换出来的 RDD 是惰性求值的，只有在行动操作中用到这些 RDD 时才会被计算。</p><p>许多转换操作都是针对各个元素的，也就是说，这些转换操作每次只会操作 RDD 中的一个元素，不过并不是所有的转换操作都是这样的。表 1 描述了常用的 RDD 转换操作。</p><center>表 1 RDD转换操作（rdd1={1, 2, 3, 3}，rdd2={3,4,5})</center><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">说明</th><th style="text-align:center">表达式</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">map()</td><td style="text-align:center">将函数应用于 RDD 的每个元素，返回值是新的 RDD</td><td style="text-align:center">rdd1.map(x=&gt;x+l)</td><td style="text-align:center">{2,3,4,4}</td></tr><tr><td style="text-align:center">flatMap()</td><td style="text-align:center">将函数应用于 RDD 的每个元素，将元素数据进行拆分，变成迭代器，返回值是新的 RDD</td><td style="text-align:center">rdd1.flatMap(x=&gt;x.to(3))</td><td style="text-align:center">{1,2,3,2,3,3,3}</td></tr><tr><td style="text-align:center">filter()</td><td style="text-align:center">函数会过滤掉不符合条件的元素，返回值是新的 RDD</td><td style="text-align:center">rdd1.filter(x=&gt;x!=1)</td><td style="text-align:center">{2,3,3}</td></tr><tr><td style="text-align:center">distinct()</td><td style="text-align:center">将 RDD 里的元素进行去重操作</td><td style="text-align:center">rdd1.distinct()</td><td style="text-align:center">(1,2,3)</td></tr><tr><td style="text-align:center">union()</td><td style="text-align:center">生成包含两个 RDD 所有元素的新的 RDD</td><td style="text-align:center">rdd1.union(rdd2)</td><td style="text-align:center">{1,2,3,3,3,4,5}</td></tr><tr><td style="text-align:center">intersection()</td><td style="text-align:center">求出两个 RDD 的共同元素</td><td style="text-align:center">rdd1.intersection(rdd2)</td><td style="text-align:center">{3}</td></tr><tr><td style="text-align:center">subtract()</td><td style="text-align:center">将原 RDD 里和参数 RDD 里相同的元素去掉</td><td style="text-align:center">rdd1.subtract(rdd2)</td><td style="text-align:center">{1,2}</td></tr><tr><td style="text-align:center">cartesian()</td><td style="text-align:center">求两个 RDD 的笛卡儿积</td><td style="text-align:center">rdd1.cartesian(rdd2)</td><td style="text-align:center">{(1,3),(1,4)……(3,5)}</td></tr></tbody></table></div><h3 id="行动操作"><a href="#行动操作" class="headerlink" title="行动操作"></a>行动操作</h3><p>行动操作用于执行计算并按指定的方式输出结果。行动操作接受 RDD，但是返回非 RDD，即输出一个值或者结果。在 RDD 执行过程中，真正的计算发生在行动操作。表 2 描述了常用的 RDD 行动操作。</p><center>表 2 RDD 行动操作（rdd={1,2,3,3}）</center><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">说明</th><th style="text-align:center">表达式</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">collect()</td><td style="text-align:center">返回 RDD 的所有元素</td><td style="text-align:center">rdd.collect()</td><td style="text-align:center">{1,2,3,3}</td></tr><tr><td style="text-align:center">count()</td><td style="text-align:center">RDD 里元素的个数</td><td style="text-align:center">rdd.count()</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">countByValue()</td><td style="text-align:center">各元素在 RDD 中的出现次数</td><td style="text-align:center">rdd.countByValue()</td><td style="text-align:center">{(1,1),(2,1),(3,2})}</td></tr><tr><td style="text-align:center">take(num)</td><td style="text-align:center">从 RDD 中返回 num 个元素</td><td style="text-align:center">rdd.take(2)</td><td style="text-align:center">{1,2}</td></tr><tr><td style="text-align:center">top(num)</td><td style="text-align:center">从 RDD 中，按照默认（降序）或者指定的排序返回最前面的 num 个元素</td><td style="text-align:center">rdd.top(2)</td><td style="text-align:center">{3,3}</td></tr><tr><td style="text-align:center">reduce()</td><td style="text-align:center">并行整合所有 RDD 数据，如求和操作</td><td style="text-align:center">rdd.reduce((x,y)=&gt;x+y)</td><td style="text-align:center">9</td></tr><tr><td style="text-align:center">fold(zero)(func)</td><td style="text-align:center">和 reduce() 功能一样，但需要提供初始值</td><td style="text-align:center">rdd.fold(0)((x,y)=&gt;x+y)</td><td style="text-align:center">9</td></tr><tr><td style="text-align:center">foreach(func)</td><td style="text-align:center">对 RDD 的每个元素都使用特定函数</td><td style="text-align:center">rdd1.foreach(x=&gt;printIn(x))</td><td style="text-align:center">打印每一个元素</td></tr><tr><td style="text-align:center">saveAsTextFile(path)</td><td style="text-align:center">将数据集的元素，以文本的形式保存到文件系统中</td><td style="text-align:center">rdd1.saveAsTextFile(file://home/test)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">saveAsSequenceFile(path)</td><td style="text-align:center">将数据集的元素，以顺序文件格式保存到指 定的目录下</td><td style="text-align:center">saveAsSequenceFile(hdfs://home/test)</td></tr></tbody></table></div><p> aggregate() 函数的返回类型不需要和 RDD 中的元素类型一致，所以在使用时，需要提供所期待的返回类型的初始值，然后通过一个函数把 RDD 中的元素累加起来放入累加器。</p><p>考虑到每个结点都是在本地进行累加的，所以最终还需要提供第二个函数来将累加器两两合并。</p><p>aggregate(zero)(seqOp,combOp) 函数首先使用 seqOp 操作聚合各分区中的元素，然后再使用 combOp 操作把所有分区的聚合结果再次聚合，两个操作的初始值都是 zero。</p><p>seqOp 的操作是遍历分区中的所有元素 T，第一个 T 跟 zero 做操作，结果再作为与第二个 T 做操作的 zero，直到遍历完整个分区。</p><p>combOp 操作是把各分区聚合的结果再聚合。aggregate() 函数会返回一个跟 RDD 不同类型的值。因此，需要 seqOp 操作来把分区中的元素 T 合并成一个 U，以及 combOp 操作把所有 U 聚合。</p><p>下面举一个利用 aggreated() 函数求平均数的例子。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val rdd = List (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">val input = sc.parallelize(rdd)</span><br><span class="line">val result = input.aggregate((<span class="number">0</span>,<span class="number">0</span>))(</span><br><span class="line">    (acc,value) =&gt; (acc<span class="meta">._1</span> + value,acc<span class="meta">._2</span> + <span class="number">1</span>),</span><br><span class="line">    (acc1,acc2) =&gt; (acc1<span class="meta">._1</span> + acc2<span class="meta">._1</span>,acc1<span class="meta">._2</span> + acc2<span class="meta">._2</span>)</span><br><span class="line">)</span><br><span class="line"><span class="symbol">result:</span>(<span class="keyword">Int</span>,<span class="keyword">Int</span>) = (<span class="number">10</span>,<span class="number">4</span>)</span><br><span class="line">val avg = result<span class="meta">._1</span> / result<span class="meta">._2</span></span><br><span class="line"><span class="symbol">avg:</span><span class="keyword">Int</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure><p>程序的详细过程大概如下。</p><p>定义一个初始值 (0,0)，即所期待的返回类型的初始值。代码 (acc,value) =&gt; (acc._1 + value,acc._2 + 1) 中的 value 是函数定义里面的 T，这里是 List 里面的元素。acc._1 + value，acc._2 + 1 的过程如下。<br>(0+1,0+1)→(1+2,1+1)→(3+3,2+1)→(6+4,3+1)，结果为(10,4)。</p><p>实际的 Spark 执行过程是分布式计算，可能会把 List 分成多个分区，假如是两个：p1(1,2) 和 p2(3,4)。</p><p>经过计算，各分区的结果分别为 (3,2) 和 (7,2)。这样，执行 (acc1,acc2) =&gt; (acc1._1 + acc2._2,acc1._2 + acc2._2) 的结果就是 (3+7,2+2)，即 (10,4)，然后可计算平均值。</p><h2 id="血缘关系"><a href="#血缘关系" class="headerlink" title="血缘关系"></a>血缘关系</h2><p>RDD 的最重要的特性之一就是血缘关系（Lineage )，它描述了一个 RDD 是如何从父 RDD 计算得来的。如果某个 RDD 丢失了，则可以根据血缘关系，从父 RDD 计算得来。</p><p>如图给出了一个 RDD 执行过程的实例。系统从输入中逻辑上生成了 A 和 C 两个 RDD， 经过一系列转换操作，逻辑上生成了 F 这个 RDD。</p><p>Spark 记录了 RDD 之间的生成和依赖关系。当 F 进行行动操作时，Spark 才会根据 RDD 的依赖关系生成 DAG，并从起点开始真正的计算。</p><p><img src="/images/spark-lineage.png"></p><p>上述一系列处理称为一个血缘关系（Lineage），即 DAG 拓扑排序的结果。在血缘关系中，下一代的 RDD 依赖于上一代的 RDD。例如，在图 2 中，B 依赖于 A，D 依赖于 C，而 E 依赖于 B 和 D。</p><h2 id="依赖类型"><a href="#依赖类型" class="headerlink" title="依赖类型"></a>依赖类型</h2><p>根据不同的转换操作，RDD 血缘关系的依赖分为窄依赖和宽依赖。窄依赖是指父 RDD 的每个分区都只被子 RDD 的一个分区所使用。宽依赖是指父 RDD 的每个分区都被多个子 RDD 的分区所依赖。</p><p>map、filter、union 等操作是窄依赖，而 groupByKey、reduceByKey 等操作是宽依赖，如图  所示。</p><p><img src="/images/spark-dependency.png"></p><p>join 操作有两种情况，如果 join 操作中使用的每个 Partition 仅仅和固定个 Partition 进行 join，则该 join 操作是窄依赖，其他情况下的 join 操作是宽依赖。</p><p>所以可得出一个结论，窄依赖不仅包含一对一的窄依赖，还包含一对固定个数的窄依赖，也就是说，对父 RDD 依赖的 Partition 不会随着 RDD 数据规模的改变而改变。</p><h3 id="窄依赖"><a href="#窄依赖" class="headerlink" title="窄依赖"></a>窄依赖</h3><ul><li>子 RDD 的每个分区依赖于常数个父分区（即与数据规模无关)。</li><li>输入输出一对一的算子，且结果 RDD 的分区结构不变，如 map、flatMap。</li><li>输入输出一对一的算子，但结果 RDD 的分区结构发生了变化，如 union。</li><li>从输入中选择部分元素的算子，如 filter、distinct、subtract、sample。</li></ul><h3 id="宽依赖"><a href="#宽依赖" class="headerlink" title="宽依赖"></a>宽依赖</h3><ul><li>子 RDD 的每个分区依赖于所有父 RDD 分区。</li><li>对单个 RDD 基于 Key 进行重组和 reduce，如 groupByKey、reduceByKey。</li><li>对两个 RDD 基于 Key 进行 join 和重组，如 join。</li></ul><p>Spark 的这种依赖关系设计，使其具有了天生的容错性，大大加快了 Spark 的执行速度。RDD 通过血缘关系记住了它是如何从其他 RDD 中演变过来的。当这个 RDD 的部分分区数据丢失时，它可以通过血缘关系获取足够的信息来重新运算和恢复丢失的数据分区，从而带来性能的提升。</p><p>相对而言，窄依赖的失败恢复更为高效，它只需要根据父 RDD 分区重新计算丢失的分区即可，而不需要重新计算父 RDD 的所有分区。而对于宽依赖来讲，单个结点失效，即使只是 RDD 的一个分区失效，也需要重新计算父 RDD 的所有分区，开销较大。</p><p>宽依赖操作就像是将父 RDD 中所有分区的记录进行了“洗牌”，数据被打散，然后在子 RDD 中进行重组。</p><h2 id="阶段划分"><a href="#阶段划分" class="headerlink" title="阶段划分"></a>阶段划分</h2><p>用户提交的计算任务是一个由 RDD 构成的 DAG，如果 RDD 的转换是宽依赖，那么这个宽依赖转换就将这个 DAG 分为了不同的阶段（Stage)。由于宽依赖会带来“洗牌”，所以不同的 Stage 是不能并行计算的，后面 Stage 的 RDD 的计算需要等待前面 Stage 的 RDD 的所有分区全部计算完毕以后才能进行。</p><p>这点就类似于在 MapReduce 中，Reduce 阶段的计算必须等待所有 Map 任务完成后才能开始一样。</p><p>在对 Job 中的所有操作划分 Stage 时，一般会按照倒序进行，即从 Action 开始，遇到窄依赖操作，则划分到同一个执行阶段，遇到宽依赖操作，则划分一个新的执行阶段。后面的 Stage 需要等待所有的前面的 Stage 执行完之后才可以执行，这样 Stage 之间根据依赖关系就构成了一个大粒度的 DAG。</p><p>下面如图详细解释一下阶段划分。</p><p>假设从 HDFS 中读入数据生成 3 个不同的 RDD(A、C 和 E)，通过一系列转换操作后得到新的 RDD(G)，并把结果保存到 HDFS 中。可以看到这幅 DAG 中只有 join 操作是一个宽依赖，Spark 会以此为边界将其前后划分成不同的阶段。</p><p>同时可以注意到，在 Stage2 中，从 map 到 union 都是窄依赖，这两步操作可以形成一个流水线操作，通过 map 操作生成的分区可以不用等待整个 RDD 计算结束，而是继续进行 union 操作，这样大大提高了计算的效率。</p><p><img src="/images/spark-stage.png"></p><p>把一个 DAG 图划分成多个 Stage 以后，每个 Stage 都代表了一组由关联的、相互之间没有宽依赖关系的任务组成的任务集合。在运行的时候，Spark 会把每个任务集合提交给任务调度器进行处理。</p>]]></content>
    
    <summary type="html">
    
      spark简介
    
    </summary>
    
      <category term="大数据" scheme="http://langonggong.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://langonggong.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="spark" scheme="http://langonggong.com/tags/spark/"/>
    
      <category term="hadoop" scheme="http://langonggong.com/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Damerau–Levenshtein distance</title>
    <link href="http://langonggong.com/2019/11/16/Damerau%E2%80%93Levenshtein-distance/"/>
    <id>http://langonggong.com/2019/11/16/Damerau–Levenshtein-distance/</id>
    <published>2019-11-16T10:06:22.000Z</published>
    <updated>2020-06-22T16:40:36.954Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h1><p>Damerau–Levenshtein distance（D氏距离）对比L氏距离，还新增了交换操作（响铃两个字符的交换），一共包含了新增、删除、替换、交换四种编辑操作。计算公式如下</p><p><img src="/images/Damerau–Levenshtein distance公式.png"></p><p>该公式的最后一步，表示a字符串前i个字符序列可以通过相邻两个</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>将abc转换为acb<br>Levenshtein Distance算法解决方法如下：<br>方法一：</p><p><img src="/images/Damerau–Levenshtein distance示例步骤1.png"></p><p>abc-&gt;acc（将字符b替换成字符c）<br>acc-&gt;acb（将字符c替换成字符b）<br>一共进行两次字符替换操作<br>方法二：</p><p><img src="/images/Damerau–Levenshtein distance示例步骤2.png"></p><p>abc-&gt;ac（删除字符b）<br>ac-&gt;acb（新增字符b）<br>先删除中间的字符b，再在末尾添加字符b<br>方法三：</p><p><img src="/images/Damerau–Levenshtein distance示例步骤3.png"></p><p>abc-&gt;acbc（新增字符c）<br>acbc-&gt;acb（删除字符c）<br>先新增字符c，再删除末尾的字符c</p><p>Damerau–Levenshtein distance算法解决过程如下：</p><p><img src="/images/Damerau–Levenshtein distance示例结果图.png"></p><p>将b字符和c字符替换即可，满足条件</p><p><img src="/images/Damerau–Levenshtein distance交换.png"></p>]]></content>
    
    <summary type="html">
    
      Damerau–Levenshtein distance
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://langonggong.com/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://langonggong.com/tags/Elasticsearch/"/>
    
      <category term="Lucune" scheme="http://langonggong.com/tags/Lucune/"/>
    
      <category term="编辑距离" scheme="http://langonggong.com/tags/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>Levenshtein Distance</title>
    <link href="http://langonggong.com/2019/11/16/Levenshtein-Distance/"/>
    <id>http://langonggong.com/2019/11/16/Levenshtein-Distance/</id>
    <published>2019-11-16T09:46:00.000Z</published>
    <updated>2020-06-22T16:40:36.957Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h1><p>Levenshtein Distance（L氏距离）是一个度量两个字符序列之间差异的字符串度量标准，两个单词之间的Levenshtein Distance是将一个单词转换为另一个单词所需的单字符编辑（插入、删除或替换）的最小数量</p><p>例如：将单词abroad转换为aboarc</p><ul><li>abroad-&gt;aboad（删除字符r）</li><li>aboad-&gt;aboard（插入字符r）</li><li>aboard-&gt;aboarc（将字符d替换为字符c）</li></ul><p>编辑距离为3</p><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><p>对于两个字符串a、b，长度分别为|a|、|b|，i、j分别为a、b的下标值，它们的Levenshtein Distance 为：</p><p><img src="/images/Levenshtein Distance公式.png"></p><p>表示字符串a的前i个字符序列转换为字符串b的前j个字符序列所需要的最短的编辑距离</p><p>1、空字符串与任意非空字符串的编剧距离等于非空字符串的长度</p><p><img src="/images/Levenshtein Distance空字符.png"></p><p><img src="/images/Levenshtein Distance空字符矩阵.png"></p><p>如图第二行，将空字符串转换为k需要插入一个字符，编辑距离为1；<br>将空字符串转化为kf，需要插入两个字符，编辑距离为2；<br>如图第二列，将k转换为空字符串，需要删除一个字符，编辑距离为1；<br>将kc转换为空字符串，需要删除两个字符，编辑距离为2</p><p>2、删除一个字符</p><p><img src="/images/Levenshtein Distance删除.png"></p><p><img src="/images/Levenshtein Distance删除矩阵.png"></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">"kfc"</span>,b=<span class="string">"kc"</span>,i=<span class="number">2</span>,j=<span class="number">1</span>,</span><br><span class="line">lev(<span class="number">1</span>,<span class="number">1</span>)等同于将字符串a中的<span class="string">"k"</span>转换为字符串b中的<span class="string">"k"</span>，编辑距离为<span class="number">0</span></span><br><span class="line">lev(<span class="number">2</span>,<span class="number">1</span>)等同于将字符串a中的<span class="string">"kf"</span>转换为字符串b中的<span class="string">"k"</span>，编辑距离为<span class="number">1</span>，需要一步删除操作</span><br><span class="line">lev(i,j)=lev(<span class="number">2</span>,<span class="number">1</span>)=lev(<span class="number">1</span>,<span class="number">1</span>)+<span class="number">1</span>=<span class="number">0</span>+<span class="number">1</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>由图像可知：在前一行的编辑距离上加一</p><p>3、新增一个字符</p><p><img src="/images/Levenshtein Distance新增.png"></p><p><img src="/images/Levenshtein Distance新增矩阵.png"></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">"kc"</span>,b=<span class="string">"kfc"</span>,i=<span class="number">1</span>,j=<span class="number">2</span></span><br><span class="line">lev(<span class="number">1</span>,<span class="number">1</span>)等同于将字符串a中的<span class="string">"k"</span>转换为字符串b中的<span class="string">"k"</span>，编辑距离为<span class="number">0</span></span><br><span class="line">lev(<span class="number">1</span>,<span class="number">2</span>)等同于将字符串a中的<span class="string">"k"</span>转换为字符串b中的<span class="string">"kf"</span>，编辑距离为<span class="number">1</span>，需要一步新增操作</span><br><span class="line">lev(i,j)=lev(<span class="number">1</span>,<span class="number">2</span>)=lev(<span class="number">1</span>,<span class="number">1</span>)+<span class="number">1</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>由图像可知：在前一列的编辑距离上加一</p><p>4、当前两个字符相同，编辑距离不变</p><p><img src="/images/Levenshtein Distance不变.png"></p><p><img src="/images/Levenshtein Distance不变矩阵.png"></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">"kc"</span>,b=<span class="string">"kfc"</span>,i=<span class="number">2</span>,j=<span class="number">3</span></span><br><span class="line">lev(<span class="number">1</span>,<span class="number">2</span>)等同于将字符串a中的<span class="string">"k"</span>转换为字符串b中的<span class="string">"kf"</span>，编辑距离为<span class="number">1</span>，需要一步新增操作</span><br><span class="line">lev(<span class="number">2</span>,<span class="number">3</span>)等同于将字符串a中的<span class="string">"kc"</span>转换为字符串b中的<span class="string">"kfc"</span>，编辑距离为<span class="number">1</span></span><br><span class="line">因为字符串a中的c字符等于字符串b中的c字符，所以lev(i,j)=lev(<span class="number">2</span>,<span class="number">3</span>)=lev(<span class="number">1</span>,<span class="number">2</span>)+<span class="number">0</span></span><br></pre></td></tr></table></figure><p>由图像可知：与左上角坐标所示编辑距离相同</p><p>5、当前两个字符不同，替换操作</p><p><img src="/images/Levenshtein Distance替换.png"></p><p><img src="/images/Levenshtein Distance替换矩阵.png"></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">"kc"</span>,b=<span class="string">"kb"</span>,i=j=<span class="number">2</span></span><br><span class="line">lev(<span class="number">1</span>,<span class="number">1</span>)等同于将字符串a中的<span class="string">"k"</span>转换为字符串b中的<span class="string">"k"</span>，编辑距离为<span class="number">0</span></span><br><span class="line">lev(<span class="number">2</span>,<span class="number">2</span>)等同于将字符串a中的<span class="string">"kc"</span>转换为字符串b中的<span class="string">"kb"</span>，编辑距离为<span class="number">1</span>，需要替换一个字符串</span><br></pre></td></tr></table></figure><p>由图像可知：将左上角坐标所示编辑距离加一</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>求最优编辑距离示例：将单词abroad转换为aboarc<br>1、将abr转换为ab，删除字符r</p><p><img src="/images/Levenshtein Distance示例步骤1.png"></p><p>2、将aboa（之前已删除字符r）转换为aboar，新增字符r</p><p><img src="/images/Levenshtein Distance示例步骤2.png"></p><p>3、将aboard转换为aboarc，将字符d替换为字符c</p><p><img src="/images/Levenshtein Distance示例步骤3.png"></p><h1 id="字符串的相似度"><a href="#字符串的相似度" class="headerlink" title="字符串的相似度"></a>字符串的相似度</h1><p><img src="/images/Levenshtein Distance字符串相似度.png"></p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>DNA序列分析、拼写检查、语音辨识、抄袭侦测</p>]]></content>
    
    <summary type="html">
    
      Levenshtein Distance
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://langonggong.com/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://langonggong.com/tags/Elasticsearch/"/>
    
      <category term="Lucune" scheme="http://langonggong.com/tags/Lucune/"/>
    
      <category term="编辑距离" scheme="http://langonggong.com/tags/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>AC自动机</title>
    <link href="http://langonggong.com/2019/11/16/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <id>http://langonggong.com/2019/11/16/AC自动机/</id>
    <published>2019-11-16T09:36:46.000Z</published>
    <updated>2020-06-22T16:40:36.952Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="应用背景"><a href="#应用背景" class="headerlink" title="应用背景"></a>应用背景</h1><p>在互联网应用中，通常会用到关键词检测功能，以防止用户发表包括了指定关键词的内容。如游戏的聊天系统、角色名称检测，论坛发帖、直播弹幕等，都需要对用户发布的内容进行检测，以检测是否包含敏感的关键字。</p><p>通常需要检测的关键词，会有很多很多，比如侮辱人的关键词，政治敏感的关键词，系统相关的特定关键词等。毫不夸张的说，通常要检测的关键词会有几千个，甚至过万。这时效率都变得尤为突出，如果检测关键词的效率低下，对大型互联网应用来说，很可能有是致命的。</p><p>以8000个关键词为例，如果使用正则表达式，则需要对用户发布的内容遍历8000遍。如果同一秒中，有100位，1000位，10000位…用户发布内容，可想而知仅仅在关键词检测方面服务器上CPU的开销。</p><p>AC多模式匹配算法，可以有效的解决关键词检测的效率问题。时间复杂度为O(n),n为用户发布内容的长度n。基本与关键词的数量无关。</p><h1 id="AC算法介绍"><a href="#AC算法介绍" class="headerlink" title="AC算法介绍"></a>AC算法介绍</h1><p>AC算法是一个经典的多模式匹配算法，可以保证对于给定的长度为n的文本，和模式集合P{p1,p2,…pm}，在O(n)时间复杂度内，找到文本中的所有目标模式，而与模式集合的规模m无关。</p><p>AC算法实现原理：<br>ac自动机,就是在tire树的基础上,增加一个fail指针,如果当前点匹配失败,则将指针转移到fail指针指向的地方,这样就不用回溯,而可以路匹配下去了</p><p>举例：<br>如要查找abce和bcd是否在abcd中出现,我们找到c发现下一个要找的不是e,就跳到bcd中的c处,看看此处的下一个字符(d)是不是应该找的那一个<br>因为abc部分的后缀与bcd的部分前缀相同，便能构造fail指针</p><p><img src="/images/fail示例.png"></p><p>完整流程：</p><ul><li>构建敏感词树型结构，并标注结束节点（即是否是一个敏感词的结束）；</li><li>为树上的结点，构建匹配失败时的跳转-失败结点（即匹配失败时，跳转到哪个结点继续匹配）；</li><li>对用户内容进行一次遍历，对于每个字符（字节）都去敏感词树型结构中，从当前结点位置开始匹配。</li></ul><h1 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h1><p>以模式串he,she,him,hers,shit为例，先构造一颗字典树</p><p><img src="/images/AC树.png"></p><p>图像说明</p><ul><li>图中根节点为空节点</li><li>红色节点表示该节点是一个存在的字符串</li><li>蓝色实线连接父子节点</li><li>黄色虚线表示fail指针</li><li>没有标注黄色虚线的节点，fail指针默认都指向根节点</li></ul><p>fail指针构造过程</p><ul><li>第三行的h节点，找到父节点的fail节点的子节点中，与当前节点相同的点，将h的fail指针指向该节点</li><li>第四行的i节点，找他i节点的父节点的fail节点的子节点中是否有i节点</li><li>依次类推</li></ul><h1 id="匹配示例"><a href="#匹配示例" class="headerlink" title="匹配示例"></a>匹配示例</h1><p>拿主串ashers上去匹配</p><p><img src="/images/AC匹配过程.png"></p><ul><li>第三步确定找到she，接续沿着线头则匹配失败，根据fail指针跳转</li><li>第四步找到he，继续往下找</li><li>第六步找到hers，匹配结束</li></ul>]]></content>
    
    <summary type="html">
    
      AC自动机
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://langonggong.com/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://langonggong.com/tags/Elasticsearch/"/>
    
      <category term="树" scheme="http://langonggong.com/tags/%E6%A0%91/"/>
    
      <category term="Lucune" scheme="http://langonggong.com/tags/Lucune/"/>
    
  </entry>
  
  <entry>
    <title>Double Array Trie</title>
    <link href="http://langonggong.com/2019/11/16/Double-Array-Trie/"/>
    <id>http://langonggong.com/2019/11/16/Double-Array-Trie/</id>
    <published>2019-11-16T09:20:56.000Z</published>
    <updated>2020-06-22T16:40:36.955Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>Trie树的创建要考虑的是父节点如何保存孩子节点，主要有链表和数组两种方式：</p><ul><li>使用节点数组，因为是英文字符，可以用Node[26]来保存孩子节点(如果是数字我们可以用Node[10])，这种方式最快，但是并不是所有节点都会有很多孩子，所以这种方式浪费的空间太多</li><li>用一个链表根据需要动态添加节点。这样我们就可以省下不小的空间，但是缺点是搜索的时候需要遍历这个链表，增加了时间复杂度。</li><li>Trie也可以按照DFA的方式存储，即表示为转移矩阵。行表示状态，列表示输入字符，(行, 列)位置表示转移状态。这种方式的查询效率很高，但由于稀疏的现象严重，空间利用效率很低。</li></ul><p>如果是中文词典，子节点的数目范围跨度更大，问题将会更加严重</p><p><img src="/images/字典树父子节点.png"></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>双数组Trie树（Double-array Trie, DAT）是一种Trie树的高效实现，兼顾了查询效率与空间存储</p><p>Double-Array Trie包含base和check两个数组。base数组的每个元素表示一个Trie节点，即一个状态；check数组表示某个状态的前驱状态。<br>其中，s是当前状态的下标，t是转移状态的下标，c是输入字符的数值。如图所示：<br>base和check的关系满足下述条件：<br>base[s] + c = t<br>check[t] = s</p><p><img src="/images/双数组.png"></p><p>以bachelor, baby, badge, jar为例</p><p><img src="/images/双数组示例.png"></p><p>其中，字符的编码表为{‘#’=1, ‘a’=2, ‘b’=3, ‘c’=4, etc. }。为了对Trie做进一步的压缩，用tail数组存储无公共前缀的尾字符串，且满足如下的特点：<br>p = -base[m], tail[p] = b1, tail[p+1] = b2, …, tail[p+h-1] = bh；<br>h为该尾字符串的长度</p><h1 id="检索示例"><a href="#检索示例" class="headerlink" title="检索示例"></a>检索示例</h1><p>检索词badge的过程如下：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// root -&gt; b</span></span><br><span class="line">base[<span class="number">1</span>] + 'b' = <span class="number">4</span> + <span class="number">3</span> = <span class="number">7</span></span><br><span class="line">check[<span class="number">7</span>]=<span class="number">1</span></span><br><span class="line"><span class="comment">// root -&gt; b -&gt; a</span></span><br><span class="line">base[<span class="number">7</span>] + 'a' = <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span></span><br><span class="line">check[<span class="number">3</span>]=<span class="number">7</span></span><br><span class="line"><span class="comment">// root -&gt; b -&gt; a -&gt; d</span></span><br><span class="line">base[<span class="number">3</span>] + 'd' = <span class="number">1</span> + <span class="number">5</span> = <span class="number">6</span></span><br><span class="line">check[<span class="number">6</span>]=<span class="number">3</span></span><br><span class="line"><span class="comment">// badge#</span></span><br><span class="line">base[<span class="number">6</span>] = <span class="number">-12</span></span><br><span class="line">tail[<span class="number">12.</span><span class="number">.14</span>] = 'ge#'</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Double Array Trie
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://langonggong.com/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://langonggong.com/tags/Elasticsearch/"/>
    
      <category term="树" scheme="http://langonggong.com/tags/%E6%A0%91/"/>
    
      <category term="Lucune" scheme="http://langonggong.com/tags/Lucune/"/>
    
  </entry>
  
  <entry>
    <title>字典树</title>
    <link href="http://langonggong.com/2019/11/16/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    <id>http://langonggong.com/2019/11/16/字典树/</id>
    <published>2019-11-16T08:59:24.000Z</published>
    <updated>2020-06-22T16:40:36.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>如果现在有b，abc，abd，bcd，abcd，efg，hii 这7个单词，我们可以构建一棵如下图所示的树：</p><p><img src="/images/字典树.png"></p><p>如上图所示，对于每一个节点，从根遍历到他的过程就是一个单词，如果这个节点被标记为红色，就表示这个单词存在，否则不存在。 </p><p>Trie树，又称字典树，单词查找树或者前缀树，是一种用于快速检索的多叉树结构，如英文字母的字典树是一个26叉树，数字的字典树是一个10叉树。<br>与二叉查找树不同，Trie树的键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p><h2 id="基本性质："><a href="#基本性质：" class="headerlink" title="基本性质："></a>基本性质：</h2><ul><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li><li>每个节点的所有子节点包含的字符都不相同。</li></ul><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>Trie树优点是最大限度地减少无谓的字符串比较，查询效率比较高。核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p><ul><li>插入、查找的时间复杂度均为O(N)，其中N为字符串长度。</li><li>空间复杂度是26^n级别的，非常庞大（可采用双数组实现改善）。</li></ul><h1 id="Trie树的实现"><a href="#Trie树的实现" class="headerlink" title="Trie树的实现"></a>Trie树的实现</h1><p>trie树实际上是一个DFA，通常用转移矩阵表示。行表示状态，列表示输入字符，（行，列）位置表示转移状态。这种方式的查询效率很高，但由于稀疏的现象严重，空间利用效率很低。也可以采用压缩的存储方式即链表来表示状态转移，但由于要线性查询，会造成效率低下。</p><p>Trie树的创建要考虑的是父节点如何保存孩子节点，主要有链表和数组两种方式：</p><ul><li>使用节点数组，因为是英文字符，可以用Node[26]来保存孩子节点(如果是数字我们可以用Node[10])，这种方式最快，但是并不是所有节点都会有很多孩子，所以这种方式浪费的空间太多</li><li>用一个链表根据需要动态添加节点。这样我们就可以省下不小的空间，但是缺点是搜索的时候需要遍历这个链表，增加了时间复杂度。</li></ul><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>字符串检索<br>  事先将已知的一些字符串（字典）的有关信息保存到trie树里，查找另外一些未知字符串是否出现过或者出现频率。<br>例如：给出一个词典，其中的单词为不良单词。单词均为小写字母。再给出一段文本，文本的每一行也由小写字母构成。判断文本中是否含有任何不良单词</li><li>字符串最长公共前缀<br>  Trie树利用多个字符串的公共前缀来节省存储空间，反之，当我们把大量字符串存储到一棵trie树上时，我们可以快速得到某些字符串的公共前缀。</li><li>排序<br>  Trie树是一棵多叉树，只要先序遍历整棵树，输出相应的字符串便是按字典序排序的结果。<br>也可以快速获得最小、最大字符串（举出数据地图分页查看分区、求最大最小分区的例子）</li><li>词频统计<br>  统计每个单词出现的次数，以及找到出现频率最高的n个单词</li><li>字符串搜索的前缀匹配<br>  trie树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</li><li>作为其他数据结构和算法的辅助结构<br>  如后缀树，AC自动机等</li></ul><h1 id="数据结构的比较"><a href="#数据结构的比较" class="headerlink" title="数据结构的比较"></a>数据结构的比较</h1><h2 id="二叉搜索树（binary-search-tree）"><a href="#二叉搜索树（binary-search-tree）" class="headerlink" title="二叉搜索树（binary search tree）"></a>二叉搜索树（binary search tree）</h2><p>二叉搜索树又叫做二叉排序树，它满足：</p><ul><li>任意节点如果左子树不为空，左子树所有节点的值都小于根节点的值；</li><li>任意节点如果右子树不为空，右子树所有节点的值都大于根节点的值；</li><li>左右子树也都是二叉搜索树；</li><li>所有节点的值都不相同。</li></ul><p>其实二叉搜索树的优势已经在与查找、插入的时间复杂度上了，通常只有 O(log n)，很多集合都是通过它来实现的。在进行插入的时候，实质上是给树添加新的叶子节点，避免了节点移动，搜索、插入和删除的复杂度等于树的高度，属于 O(log n)，最坏情况下整棵树所有的节点都只有一个子节点，完全变成一个线性表，复杂度是 O(n)。<br>Trie 树在最坏情况下查找要快过二叉搜索树，如果搜索字符串长度用 m 来表示的话，它只有 O(m)，通常情况（树的节点个数要远大于搜索字符串的长度）下要远小于 O(n)。<br>我们给 Trie 树举例子都是拿字符串举例的，其实它本身对 key 的适宜性是有严格要求的，如果 key 是浮点数的话，就可能导致整个 Trie 树巨长无比，节点可读性也非常差，这种情况下是不适宜用 Trie 树来保存数据的；而二叉搜索树就不存在这个问题。</p><h2 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h2><p>Trie 树可以比较方便地按照 key 的字母序来排序（整棵树先序遍历一次就好了），这是绝大多数 Hash 表是不同的（Hash 表一般对于不同的 key 来说是无序的）。<br>考虑一下 Hash 表键冲突的问题。Hash 表通常我们说它的复杂度是 O(1)，其实严格说起来这是接近完美的 Hash 表的复杂度，另外还需要考虑到 hash 函数本身需要遍历搜索字符串，复杂度是 O(m)。在不同键被映射到 “同一个位置”（考虑 closed hashing，这 “同一个位置” 可以由一个普通链表来取代）的时候，需要进行查找的复杂度取决于这 “同一个位置” 下节点的数目，因此，在最坏情况下，Hash 表也是可以成为一张单向链表的。<br>在较理想的情况下，Hash 表可以以 O(1) 的速度迅速命中目标，如果这张表非常大，需要放到磁盘上的话，Hash 表的查找访问在理想情况下只需要一次即可；但是 Trie 树访问磁盘的数目需要等于节点深度。<br>很多时候 Trie 树比 Hash 表需要更多的空间，我们考虑这种一个节点存放一个字符的情况的话，在保存一个字符串的时候，没有办法把它保存成一个单独的块。Trie 树的节点压缩可以明显缓解这个问题，后面会讲到。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p><a href="https://www.cnblogs.com/binyue/p/3771040.html" target="_blank" rel="noopener">字典树(Trie树)的实现及应用</a><br><a href="https://www.cnblogs.com/justinh/p/7716421.html" target="_blank" rel="noopener">Trie（前缀树/字典树）及其应用</a><br><a href="https://www.raychase.net/1783" target="_blank" rel="noopener">Trie 树和其它数据结构的比较</a><br><a href="https://www.shenyanchao.cn/blog/2018/12/04/lucene-numberic/" target="_blank" rel="noopener">Lucene数字类型处理</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      字典树
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://langonggong.com/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://langonggong.com/tags/Elasticsearch/"/>
    
      <category term="树" scheme="http://langonggong.com/tags/%E6%A0%91/"/>
    
      <category term="Lucune" scheme="http://langonggong.com/tags/Lucune/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://langonggong.com/2019/10/03/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://langonggong.com/2019/10/03/线程池/</id>
    <published>2019-10-03T08:12:49.000Z</published>
    <updated>2020-06-22T16:40:36.965Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="ThreadPoolExecutor构造参数"><a href="#ThreadPoolExecutor构造参数" class="headerlink" title="ThreadPoolExecutor构造参数"></a>ThreadPoolExecutor构造参数</h1><ul><li>corePoolSize<br>  线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；<br>如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；<br>如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</li><li>maximumPoolSize<br>  线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize</li><li>keepAliveTime<br>  线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间。默认情况下，该参数只在线程数大于corePoolSize时才有用</li><li>workQueue<br>  workQueue必须是BlockingQueue阻塞队列。当线程池中的线程数超过它的corePoolSize的时候，线程会进入阻塞队列进行阻塞等待。通过workQueue，线程池实现了阻塞功能</li><li>threadFactory<br>  创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名</li></ul><h2 id="几种排队的策略："><a href="#几种排队的策略：" class="headerlink" title="几种排队的策略："></a>几种排队的策略：</h2><h3 id="不排队，直接提交"><a href="#不排队，直接提交" class="headerlink" title="不排队，直接提交"></a>不排队，直接提交</h3><p>将任务直接交给线程处理而不保持它们，可使用SynchronousQueue<br>如果不存在可用于立即运行任务的线程（即线程池中的线程都在工作），则试图把任务加入缓冲队列将会失败，因此会构造一个新的线程来处理新添加的任务，并将其加入到线程池中（corePoolSize—&gt;maximumPoolSize扩容）<br>Executors.newCachedThreadPool()采用的便是这种策略</p><h3 id="无界队列"><a href="#无界队列" class="headerlink" title="无界队列"></a>无界队列</h3><p>可以使用LinkedBlockingQueue（基于链表的有界队列，FIFO），理论上是该队列可以对无限多的任务排队</p><p>将导致在所有corePoolSize线程都工作的情况下将新任务加入到队列中。这样，创建的线程就不会超过corePoolSize，也因此，maximumPoolSize的值也就无效了</p><h3 id="有界队列"><a href="#有界队列" class="headerlink" title="有界队列"></a>有界队列</h3><p>可以使用ArrayBlockingQueue（基于数组结构的有界队列，FIFO），并指定队列的最大长度</p><p>使用有界队列可以防止资源耗尽，但也会造成超过队列大小和maximumPoolSize后，提交的任务被拒绝的问题，比较难调整和控制。</p><h2 id="RejectedExecutionHandler（饱和策略）"><a href="#RejectedExecutionHandler（饱和策略）" class="headerlink" title="RejectedExecutionHandler（饱和策略）"></a>RejectedExecutionHandler（饱和策略）</h2><p>线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：</p><ul><li>AbortPolicy：直接抛出异常，默认策略；</li><li>CallerRunsPolicy：用调用者所在的线程来执行任务；</li><li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li><li>DiscardPolicy：直接丢弃任务；</li></ul><p>当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p><h1 id="线程池的执行流程"><a href="#线程池的执行流程" class="headerlink" title="线程池的执行流程"></a>线程池的执行流程</h1><ul><li>如果线程池中的线程数量少于corePoolSize，就创建新的线程来执行新添加的任务</li><li>如果线程池中的线程数量大于等于corePoolSize，但队列workQueue未满，则将新添加的任务放到workQueue中</li><li>如果线程池中的线程数量大于等于corePoolSize，且队列workQueue已满，但线程池中的线程数量小于maximumPoolSize，则会创建新的线程来处理被添加的任务</li><li>如果线程池中的线程数量等于了maximumPoolSize，就用RejectedExecutionHandler来执行拒绝策略</li></ul><h1 id="Executors静态工厂创建几种常用线程池"><a href="#Executors静态工厂创建几种常用线程池" class="headerlink" title="Executors静态工厂创建几种常用线程池"></a>Executors静态工厂创建几种常用线程池</h1><h2 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h2><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">FixedThreadPool</span>(int nThreads) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">FixedThreadPool</span>(int nThreads, ThreadFactory threadFactory) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个指定工作线程数的线程池，其中参数 corePoolSize 和 maximumPoolSize 相等，阻塞队列基于LinkedBlockingQueue</p><p>它是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是在线程池空闲时，即线程池中没有可运行任务时，它也不会释放工作线程，还会占用一定的系统资源</p><h2 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h2><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">SingleThreadExecutor</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">FinalizableDelegatedExecutorService</span></span><br><span class="line"><span class="type"></span>        (<span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">SingleThreadExecutor</span>(ThreadFactory threadFactory) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">FinalizableDelegatedExecutorService</span></span><br><span class="line"><span class="type"></span>        (<span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化的线程池中只有一个线程，如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行，内部使用LinkedBlockingQueue作为阻塞队列</p><h2 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h2><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">CachedThreadPool</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60</span>L, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="type">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">CachedThreadPool</span>(ThreadFactory threadFactory) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60</span>L, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="type">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个可缓存工作线程的线程池，默认存活时间60秒，线程池的线程数可达到Integer.MAX_VALUE，即2147483647，内部使用SynchronousQueue作为阻塞队列；</p><p>在没有任务执行时，当线程的空闲时间超过keepAliveTime，则工作线程将会终止，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销</p><h2 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h2><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="keyword">new</span><span class="type">ScheduledThreadPool</span>(int corePoolSize) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="keyword">new</span><span class="type">ScheduledThreadPool</span>(</span><br><span class="line">        int corePoolSize, ThreadFactory threadFactory) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ScheduledThreadPoolExecutor</span>(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p><a href="https://www.cnblogs.com/trust-freedom/p/6594270.html" target="_blank" rel="noopener">Java线程池ThreadPoolExecutor使用和分析</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      线程池
    
    </summary>
    
      <category term="java" scheme="http://langonggong.com/categories/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://langonggong.com/tags/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>词干提取器</title>
    <link href="http://langonggong.com/2019/09/21/%E8%AF%8D%E5%B9%B2%E6%8F%90%E5%8F%96%E5%99%A8/"/>
    <id>http://langonggong.com/2019/09/21/词干提取器/</id>
    <published>2019-09-21T10:07:16.000Z</published>
    <updated>2020-06-22T16:40:36.966Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大多数语言的单词都可以 词形变化 ，意味着 下列单词可以改变它们的形态用来表达不同的意思：</p><ul><li>单复数变化 ： fox 、foxes</li><li>时态变化 ： pay 、 paid 、 paying</li><li>性别变化 ： waiter 、 waitress</li><li>动词人称变化 ： hear 、 hears</li><li>代词变化 ： I 、 me 、 my</li><li>不规则变化 ： ate 、 eaten</li><li>情景变化 ： so be it 、 were it so</li></ul><h1 id="提取程度"><a href="#提取程度" class="headerlink" title="提取程度"></a>提取程度</h1><p>词干提取是一种遭受两种困扰的模糊的技术：词干弱提取和词干过度提取。</p><ul><li>词干弱提取<br>  就是无法将同样意思的单词缩减为同一个词根。例如， jumped和jumps可能被提取为 jump ， 但是 jumping 可能被提取为 jumpi 。弱词干提取会导致搜索时无法返回相关文档。</li><li>词干过度提取<br>  就是无法将不同含义的单词分开。例如，general和generate可能都被提取为 gener 。 词干过度提取会降低精准度：不相干的文档会在不需要他们返回的时候返回。</li></ul><h1 id="提取方式"><a href="#提取方式" class="headerlink" title="提取方式"></a>提取方式</h1><h2 id="基于算法"><a href="#基于算法" class="headerlink" title="基于算法"></a>基于算法</h2><p>Elasticsearch 中的大部分 stemmers （词干提取器）是基于算法的，它们提供了一系列规则用于将一个词提取为它的词根形式，例如剥离复数词末尾的 s 或 es 。提取单词词干时并不需要知道该词的任何信息。</p><ul><li>优点<br>  可以作为插件使用，速度快，占用内存少，有规律的单词处理效果好</li><li>缺点<br>  没规律的单词例如 be 、 are 、和 am ，或 mice 和 mouse 效果不好</li></ul><h2 id="基于字典"><a href="#基于字典" class="headerlink" title="基于字典"></a>基于字典</h2><p>字典词干提取器在工作机制上与算法化词干提取器完全不同。 不同于应用一系列标准规则到每个词上，字典词干提取器只是简单地在字典里查找词。理论上可以给出比算法化词干提取器更好的结果。一个字典词干提取器应当可以：</p><ul><li>返回不规则形式如feet和mice的正确词干</li><li>区分出词形相似但词义不同的情形，比如organ and organization</li></ul><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>实践中一个好的算法化词干提取器一般优于一个字典词干提取器。应该有以下两大原因：</p><ul><li>字典质量<br>  字典需要保持最新，这是一项很耗时的任务。通常等到一个字典变得好用后，其中的部分内容已经过时。字典词干提取器对于字典中不存在的词无能为力。而一个基于算法的词干提取器，则会继续应用之前的相同规则，结果可能正确或错误。</li><li>大小与性能<br>  字典词干提取器需要加载所有词汇、 所有前缀，以及所有后缀到内存中。这会显著地消耗内存。找到一个词的正确词干，一般比算法化词干提取器的相同过程更加复杂。依赖于不同的字典质量，去除前后缀的过程可能会更加高效或低效。低效的情形可能会明显地拖慢整个词干提取过程。</li></ul><h1 id="提取器种类"><a href="#提取器种类" class="headerlink" title="提取器种类"></a>提取器种类</h1><ul><li>Porter Stem Token Filter<br>  porter_stem语汇单元过滤器（token filter）。<br>  最早的一个基于算法 的英文词干提取器，提取程度较为激进。</li><li>KStem Token Filter<br>  kstem语汇单元过滤器（token filter）。<br>  是一款合并了词干提取算法和内置词典的英语分词过滤器。为了避免模糊词不正确提取，这个词典包含一系列根词单词和特例单词。 kstem分词过滤器相较于Porter词干提取器而言不那么激进。</li><li>Hunspell 词干提取器<br>  基于词典提取词干的hunspell语汇单元过滤器（token filter）. Hunspell hunspell.github.io 是一个 Open Office、LibreOffice、Chrome、Firefox、Thunderbird 等众多其它开源项目都在使用的拼写检查器。Hunspell词典会占用几兆的内存，它不仅能移除前缀还能移除后缀。<br>  一个 Hunspell 词典由两个文件组成 — 具有相同的文件名和两个不同的后缀 — 如 en_US—和下面的两个后缀的其中一个：<ul><li>.dic<br>  包含所有词根，采用字母顺序，再加上一个代表所有可能前缀和后缀的代码表 【集体称之为词缀( affixes 】</li><li>.aff<br>  包含实际 .dic 文件每一行代码表对应的前缀和后缀转换</li></ul></li><li>其他<br>  Lovins 提取器、Porter 提取器、Porter2 提取器等</li></ul><h1 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h1><p>推荐的词干提取器也许不适用所有场景。 关于哪个是最好的词干提取器，不存在一个唯一的正确答案 — 它要看你具体的需求。 这里有3个方面的因素需要考虑在内： 性能、质量、程度。</p><h2 id="提取性能"><a href="#提取性能" class="headerlink" title="提取性能"></a>提取性能</h2><p>算法提取器一般来说比Hunspell提取器快4到5倍。Hunspell 提取器需要加载所有的词典、前缀和后缀表到内存，可能需要消耗几兆的内存。而算法提取器，由一点点代码组成，只需要使用很少内存。</p><h2 id="提取质量"><a href="#提取质量" class="headerlink" title="提取质量"></a>提取质量</h2><p>最日常用语使用的词往往不规则。一个基于词典的提取器往往取决于词典的好坏。如果 Hunspell 碰到的这个词不在词典里，那它什么也不能做。 Hunspell 需要一个广泛的、高质量的、最新的词典以产生好的结果；这样级别的词典可谓少之又少。 另一方面，一个算法提取器，将愉快的处理新词而不用为新词重新设计算法。<br>如果一个好的算法词干提取器可用于你的语言，那明智的使用它而不是 Hunspell。它会更快并且消耗更少内存，并且会产生和通常一样好或者比 Hunspell 等价的结果.<br>如果精度和可定制性对你很重要，那么你需要（和有精力）来维护一个自定义的词典，那么 Hunspell 会给你比算法提取器更大的灵活性</p><h2 id="提取程度-1"><a href="#提取程度-1" class="headerlink" title="提取程度"></a>提取程度</h2><p>是否想要积极提取还是轻量提取取决于你的场景。如果你的搜索结果是要用于聚类算法，你可能会希望匹配的更广泛一点（因此，提取力度要更大一点）。 如果你的搜索结果是面向最终用户，轻量的提取一般会产生更好的结果。对搜索来说，将名称和形容词提干比动词提干更重要，当然这也取决于语言。</p><p>另外一个要考虑的因素就是你的文档集的大小。 一个只有 10,000 个产品的小集合，你可能要更激进的提干来确保至少匹配到一些文档。 如果你的文档集很大，使用轻量的弱提取可能会得到更好的匹配结果。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/stemming.html" target="_blank" rel="noopener">将单词还原为词根</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      词干提取器
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://langonggong.com/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://langonggong.com/tags/Elasticsearch/"/>
    
      <category term="分析器" scheme="http://langonggong.com/tags/%E5%88%86%E6%9E%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>ES分析器</title>
    <link href="http://langonggong.com/2019/09/15/ES%E5%88%86%E6%9E%90%E5%99%A8/"/>
    <id>http://langonggong.com/2019/09/15/ES分析器/</id>
    <published>2019-09-14T17:09:03.000Z</published>
    <updated>2020-06-22T16:40:36.956Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h1><h1 id="CharFilter"><a href="#CharFilter" class="headerlink" title="CharFilter"></a>CharFilter</h1><h1 id="Tokenizer"><a href="#Tokenizer" class="headerlink" title="Tokenizer"></a>Tokenizer</h1><h1 id="Tokenizer-Filter"><a href="#Tokenizer-Filter" class="headerlink" title="Tokenizer Filter"></a>Tokenizer Filter</h1><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><h3 id="Lowercase-Token-Filter"><a href="#Lowercase-Token-Filter" class="headerlink" title="Lowercase Token Filter"></a>Lowercase Token Filter</h3><p>小写过滤器。将标记token规范化为小写</p><h3 id="Uppercase-Token-Filter"><a href="#Uppercase-Token-Filter" class="headerlink" title="Uppercase Token Filter"></a>Uppercase Token Filter</h3><p>大写过滤器。将术语转写成大写</p><h3 id="Synonym-Token-Filter"><a href="#Synonym-Token-Filter" class="headerlink" title="Synonym Token Filter"></a>Synonym Token Filter</h3><p>同义词过滤器</p><h3 id="ASCII-Folding-Token-Filter"><a href="#ASCII-Folding-Token-Filter" class="headerlink" title="ASCII Folding Token Filter"></a>ASCII Folding Token Filter</h3><p>ASCII码折叠过滤器。asciifolding过滤器将ASCII码不在ASCII表前127内的字母、数字和Unicode符号转换为ASCII等效字符(如果存在的话)</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//新建索引</span><br><span class="line">PUT asciifold_example</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"settings"</span>: &#123;</span><br><span class="line">        <span class="string">"analysis"</span>: &#123;</span><br><span class="line">            <span class="string">"analyzer"</span>: &#123;</span><br><span class="line">                <span class="string">"my_analyzer"</span>: &#123;</span><br><span class="line">                    <span class="string">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">                    <span class="string">"filter"</span>: [</span><br><span class="line">                        <span class="string">"my_ascii_folding"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"filter"</span>: &#123;</span><br><span class="line">                <span class="string">"my_ascii_folding"</span>: &#123;</span><br><span class="line">                    <span class="string">"type"</span>: <span class="string">"asciifolding"</span>,</span><br><span class="line">                    <span class="string">"preserve_original"</span>: false</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提交文本</span></span><br><span class="line">POST asciifold_example/_analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"analyzer"</span>: <span class="string">"my_analyzer"</span>,</span><br><span class="line">    <span class="string">"text"</span>: <span class="string">"Êê Ẑẑ Ĉĉ Ŝŝ Ŋŋ Öö"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取结果</span></span><br><span class="line">[<span class="meta">Ee,Zz,Cc,Ss,Nn,Oo</span>]</span><br></pre></td></tr></table></figure><h3 id="词干提取器"><a href="#词干提取器" class="headerlink" title="词干提取器"></a>词干提取器</h3><p><a href="http://langonggong.com/2019/09/21/%E8%AF%8D%E5%B9%B2%E6%8F%90%E5%8F%96%E5%99%A8/">词干提取器</a>将一个词提取为它的词根形式</p><ul><li>Porter Stem Token Filter</li><li>Stemmer Token Filter：包含了大多数词干提取器</li><li>KStem Token Filter</li><li>Snowball Token Filter<h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2></li></ul><h3 id="Length-Token-Filter"><a href="#Length-Token-Filter" class="headerlink" title="Length Token Filter"></a>Length Token Filter</h3><p>长度过滤器，会移除token流中太长或太短的标记</p><h3 id="Stop-Token-Filter"><a href="#Stop-Token-Filter" class="headerlink" title="Stop Token Filter"></a>Stop Token Filter</h3><p>停用词过滤器，会移除自定义或指定文件中的停用词</p><h3 id="Predicate-Token-Filter"><a href="#Predicate-Token-Filter" class="headerlink" title="Predicate Token Filter"></a>Predicate Token Filter</h3><p>根据脚本里面的表达式来判断是否过滤掉某个词条，例如使用standard分析器后的”What Flapdoodle”分隔成两个词条，只保留长度大于5的词条，则”What”将被删除</p><h2 id="切割"><a href="#切割" class="headerlink" title="切割"></a>切割</h2><h3 id="Word-Delimiter-Token-Filter"><a href="#Word-Delimiter-Token-Filter" class="headerlink" title="Word Delimiter Token Filter"></a>Word Delimiter Token Filter</h3><p>分隔符过滤器，根据一定的规则将单词分割为多个子字符串，或者删除单词中的分隔符。例如：</p><ul><li>generate_word_parts<br>  “Power-Shot”, “(Power,Shot)” -&gt; “Power” “Shot”</li><li>generate_number_parts<br>  将数字拆出来：”500-42” -&gt; “500” “42”</li><li>catenate_words<br>  将单词去掉分隔符后合并：”wi-fi” -&gt; “wifi”</li><li>其他</li></ul><h3 id="Edge-NGram-Token-Filter"><a href="#Edge-NGram-Token-Filter" class="headerlink" title="Edge NGram Token Filter"></a>Edge NGram Token Filter</h3><p>n-gram 看成一个在词语上 滑动窗口 ， n 代表这个 “窗口” 的长度。如果我们要 n-gram quick 这个词 —— 它的结果取决于 n 的选择长度：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">长度 <span class="number">1</span>（unigram）： <span class="string">[ q, u, i, c, k ]</span></span><br><span class="line">长度 <span class="number">2</span>（bigram）： <span class="string">[ qu, ui, ic, ck ]</span></span><br><span class="line">长度 <span class="number">3</span>（trigram）： <span class="string">[ qui, uic, ick ]</span></span><br><span class="line">长度 <span class="number">4</span>（four-gram）：<span class="string">[ quic, uick ]</span></span><br><span class="line">长度 <span class="number">5</span>（five-gram）：<span class="string">[ quick ]</span></span><br></pre></td></tr></table></figure><p>朴素的n-gram对词语内部的匹配非常有用，即在 <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/ngrams-compound-words.html" target="_blank" rel="noopener">Ngram匹配复合词</a> 介绍的那样。但对于输入即搜索（search-as-you-type）这种应用场景，我们会使用一种特殊的n-gram称为边界n-grams（edge n-grams）。所谓的边界n-gram是说它会固定词语开始的一边，以单词quick为例，它的边界n-gram的结果为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[q,qu,qui,quic,quick]</span><br></pre></td></tr></table></figure><p>创建索引、实例化 token 过滤器和分析器的完整示例如下</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"settings"</span>: &#123;</span><br><span class="line">        <span class="string">"number_of_shards"</span>: <span class="number">1</span>, </span><br><span class="line">        <span class="string">"analysis"</span>: &#123;</span><br><span class="line">            <span class="string">"filter"</span>: &#123;</span><br><span class="line">                <span class="string">"autocomplete_filter"</span>: &#123; </span><br><span class="line">                    <span class="string">"type"</span>:     <span class="string">"edge_ngram"</span>,</span><br><span class="line">                    <span class="string">"min_gram"</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="string">"max_gram"</span>: <span class="number">20</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"analyzer"</span>: &#123;</span><br><span class="line">                <span class="string">"autocomplete"</span>: &#123;</span><br><span class="line">                    <span class="string">"type"</span>:      <span class="string">"custom"</span>,</span><br><span class="line">                    <span class="string">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">                    <span class="string">"filter"</span>: [</span><br><span class="line">                        <span class="string">"lowercase"</span>,</span><br><span class="line">                        <span class="string">"autocomplete_filter"</span> </span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以拿 analyze API 测试这个新的分析器确保它行为正确：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /my_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"text"</span>: <span class="string">"quick brown"</span>,</span><br><span class="line">  <span class="string">"analyzer"</span>: <span class="string">"autocomplete"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果表明分析器能正确工作，并返回以下词：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[q,qu,qui,quic,quick,b,br,bro,brow,brown]</span><br></pre></td></tr></table></figure><p>可以用 update-mapping API 将这个分析器应用到具体字段并添加数据</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/_mapping/</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"properties"</span>: &#123;</span><br><span class="line">    <span class="string">"name"</span>: &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">      <span class="string">"analyzer"</span>: <span class="string">"autocomplete"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST /my_index/_bulk</span><br><span class="line">&#123;<span class="string">"index"</span>:&#123;<span class="string">"_id"</span>:<span class="number">1</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"Brown foxes"</span>&#125;</span><br><span class="line">&#123;<span class="string">"index"</span>:&#123;<span class="string">"_id"</span>:<span class="number">2</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"Yellow furballs"</span>&#125;</span><br></pre></td></tr></table></figure><p>如果使用简单 match 查询测试查询 “brown fo” ,可以看到两个文档同时都能匹配，尽管 Yellow furballs 这个文档并不包含 brown 和 fo</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_validate/query?explain</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span>: &#123;</span><br><span class="line">        <span class="string">"match"</span>: &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"brown fo"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用validate-query API 分析：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_validate/query?explain</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"match"</span>: &#123;</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"brown fo"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>explanation 表明查询会查找边界 n-grams 里的每个词：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">name</span>:b <span class="built_in">name</span>:br <span class="built_in">name</span>:bro <span class="built_in">name</span>:brow <span class="built_in">name</span>:brown <span class="built_in">name</span>:f <span class="built_in">name</span>:fo</span><br></pre></td></tr></table></figure><p>name:f 条件可以满足第二个文档</p><p>我们需要保证倒排索引表中包含边界 n-grams 的每个词，但是我们只想匹配用户输入的完整词组（ brown 和 fo ）， 可以通过在索引时使用 autocomplete 分析器，并在搜索时使用 standard 标准分析器来实现这种想法，只要改变查询使用的搜索分析器 analyzer 参数即可：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"match"</span>: &#123;</span><br><span class="line">      <span class="string">"name"</span>: &#123;</span><br><span class="line">        <span class="string">"query"</span>: <span class="string">"brown fo"</span>,</span><br><span class="line">        <span class="string">"analyzer"</span>: <span class="string">"standard"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>换种方式，我们可以在映射中，为name字段分别指定index_analyzer和 earch_analyzer。因为我们只想改变 search_analyzer，这里只要更新现有的映射而不用对数据重新创建索引：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/_mapping</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"properties"</span>: &#123;</span><br><span class="line">    <span class="string">"name"</span>: &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">      <span class="string">"analyzer"</span>: <span class="string">"autocomplete"</span>,</span><br><span class="line">      <span class="string">"search_analyzer"</span>: <span class="string">"standard"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果再次请求 validate-query API ，当前的解释为：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">name</span>:brown <span class="built_in">name</span>:fo</span><br></pre></td></tr></table></figure><p>再次执行查询就能正确返回 Brown foxes 这个文档。</p><h3 id="Shingle-Token-Filter（滑动窗口）"><a href="#Shingle-Token-Filter（滑动窗口）" class="headerlink" title="Shingle Token Filter（滑动窗口）"></a>Shingle Token Filter（滑动窗口）</h3><p>使用 TF/IDF 的标准全文检索将文档或者文档中的字段作一大袋的词语处理。 match 查询可以告知我们这大袋子中是否包含查询的词条，但却无法告知词语之间的关系。</p><p>思考下面这几个句子的不同：</p><ul><li>Sue ate the alligator.</li><li>The alligator ate Sue.</li><li>Sue never goes anywhere without her alligator-skin purse.</li></ul><p>用match搜索sue alligator上面的三个文档都会得到匹配，但它却不能确定这两个词是否只来自于一种语境，甚至都不能确定是否来自于同一个段落。</p><p>理解分词之间的关系是一个复杂的难题，我们也无法通过换一种查询方式去解决。但我们至少可以通过出现在彼此附近或者仅仅是彼此相邻的分词来判断一些似乎相关的分词。</p><p>对句子Sue ate the alligator ，不仅要将每一个单词（或者 unigram ）作为词项索引<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"sue"</span>, <span class="string">"ate"</span>, <span class="string">"the"</span>, <span class="string">"alligator"</span>]</span><br></pre></td></tr></table></figure></p><p>也要将每个单词以及它的邻近词作为单个词项索引：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"sue ate"</span>, <span class="string">"ate the"</span>, <span class="string">"the alligator"</span>]</span><br></pre></td></tr></table></figure></p><p>这些单词对（或者 bigrams ）被称为 shingles 。<br>你也可以索引三个单词（ trigrams ）。Trigrams 提供了更高的精度，但是也大大增加了索引中唯一词项的数量。在大多数情况下，Bigrams 就够了。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"sue ate the"</span>, <span class="string">"ate the alligator"</span>]</span><br></pre></td></tr></table></figure></p><p>只有当用户输入的查询内容和在原始文档中顺序相同时，shingles 才是有用的；对 sue alligator 的查询可能会匹配到单个单词，但是不会匹配任何 shingles 。只是索引 bigrams 是不够的；我们仍然需要 unigrams ，但可以将匹配 bigrams 作为增加相关度评分的信号。</p><p>将它们分开保存在能被独立查询的字段会更清晰：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">PUT /shingle_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"settings"</span>: &#123;</span><br><span class="line">    <span class="string">"number_of_shards"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"analysis"</span>: &#123;</span><br><span class="line">      <span class="string">"filter"</span>: &#123;</span><br><span class="line">        <span class="string">"my_shingle_filter"</span>: &#123;</span><br><span class="line">          <span class="string">"type"</span>: <span class="string">"shingle"</span>,</span><br><span class="line">          <span class="string">"min_shingle_size"</span>: <span class="number">2</span>,</span><br><span class="line">          <span class="string">"max_shingle_size"</span>: <span class="number">2</span>,</span><br><span class="line">          <span class="string">"output_unigrams"</span>: false</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="string">"my_shingle_analyzer"</span>: &#123;</span><br><span class="line">          <span class="string">"type"</span>: <span class="string">"custom"</span>,</span><br><span class="line">          <span class="string">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">          <span class="string">"filter"</span>: [</span><br><span class="line">            <span class="string">"lowercase"</span>,</span><br><span class="line">            <span class="string">"my_shingle_filter"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用 analyze API 测试下分析器：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /shingle_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"analyzer"</span>: <span class="string">"my_shingle_analyzer"</span>,</span><br><span class="line">  <span class="string">"text"</span>: <span class="string">"Sue ate the alligator"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>得到了 3 个词项：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"sue ate"</span>, <span class="string">"ate the"</span>, <span class="string">"the alligator"</span>]</span><br></pre></td></tr></table></figure></p><p>将unigrams和bigrams分开索引更清晰，所以title字段将创建成一个多字段：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PUT /shingle_index/_mapping/</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"properties"</span>: &#123;</span><br><span class="line">    <span class="string">"title"</span>: &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">      <span class="string">"fields"</span>: &#123;</span><br><span class="line">        <span class="string">"shingles"</span>: &#123;</span><br><span class="line">          <span class="string">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">          <span class="string">"analyzer"</span>: <span class="string">"my_shingle_analyzer"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>索引以下示例文档：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /shingle_index/_doc/_bulk</span><br><span class="line">&#123;<span class="string">"index"</span>:&#123;<span class="string">"_id"</span>:<span class="number">1</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">"title"</span>:<span class="string">"Sue ate the alligator"</span>&#125;</span><br><span class="line">&#123;<span class="string">"index"</span>:&#123;<span class="string">"_id"</span>:<span class="number">2</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">"title"</span>:<span class="string">"The alligator ate Sue"</span>&#125;</span><br><span class="line">&#123;<span class="string">"index"</span>:&#123;<span class="string">"_id"</span>:<span class="number">3</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">"title"</span>:<span class="string">"Sue never goes anywhere without her alligator skin purse"</span>&#125;</span><br></pre></td></tr></table></figure></p><p>使用The hungry alligator ate Sue 进行简单 match 查询：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GET /shingle_index/_doc/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"match"</span>: &#123;</span><br><span class="line">      <span class="string">"title"</span>: <span class="string">"the hungry alligator ate sue"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个查询返回了所有的三个文档， 但是注意文档 1 和 2 有相同的相关度评分因为他们包含了相同的单词：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"total"</span>: &#123;</span><br><span class="line">        <span class="attr">"value"</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">"relation"</span>: <span class="string">"eq"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"max_score"</span>: <span class="number">1.3721708</span>,</span><br><span class="line">    <span class="attr">"hits"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"_index"</span>: <span class="string">"shingle_index"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">            <span class="attr">"_score"</span>: <span class="number">1.3721708</span>,</span><br><span class="line">            <span class="attr">"_source"</span>: &#123;</span><br><span class="line">                <span class="attr">"title"</span>: <span class="string">"Sue ate the alligator"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"_index"</span>: <span class="string">"shingle_index"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>: <span class="string">"2"</span>,</span><br><span class="line">            <span class="attr">"_score"</span>: <span class="number">1.3721708</span>,</span><br><span class="line">            <span class="attr">"_source"</span>: &#123;</span><br><span class="line">                <span class="attr">"title"</span>: <span class="string">"The alligator ate Sue"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"_index"</span>: <span class="string">"shingle_index"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>: <span class="string">"3"</span>,</span><br><span class="line">            <span class="attr">"_score"</span>: <span class="number">0.2152618</span>,</span><br><span class="line">            <span class="attr">"_source"</span>: &#123;</span><br><span class="line">                <span class="attr">"title"</span>: <span class="string">"Sue never goes anywhere without her alligator skin purse"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在在查询里添加 shingles 字段，为了提高相关度评分，我们仍然需要将基本title字段包含到查询中：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET /shingle_index/_doc/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"bool"</span>: &#123;</span><br><span class="line">      <span class="string">"must"</span>: &#123;</span><br><span class="line">        <span class="string">"match"</span>: &#123;</span><br><span class="line">          <span class="string">"title"</span>: <span class="string">"the hungry alligator ate sue"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"should"</span>: &#123;</span><br><span class="line">        <span class="string">"match"</span>: &#123;</span><br><span class="line">          <span class="string">"title.shingles"</span>: <span class="string">"the hungry alligator ate sue"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>仍然匹配到了所有的 3 个文档， 但是文档 2 现在排到了第一名因为它匹配了 shingled 词项 ate sue：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"total"</span>: &#123;</span><br><span class="line">        <span class="attr">"value"</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">"relation"</span>: <span class="string">"eq"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"max_score"</span>: <span class="number">3.6694741</span>,</span><br><span class="line">    <span class="attr">"hits"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"_index"</span>: <span class="string">"shingle_index"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>: <span class="string">"2"</span>,</span><br><span class="line">            <span class="attr">"_score"</span>: <span class="number">3.6694741</span>,</span><br><span class="line">            <span class="attr">"_source"</span>: &#123;</span><br><span class="line">                <span class="attr">"title"</span>: <span class="string">"The alligator ate Sue"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"_index"</span>: <span class="string">"shingle_index"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">            <span class="attr">"_score"</span>: <span class="number">1.3721708</span>,</span><br><span class="line">            <span class="attr">"_source"</span>: &#123;</span><br><span class="line">                <span class="attr">"title"</span>: <span class="string">"Sue ate the alligator"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"_index"</span>: <span class="string">"shingle_index"</span>,</span><br><span class="line">            <span class="attr">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>: <span class="string">"3"</span>,</span><br><span class="line">            <span class="attr">"_score"</span>: <span class="number">0.2152618</span>,</span><br><span class="line">            <span class="attr">"_source"</span>: &#123;</span><br><span class="line">                <span class="attr">"title"</span>: <span class="string">"Sue never goes anywhere without her alligator skin purse"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="Conditional-Token-Filter"><a href="#Conditional-Token-Filter" class="headerlink" title="Conditional Token Filter"></a>Conditional Token Filter</h3><p>根据表达式条件决定是否使用某个其他的过滤器，例如根据一个词条中字符的个数来判断是否要使用Lowercase Token Filter过滤器</p><h3 id="Keyword-Marker-Token-Filter"><a href="#Keyword-Marker-Token-Filter" class="headerlink" title="Keyword Marker Token Filter"></a>Keyword Marker Token Filter</h3><p>保护某些单词不被stemmers（词干提取器）处理，可以自定义单词列表或者指定文件路径</p><h3 id="Keyword-Repeat-Token-Filter"><a href="#Keyword-Repeat-Token-Filter" class="headerlink" title="Keyword Repeat Token Filter"></a>Keyword Repeat Token Filter</h3><p>将每个输入的token复制，生成keyword和non-keyword两个。一般用于交给词干提取器处理，然后去重处理</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PUT /keyword_repeat_example</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"settings"</span>: &#123;</span><br><span class="line">    <span class="string">"analysis"</span>: &#123;</span><br><span class="line">      <span class="string">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="string">"stemmed_and_unstemmed"</span>: &#123;</span><br><span class="line">          <span class="string">"type"</span>: <span class="string">"custom"</span>,</span><br><span class="line">          <span class="string">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">          <span class="string">"filter"</span>: [</span><br><span class="line">            <span class="string">"lowercase"</span>,</span><br><span class="line">            <span class="string">"keyword_repeat"</span>,</span><br><span class="line">            <span class="string">"porter_stem"</span>,</span><br><span class="line">            <span class="string">"unique_stem"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"filter"</span>: &#123;</span><br><span class="line">        <span class="string">"unique_stem"</span>: &#123;</span><br><span class="line">          <span class="string">"type"</span>: <span class="string">"unique"</span>,</span><br><span class="line">          <span class="string">"only_on_same_position"</span>: true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例如下：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST <span class="regexp">/keyword_repeat_example/</span>_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"analyzer"</span>: <span class="string">"stemmed_and_unstemmed"</span>,</span><br><span class="line">  <span class="string">"text"</span>: <span class="string">"I like cats"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"tokens"</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"token"</span> : <span class="string">"i"</span>,</span><br><span class="line">      <span class="attr">"start_offset"</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"end_offset"</span> : <span class="number">1</span>,</span><br><span class="line">      <span class="attr">"type"</span> : <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">      <span class="attr">"position"</span> : <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"token"</span> : <span class="string">"like"</span>,</span><br><span class="line">      <span class="attr">"start_offset"</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"end_offset"</span> : <span class="number">6</span>,</span><br><span class="line">      <span class="attr">"type"</span> : <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">      <span class="attr">"position"</span> : <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"token"</span> : <span class="string">"cats"</span>,</span><br><span class="line">      <span class="attr">"start_offset"</span> : <span class="number">7</span>,</span><br><span class="line">      <span class="attr">"end_offset"</span> : <span class="number">11</span>,</span><br><span class="line">      <span class="attr">"type"</span> : <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">      <span class="attr">"position"</span> : <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"token"</span> : <span class="string">"cat"</span>,</span><br><span class="line">      <span class="attr">"start_offset"</span> : <span class="number">7</span>,</span><br><span class="line">      <span class="attr">"end_offset"</span> : <span class="number">11</span>,</span><br><span class="line">      <span class="attr">"type"</span> : <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">      <span class="attr">"position"</span> : <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      ES分析器，由字符过滤器、分词器、分词过滤器组成
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://langonggong.com/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://langonggong.com/tags/Elasticsearch/"/>
    
      <category term="分析器" scheme="http://langonggong.com/tags/%E5%88%86%E6%9E%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>synchronized的内存语义</title>
    <link href="http://langonggong.com/2019/07/01/synchronized%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89/"/>
    <id>http://langonggong.com/2019/07/01/synchronized的内存语义/</id>
    <published>2019-07-01T15:51:37.000Z</published>
    <updated>2020-06-22T16:40:36.961Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中<br>而线程获取锁，JMM会把其对应内存置为无效，从而使被监视器保护的临界区代码必须要从主内存去读取共享变量</p>]]></content>
    
    <summary type="html">
    
      synchronized的内存语义
    
    </summary>
    
      <category term="java" scheme="http://langonggong.com/categories/java/"/>
    
      <category term="内存模型" scheme="http://langonggong.com/categories/java/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
    
      <category term="java" scheme="http://langonggong.com/tags/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java内存模型" scheme="http://langonggong.com/tags/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="synchronized" scheme="http://langonggong.com/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>SQL优化</title>
    <link href="http://langonggong.com/2018/12/02/SQL%E4%BC%98%E5%8C%96/"/>
    <id>http://langonggong.com/2018/12/02/SQL优化/</id>
    <published>2018-12-02T12:21:43.000Z</published>
    <updated>2020-06-22T16:40:36.957Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><ul><li>字段类型转换导致不用索引，如字符串类型的不用引号，数字类型的用引号等，这有可能会用不到索引导致全表扫描；</li><li>mysql 不支持函数转换，所以字段前面不能加函数，否则这将用不到索引；</li><li>不要在字段前面加减运算；</li><li>字符串比较长的可以考虑索引一部份减少索引文件大小，提高写入效率；</li><li>like % 在前面用不到索引；</li><li>根据联合索引的第二个及以后的字段单独查询用不到索引；</li><li>不要使用 select *；</li><li>排序请尽量使用升序 ;</li><li>or 的查询尽量用 union 代替 （Innodb）；</li><li>复合索引高选择性的字段排在前面；</li><li>order by / group by 字段包括在索引当中减少排序，效率会更高。</li></ul>]]></content>
    
    <summary type="html">
    
      SQL优化
    
    </summary>
    
      <category term="mysql" scheme="http://langonggong.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://langonggong.com/tags/mysql/"/>
    
      <category term="DB" scheme="http://langonggong.com/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB锁</title>
    <link href="http://langonggong.com/2018/11/27/InnoDB%E9%94%81/"/>
    <id>http://langonggong.com/2018/11/27/InnoDB锁/</id>
    <published>2018-11-26T16:00:41.000Z</published>
    <updated>2020-06-22T16:40:36.956Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><p>事务是由一组SQL语句组成的逻辑处理单元，事务具有以下4个属性，通常简称为事务的ACID属性。</p><ul><li>原子性（Atomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行</li><li>一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的</li><li>隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然</li><li>持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持</li></ul><h2 id="事务并发带来的问题"><a href="#事务并发带来的问题" class="headerlink" title="事务并发带来的问题"></a>事务并发带来的问题</h2><ul><li>更新丢失（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题－－最后的更 新覆盖了由其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文 档。最后保存其更改副本的编辑人员覆盖另一个编辑人员所做的更改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题</li><li>脏读（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加 控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做”脏读”</li><li>不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”</li><li>幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”</li></ul><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。“脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。</p><p>数据库实现事务隔离的方式，基本上可分为以下两种</p><ul><li>在读取数据前，对其加锁，阻止其他事务对数据进行修改。</li><li>不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot)，并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度来看，好像是数据库可以提供同一数据的多个版本，因此，这种技术叫做数据多版本并发控制（MultiVersion Concurrency Control，简称MVCC或MCC），也经常称为多版本数据库</li></ul><p>4种隔离级别比较</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">读数据一致性</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">未提交读（Read uncommitted）</td><td style="text-align:center">最低级别，只能保证不读取物理上损坏的数据</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">已提交度（Read committed）</td><td style="text-align:center">语句级</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">可重复读（Repeatable read</td><td style="text-align:center">事务级</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">序列化（Serializable）</td><td style="text-align:center">最高级别，事务级</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">否</td></tr></tbody></table></div><p>各具体数据库并不一定完全实现了上述4个隔离级别，MySQL 支持全部4个隔离级别，但在具体实现时，有一些特点，比如在一些隔离级别下是采用MVCC一致性读，但某些情况下又不是。</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h2><p>按锁的粒度划分</p><ul><li>行级锁：行级锁分为共享锁和排它锁。行级锁是Mysql中锁定粒度最细的锁。InnoDB引擎支持行级锁和表级锁，只有在通过索引条件检索数据的时候，才使用行级锁，否就使用表级锁。行级锁开销大，加锁慢，锁定粒度最小，发生锁冲突概率最低，并发度最高</li><li>表级锁：表级锁分为表共享锁和表独占锁。表级锁开销小，加锁快，锁定粒度大、发生锁冲突最高，并发度最低</li><li>页级锁：页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁。 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li><li>间隙锁（Next-Key）：对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓 的间隙锁（Next-Key锁）</li></ul><p>按锁级别划分</p><p>InnoDB实现了以下两种类型的行锁</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li><li>排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li></ul><p>另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。</p><ul><li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li><li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</li></ul><p>InnoDB行锁模式兼容性列表</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">X</th><th style="text-align:center">IX</th><th style="text-align:center">S</th><th style="text-align:center">IS</th></tr></thead><tbody><tr><td style="text-align:center">X</td><td style="text-align:center">冲突</td><td style="text-align:center">冲突</td><td style="text-align:center">冲突</td><td style="text-align:center">冲突</td></tr><tr><td style="text-align:center">IX</td><td style="text-align:center">冲突</td><td style="text-align:center">兼容</td><td style="text-align:center">冲突</td><td style="text-align:center">兼容</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">冲突</td><td style="text-align:center">冲突</td><td style="text-align:center">兼容</td><td style="text-align:center">兼容</td></tr><tr><td style="text-align:center">IS</td><td style="text-align:center">冲突</td><td style="text-align:center">兼容</td><td style="text-align:center">兼容</td><td style="text-align:center">兼容</td></tr></tbody></table></div><p>如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。</p><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><ul><li>在不通过索引条件查询的时候，InnoDB使用的是表锁，而不是行锁</li><li>由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的</li><li>当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁</li><li>即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比 如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁</li><li>检索值的数据类型与索引字段不同，虽然MySQL能够进行数据类型转换，但却不会使用索引，从而导致InnoDB使用表锁</li></ul><h2 id="间隙锁（Next-Key）"><a href="#间隙锁（Next-Key）" class="headerlink" title="间隙锁（Next-Key）"></a>间隙锁（Next-Key）</h2><p>当用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件 的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，或者叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁。</p><p>InnoDB 使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求；另外一方面，是为了满足其恢复和复制的需要</p><p>举例：</p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span>  emp <span class="keyword">where</span> <span class="keyword">id</span> &gt; <span class="number">100</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>是一个范围条件的检索，InnoDB不仅会对符合条件的记录加锁，也会对id大于101（这些记录并不存在）的“间隙”加锁.要是不使用间隙锁，如果其他事务插入了id大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读</p><h3 id="恢复和复制"><a href="#恢复和复制" class="headerlink" title="恢复和复制"></a>恢复和复制</h3><p>对于“insert  into target_tab select * from source_tab where …”和“create  table target_tab …select … From  source_tab where …(CTAS)”这种SQL语句，MySQL对这种SQL语句做了特别处理。<br>因为不加锁的话，如果在上述语句执行过程中，其他事务对source_tab做了更新操作，造成不符合target_tab的数据在source_tab中变成了符合target_tab，就可能导致数据恢复的结果错误</p><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p>对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择InnoDB表的理由。但在个别特殊事务中，也可以考虑使用表级锁。</p><ul><li>事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。</li><li>事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。</li></ul><h2 id="锁在不同条件的差异"><a href="#锁在不同条件的差异" class="headerlink" title="锁在不同条件的差异"></a>锁在不同条件的差异</h2><p>InnoDB在不同隔离级别下的一致性读及锁的差异</p><table style="text-align:center">   <tr>      <td> SQL </td>      <td>条件</td>      <td>Read Uncommited</td>      <td>Read Commited</td>      <td>Repeatable Read</td>      <td> Serializable</td>   </tr>   <tr>      <td rowspan="2"> select </td>      <td>相等</td>      <td>None locks</td>      <td>Consisten read/None lock</td>      <td>Consisten read/None lock</td>      <td> Share locks</td>   </tr>   <tr>      <td>范围</td>      <td>None locks</td>      <td>Consisten read/None lock</td>      <td>Consisten read/None lock</td>      <td> Share Next-Key</td>   </tr>   <tr>      <td rowspan="2"> update </td>      <td>相等</td>      <td>exclusive locks</td>      <td>exclusive locks</td>      <td>exclusive locks</td>      <td>exclusive locks</td>   </tr>   <tr>      <td>范围</td>      <td>exclusive next-key</td>      <td>exclusive next-key</td>      <td>exclusive next-key</td>      <td>exclusive next-key</td>   </tr>   <tr>      <td> Insert </td>      <td>N/A</td>      <td>exclusive locks</td>      <td>exclusive locks</td>      <td>exclusive locks</td>      <td>exclusive locks</td>   </tr>   <tr>      <td rowspan="2">replace</td>      <td>无键冲突</td>      <td>exclusive locks</td>      <td>exclusive locks</td>      <td>exclusive locks</td>      <td>exclusive locks</td>   </tr>   <tr>      <td>键冲突</td>      <td>exclusive next-key</td>      <td>exclusive next-key</td>      <td>exclusive next-key</td>      <td>exclusive next-key</td>   </tr>   <tr>      <td rowspan="2"> delete </td>      <td>相等</td>      <td>exclusive locks</td>      <td>exclusive locks</td>      <td>exclusive locks</td>      <td>exclusive locks</td>   </tr>   <tr>      <td>范围</td>      <td>exclusive next-key</td>      <td>exclusive next-key</td>      <td>exclusive next-key</td>      <td>exclusive next-key</td>   </tr>   <tr>      <td rowspan="2"> Select ... from ... Lock in share mode </td>      <td>相等</td>      <td>Share locks</td>      <td>Share locks</td>      <td>Share locks</td>      <td>Share locks</td>   </tr>   <tr>      <td>范围</td>      <td>Share locks</td>      <td>Share locks</td>      <td>Share Next-Key</td>      <td>Share Next-Key</td>   </tr>   <tr>      <td rowspan="2">Select * from ... For update</td>      <td>相等</td>      <td>exclusive locks</td>      <td>exclusive locks</td>      <td>exclusive locks</td>      <td>exclusive locks</td>   </tr>   <tr>      <td>范围</td>      <td>exclusive locks</td>      <td>Share locks</td>      <td>exclusive next-key</td>      <td>exclusive next-key</td>   </tr>   </table><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>MyISAM表锁是deadlock free的，这是因为MyISAM总是一次获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。但在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，这就决定了在InnoDB中发生死锁是可能的</p><p>发生死锁后，InnoDB一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB并不能完全自动检测到死锁，这需要通过设置锁等待超时参数 innodb_lock_wait_timeout来解决。在并发访问比较高的情况下，如果大量事务因无法立即获得所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖跨数据库。</p><p>死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。通常来说，死锁都是应用设计的问题，通过调整业务流程、数据库对象设计、事务大小，以及访问数据库的SQL语句，绝大部分死锁都可以避免。</p><p>避免死锁的常用方法</p><ul><li>在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会。在下面的例子中，由于两个session访问两个表的顺序不同，发生死锁的机会就非常高！但如果以相同的顺序来访问，死锁就可以避免。</li><li>在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能。</li><li>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁，更新时再申请排他锁，因为当用户申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁。</li></ul>]]></content>
    
    <summary type="html">
    
      InnoDB锁
    
    </summary>
    
      <category term="mysql" scheme="http://langonggong.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://langonggong.com/tags/mysql/"/>
    
      <category term="DB" scheme="http://langonggong.com/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>mysql索引</title>
    <link href="http://langonggong.com/2018/11/20/mysql%E7%B4%A2%E5%BC%95/"/>
    <id>http://langonggong.com/2018/11/20/mysql索引/</id>
    <published>2018-11-19T16:27:37.000Z</published>
    <updated>2020-06-22T16:40:36.959Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><img src="/images/RBTree.jpg"></p><p>红黑树的特性:</p><ul><li>每个节点或者是黑色，或者是红色</li><li>根节点是黑色</li><li>每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</li><li>如果一个节点是红色的，则它的子节点必须是黑色的</li><li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点</li></ul><p>红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。<br>例如，Java集合中的TreeSet和TreeMap，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。</p><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p><img src="/images/BTree.jpg"></p><p>B 树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点</p><ul><li>根节点至少有两个子节点</li><li>每个节点有M-1个key，并且以升序排列</li><li>位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间</li><li>其它节点至少有M/2个子节点</li></ul><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p><img src="/images/B+Tree.jpg"></p><p>B+树是对B树的一种变形树，它与B树的差异在于</p><ul><li>有k个子结点的结点必然有k个关键码；</li><li>非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。</li><li>树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。</li></ul><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>结构上</p><ul><li>B树中关键字集合分布在整棵树中，叶节点中不包含任何关键字信息，而B+树关键字集合分布在叶子结点中，非叶节点只是叶子结点中关键字的索引</li><li>B树中任何一个关键字只出现在一个结点中，而B+树中的关键字必须出现在叶节点中，也可能在非叶结点中重复出现</li></ul><p>性能上</p><ul><li>不同于B树只适合随机检索，B+树同时支持随机检索和顺序检索；</li><li>B+树的磁盘读写代价更低。B+树的内部结点并没有指向关键字具体信息的指针，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素。</li><li>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</li><li>（数据库索引采用B+树的主要原因是）B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）</li></ul><h1 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h1><p>从数据结构角度</p><ul><li>B+树索引</li><li>hash索引</li></ul><p>从物理存储角度</p><ul><li>聚集索引（聚簇索引）（clustered index）</li><li>非聚集索引（non-clustered index）</li></ul><p>从逻辑角度</p><ul><li>普通索引或者单列索引</li><li>唯一索引</li><li>主键索引：主键索引是一种特殊的唯一索引，不允许有空值</li><li>多列索引（复合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合</li><li>全文索引</li></ul><p>从存储引擎的角度</p><ul><li>主键索引</li><li>辅助索引(二级索引)</li></ul><p>B+树索引和哈希索引的明显区别是</p><ul><li>如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据</li><li>哈希索引无法完成范围查询检索</li><li>哈希索引无法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）</li><li>哈希索引也不支持多列联合索引的最左匹配规则</li><li>B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题</li></ul><h1 id="不同引擎的索引"><a href="#不同引擎的索引" class="headerlink" title="不同引擎的索引"></a>不同引擎的索引</h1><h2 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址</p><p><img src="/images/MyISAMPK.png"></p><h3 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h3><p>在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复</p><p><img src="/images/MyISAMSK.png"></p><h2 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h2><h3 id="主键索引-1"><a href="#主键索引-1" class="headerlink" title="主键索引"></a>主键索引</h3><p>MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引</p><p><img src="/images/InnoDBPK.png"></p><p>(图inndb主键索引）是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键</p><h3 id="辅助索引-1"><a href="#辅助索引-1" class="headerlink" title="辅助索引"></a>辅助索引</h3><p>InnoDB的所有辅助索引都引用主键作为data域</p><p><img src="/images/InnoDBSK.png"></p><p>InnoDB 表是基于聚簇索引建立的。因此InnoDB 的索引能提供一种非常快速的主键查找性能。不过，它的辅助索引（Secondary Index， 也就是非主键索引）也会包含主键列，所以，如果主键定义的比较大，其他索引也将很大。如果想在表上定义 、很多索引，则争取尽量把主键定义得小一些</p><p>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录</p><h2 id="InnoDB和MyISAM的区别"><a href="#InnoDB和MyISAM的区别" class="headerlink" title="InnoDB和MyISAM的区别"></a>InnoDB和MyISAM的区别</h2><ul><li>一是主索引的区别，InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。</li><li>二是辅助索引的区别：InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。</li></ul><h1 id="索引详解"><a href="#索引详解" class="headerlink" title="索引详解"></a>索引详解</h1><h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><p>有时候需要索引很长的字符列，这会让索引变得大且慢。通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。<br>对于BLOB，TEXT，或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。<br>要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间）。前缀应该足够长，以使得前缀索引的选择性接近于索引的整个列。<br>mysql无法使用其前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。</p><h2 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h2><p>多列索引并不是指建立多个单列索引，而是指在多个字段建立一个索引。</p><ul><li>又叫联合索引、复合索引。符合最左前缀规则</li><li>多列建索引比对每个列分别建索引更有优势，因为索引建立得越多就越占磁盘空间，在更新数据的时候速度会更慢。那如果我们分别在a和b上创建两个列索引，mysql的处理方式就不一样了，它会选择一个最严格的索引来进行检索，可以理解为检索能力最强的那个索引来检索，另外一个利用不上了，这样效果就不如多列索引了</li><li>将选择性最高的列放到索引的最前列</li></ul><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><ul><li>解释一： 就是select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。</li><li>解释二： 索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。</li><li>解释三：是非聚集组合索引的一种形式，它包括在查询里的Select、Join和Where子句用到的所有列（即建立索引的字段正好是覆盖查询语句[select子句]与查询条件[Where子句]中所涉及的字段，也即，索引包含了查询正在查找的所有数据）</li></ul><p>使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为using index,MySQL查询优化器在执行查询前会决定是否有索引覆盖查询。<br>覆盖索引也并不适用于任意的索引类型，索引必须存储列的值。Hash 和full-text索引不存储值，因此MySQL只能使用B-TREE</p><h2 id="空间索引"><a href="#空间索引" class="headerlink" title="空间索引"></a>空间索引</h2><p><a href="https://blog.csdn.net/MongChia1993/article/details/69941783#toc_16" target="_blank" rel="noopener">参考链接</a></p><h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><p><a href="https://www.cnblogs.com/itxiongwei/p/7064252.html" target="_blank" rel="noopener">参考链接</a></p><h1 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h1><p>优点</p><ul><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li><li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li><li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能</li></ul><p>缺点</p><ul><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li></ul><h1 id="索引建立原则"><a href="#索引建立原则" class="headerlink" title="索引建立原则"></a>索引建立原则</h1><p>一般来说，不应该创建索引的的这些列具有下列特点</p><ul><li>对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li><li>对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</li><li>对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</li><li>当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li></ul><p>常见规则</p><ul><li>最左前缀匹配原则<br>  mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整</li><li>=和in可以乱序<br>  比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li><li>尽量选择区分度高的列作为索引<br>  区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1</li><li>索引列不能参与计算<br>  比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大</li><li>尽量的扩展索引，不要新建索引<br>  比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可</li></ul>]]></content>
    
    <summary type="html">
    
      mysql索引
    
    </summary>
    
      <category term="mysql" scheme="http://langonggong.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://langonggong.com/tags/mysql/"/>
    
      <category term="DB" scheme="http://langonggong.com/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>生产者消费者</title>
    <link href="http://langonggong.com/2018/11/17/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <id>http://langonggong.com/2018/11/17/生产者消费者/</id>
    <published>2018-11-17T13:47:09.000Z</published>
    <updated>2020-06-22T16:40:36.965Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>注意：必须使用while循环，因为当前线程被唤醒之前，同时有消费者和生产线程都有执行过，导致当前的条件不满足。例如，size为0导致消费者线程thread1被阻塞，后来成产者线程thread2和消费者线程thread3都有执行，thread2唤醒了thread1，但是此时thread1发现size还是0，继续阻塞</p><h1 id="wait-notify-方法"><a href="#wait-notify-方法" class="headerlink" title="wait() / notify()方法"></a>wait() / notify()方法</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Storage1</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;Object&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    synchronized (<span class="built_in">list</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="built_in">list</span>.size() == MAX_SIZE) &#123;</span><br><span class="line">        System.out.println(<span class="string">"full,wait!"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="built_in">list</span>.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">list</span>.add(<span class="keyword">new</span> Object());</span><br><span class="line">      System.out.println(<span class="string">"produce,now size is:"</span> + <span class="built_in">list</span>.size());</span><br><span class="line">      <span class="built_in">list</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    synchronized (<span class="built_in">list</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="built_in">list</span>.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"empty,wait!"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="built_in">list</span>.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">list</span>.remove(<span class="number">0</span>);</span><br><span class="line">      System.out.println(<span class="string">"consume,new size is:"</span> + <span class="built_in">list</span>.size());</span><br><span class="line">      <span class="built_in">list</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Storage1 storage1 = <span class="keyword">new</span> Storage1();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">          storage1.consume();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">          storage1.produce();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="await-signal-方法"><a href="#await-signal-方法" class="headerlink" title="await() / signal()方法"></a>await() / signal()方法</h1><p>通过在Lock对象上调用newCondition()方法，将一个condition和一个约束条件进行绑定，进而控制并发程序访问竞争资源的安全</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Storage2</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Lock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Condition notEmpty = <span class="keyword">lock</span>.newCondition();</span><br><span class="line">  <span class="keyword">private</span> Condition notFull = <span class="keyword">lock</span>.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (list.size() == MAX_SIZE) &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"full,wait!"</span>);</span><br><span class="line">        notFull.<span class="keyword">await</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      list.<span class="keyword">add</span>(<span class="keyword">new</span> Object());</span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">"produce,now size is:"</span> + list.size());</span><br><span class="line">      notEmpty.signalAll();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (list.isEmpty()) &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"empty,wait!"</span>);</span><br><span class="line">        notEmpty.<span class="keyword">await</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      list.<span class="keyword">remove</span>(<span class="number">0</span>);</span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">"consume,now size is:"</span> + list.size());</span><br><span class="line">      notFull.signalAll();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">    Storage2 Storage2 = <span class="keyword">new</span> Storage2();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          Storage2.consume();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          Storage2.produce();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h1><ul><li>put()方法：容量达到最大时，自动阻塞。</li><li>take()方法：容量为0时，自动阻塞。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Storage3</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> LinkedBlockingDeque&lt;Object&gt; <span class="built_in">deque</span> = <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(MAX_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">deque</span>.size() == MAX_SIZE) &#123;</span><br><span class="line">      System.out.println(<span class="string">"full,wait!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">deque</span>.put(<span class="keyword">new</span> Object());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"produce,now size is:"</span> + <span class="built_in">deque</span>.size());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">deque</span>.isEmpty()) &#123;</span><br><span class="line">      System.out.println(<span class="string">"empty,wait!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">deque</span>.takeFirst();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"consume,now size is:"</span> + <span class="built_in">deque</span>.size());</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      生产者消费者
    
    </summary>
    
      <category term="java" scheme="http://langonggong.com/categories/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://langonggong.com/tags/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CyclicBarrier</title>
    <link href="http://langonggong.com/2018/11/17/CyclicBarrier/"/>
    <id>http://langonggong.com/2018/11/17/CyclicBarrier/</id>
    <published>2018-11-17T07:11:33.000Z</published>
    <updated>2020-06-22T16:40:36.954Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><code>回环栅栏</code>是一个同步工具类，它允许一组线程互相等待，直到到达某个公共屏障点。与CountDownLatch不同的是该barrier在释放等待线程后可以重用，所以称它为循环（Cyclic）的屏障（Barrier）</p><p>CyclicBarrier支持一个可选的Runnable命令，在一组线程中的最后一个线程到达之后（但在释放所有线程之前），该命令只在每个屏障点运行一次。若在继续所有参与线程之前更新共享状态，此屏障操作很有用</p><ul><li>CyclicBarrier(int parties)</li><li>CyclicBarrier(int parties, Runnable barrierAction)：参数parties指让多少个线程或者任务等待至barrier状态；参数barrierAction为当这些线程都达到barrier状态时会执行的内容</li><li>int await()：用来挂起当前线程，直至所有线程都到达barrier状态再同时执行后续任务</li><li>int await(long timeout, TimeUnit unit)：让这些线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务</li></ul><p>使用场景：多个子线程执行部分逻辑后进入就绪状态，停顿一下，然后等待某个关键线程执行，之后多个子线程再继续执行后面的逻辑</p>]]></content>
    
    <summary type="html">
    
      CyclicBarrier
    
    </summary>
    
      <category term="java" scheme="http://langonggong.com/categories/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://langonggong.com/tags/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数组中只出现了一次的数</title>
    <link href="http://langonggong.com/2018/11/08/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%BA%86%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0/"/>
    <id>http://langonggong.com/2018/11/08/数组中只出现了一次的数/</id>
    <published>2018-11-08T07:40:36.000Z</published>
    <updated>2020-06-22T16:40:36.964Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> FindNumsAppearOnce(<span class="keyword">int</span> [] <span class="keyword">array</span>,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[]) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">if</span> (<span class="keyword">array</span> == null || <span class="keyword">array</span>.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k0 = <span class="number">0</span>, k1 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//通过抑或运算，出现偶数次的元素消失</span></span><br><span class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> i : <span class="keyword">array</span>) &#123;</span><br><span class="line">      k0 = k0 ^ i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得该值二进制数字中的最右边的1</span></span><br><span class="line">    <span class="keyword">int</span> right = k0 &amp; (~k0 + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> i : <span class="keyword">array</span>) &#123;</span><br><span class="line">      <span class="built_in">if</span> ((right &amp; i) != <span class="number">0</span>) &#123;</span><br><span class="line">        k1 = k1 ^ i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    num1[<span class="number">0</span>] = Math.<span class="built_in">min</span>(k1, k1 ^ k0);</span><br><span class="line">    num2[<span class="number">0</span>] = Math.<span class="built_in">max</span>(k1, k1 ^ k0);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      数组中只出现了一次的数
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="位运算" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="位运算" scheme="http://langonggong.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>责任链模式</title>
    <link href="http://langonggong.com/2018/10/29/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://langonggong.com/2018/10/29/责任链模式/</id>
    <published>2018-10-29T14:55:07.000Z</published>
    <updated>2020-06-22T16:40:36.967Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>责任链模式是一种对象的行为模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。Tomcat中的Filter就是使用了责任链模式</p><p>Request<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> &#123;</span></span><br><span class="line">    String requestStr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> requestStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequest</span><span class="params">(String request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestStr = request;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Response<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span> &#123;</span></span><br><span class="line">    String responseStr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> responseStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResponse</span><span class="params">(String response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.responseStr = response;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Filter<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface Filter </span>&#123;</span><br><span class="line">    void doFilter(Request request,Response response,FilterChain chain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>HTMLFilter<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HTMLFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request request, Response response,FilterChain chain)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将字符串中出现的"&lt;&gt;"符号替换成"[]"</span></span><br><span class="line">        request.requestStr=request.requestStr</span><br><span class="line">                .replace(<span class="string">'&lt;'</span>, <span class="string">'['</span>).replace(<span class="string">'&gt;'</span>, <span class="string">']'</span>);</span><br><span class="line">        chain.doFilter(request, response,chain);</span><br><span class="line">        response.responseStr+=<span class="string">"---HTMLFilter()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SensitiveFilter<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SensitiveFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request request, Response response,FilterChain chain)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//处理字符串中的敏感信息，将被就业和谐成就业</span></span><br><span class="line">        request.requestStr=request.requestStr</span><br><span class="line">                .replace(<span class="string">"被就业"</span>, <span class="string">"就业"</span>).replace(<span class="string">"敏感"</span>, <span class="string">""</span>);</span><br><span class="line">        chain.doFilter(request, response,chain);</span><br><span class="line">        response.responseStr+=<span class="string">"---sensitiveFilter()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>FilterChain<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterChain</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">    <span class="comment">//用List集合来存储过滤规则</span></span><br><span class="line">    List&lt;Filter&gt; filters = <span class="keyword">new</span> ArrayList&lt;Filter&gt;();</span><br><span class="line">    <span class="comment">//用于标记规则的引用顺序</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">index</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//往规则链条中添加规则</span></span><br><span class="line">    <span class="keyword">public</span> FilterChain addFilter(Filter f) &#123;</span><br><span class="line">        filters.add(f);</span><br><span class="line">        <span class="comment">//代码的设计技巧:Chain链添加过滤规则结束后返回添加后的Chain，方便我们下面doFilter函数的操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> doFilter(Request request,Response response,FilterChain chain)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">index</span>==filters.size())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每添加一个过滤规则，index自增1</span></span><br><span class="line">        Filter f=filters.get(<span class="keyword">index</span>);</span><br><span class="line">        <span class="keyword">index</span>++;</span><br><span class="line">        <span class="comment">//根据索引值获取对应的规律规则对字符串进行处理</span></span><br><span class="line">        f.doFilter(request, response, chain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试用例<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span> args[]) &#123;</span><br><span class="line">        <span class="keyword">String</span> msg = <span class="string">":):,&lt;script&gt;,敏感,被就业,网络授课"</span>;</span><br><span class="line">        Request request=<span class="keyword">new</span> <span class="type">Request</span>();</span><br><span class="line">        request.setRequest(msg);</span><br><span class="line">        Response response=<span class="keyword">new</span> <span class="type">Response</span>();</span><br><span class="line">        response.setResponse(<span class="string">"response:"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//FilterChain,过滤规则形成的拦截链条</span></span><br><span class="line">        FilterChain fc=<span class="keyword">new</span> <span class="type">FilterChain</span>();</span><br><span class="line">        fc.addFilter(<span class="keyword">new</span> <span class="type">HTMLFilter</span>())</span><br><span class="line">        .addFilter(<span class="keyword">new</span> <span class="type">SensitiveFilter</span>())</span><br><span class="line">        .addFilter(<span class="keyword">new</span> <span class="type">FaceFilter</span>());</span><br><span class="line">        <span class="comment">//按照FilterChain的规则顺序，依次应用过滤规则</span></span><br><span class="line">        fc.doFilter(request, response,fc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      责任链模式
    
    </summary>
    
      <category term="设计模式" scheme="http://langonggong.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://langonggong.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>命令模式</title>
    <link href="http://langonggong.com/2018/10/29/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://langonggong.com/2018/10/29/命令模式/</id>
    <published>2018-10-29T09:22:57.000Z</published>
    <updated>2020-06-22T16:40:36.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><ul><li>更方便的对命令进行扩展（注意：这不是主要的优势，后面会提到）</li><li>对多个命令的统一控制（这种控制包括但不限于：队列、撤销/恢复、记录日志等等）</li></ul><h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><ul><li>Command：定义命令的统一接口</li><li>ConcreteCommand：Command接口的实现者，用来执行具体的命令，某些情况下可以直接用来充当Receiver</li><li>Receiver：命令的实际执行者</li><li>Invoker：命令的请求者，是命令模式中最重要的角色。这个角色用来对各个命令进行控制</li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>抽象角色<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>ICommand</span><br><span class="line">&#123;</span><br><span class="line">    void Execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>角色A<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConcreteCommandA</span> : <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommandA</span>(<span class="params">Receiver receiver</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver.DoA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>角色B<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConcreteCommandB</span> : <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommandB</span>(<span class="params">Receiver receiver</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver.DoB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Receiver<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//DoSomething</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//DoSomething</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Invoker<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Invoker</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ICommand command = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置命令</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetCommand</span>(<span class="params">ICommand command</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行命令</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RunCommand</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        command.Execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端调用<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Client()</span><br><span class="line">    &#123;</span><br><span class="line">        Receiver receiver = <span class="keyword">new</span> <span class="type">Receiver</span>();</span><br><span class="line">        Invoker invoker = <span class="keyword">new</span> <span class="type">Invoker</span>();</span><br><span class="line">        invoker.SetCommand(<span class="keyword">new</span> <span class="type">ConcreteCommandA</span>(receiver));</span><br><span class="line">        invoker.RunCommand();</span><br><span class="line">        invoker.SetCommand(<span class="keyword">new</span> <span class="type">ConcreteCommandB</span>(receiver));</span><br><span class="line">        invoker.RunCommand();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      命令模式
    
    </summary>
    
      <category term="设计模式" scheme="http://langonggong.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://langonggong.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="http://langonggong.com/2018/10/29/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://langonggong.com/2018/10/29/观察者模式/</id>
    <published>2018-10-29T06:29:27.000Z</published>
    <updated>2020-06-22T16:40:36.966Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><img src="/images/ObserverPattern.png"></p><ul><li>Subject（目标）：目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时它定义了通知方法notify()。目标类可以是接口，也可以是抽象类或具体类。 </li><li>ConcreteSubject（具体目标）：具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。如果无须扩展目标类，则具体目标类可以省略。 </li><li>Observer（观察者）：观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法update()，因此又称为抽象观察者。 </li><li>ConcreteObserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者Observer中定义的update()方法。通常在实现时，可以调用具体目标类的attach()方法将自己添加到目标类的集合中或通过detach()方法将自己从目标类的集合中删除</li></ul><p>定义一个抽象被观察者接口<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Observerable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span>(<span class="params">Observer o</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span>(<span class="params">Observer o</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span>(<span class="params"></span>)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义一个抽象观察者接口<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Observer &#123;</span><br><span class="line">    public void update(String message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义被观察者，实现了Observerable接口，对Observerable接口的三个方法进行了具体实现，同时有一个List集合，用以保存注册的观察者，等需要通知观察者时，遍历该集合即可<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WechatServer</span> <span class="title">implements</span> <span class="title">Observerable</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意到这个List集合的泛型参数为Observer接口，设计原则：面向接口编程而不是面向实现编程</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WechatServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">list</span>.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">list</span>.isEmpty())</span><br><span class="line">            <span class="built_in">list</span>.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.size(); i++) &#123;</span><br><span class="line">            Observer oserver = <span class="built_in">list</span>.get(i);</span><br><span class="line">            oserver.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfomation</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = s;</span><br><span class="line">        System.out.println(<span class="string">"微信服务更新消息： "</span> + s);</span><br><span class="line">        <span class="comment">//消息更新，通知所有观察者</span></span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义具体观察者，微信公众号的具体观察者为用户User<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        read();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">" 收到推送消息： "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试用例<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        WechatServer <span class="keyword">server</span> = <span class="keyword">new</span> WechatServer();</span><br><span class="line">        </span><br><span class="line">        Observer userZhang = <span class="keyword">new</span> User(<span class="string">"ZhangSan"</span>);</span><br><span class="line">        Observer userLi = <span class="keyword">new</span> User(<span class="string">"LiSi"</span>);</span><br><span class="line">        Observer userWang = <span class="keyword">new</span> User(<span class="string">"WangWu"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">server</span>. attach(userZhang);</span><br><span class="line">        <span class="keyword">server</span>. attach(userLi);</span><br><span class="line">        <span class="keyword">server</span>. attach(userWang);</span><br><span class="line">        <span class="keyword">server</span>.setInfomation(<span class="string">"PHP是世界上最好用的语言！"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">server</span>.removeObserver(userZhang);</span><br><span class="line">        <span class="keyword">server</span>.setInfomation(<span class="string">"JAVA是世界上最好用的语言！"</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      观察者模式
    
    </summary>
    
      <category term="设计模式" scheme="http://langonggong.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://langonggong.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>https</title>
    <link href="http://langonggong.com/2018/10/26/https/"/>
    <id>http://langonggong.com/2018/10/26/https/</id>
    <published>2018-10-26T09:44:29.000Z</published>
    <updated>2020-06-22T16:40:36.958Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><img src="/images/https-connect.png"></p><ul><li>客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</li><li>Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</li><li>客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</li><li>客户端的浏览器根据双方同意的安全等级，在本地生成一对对称密钥作为会话秘钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</li><li>Web服务器利用自己的私钥解密出会话密钥。</li><li>Web服务器利用会话密钥加密与客户端之间的通信</li></ul><p>为什么要同时用到对称秘钥和非对称秘钥?</p><ul><li>对称秘钥加密、解密效率高，涉及web页面和没提内容输出时更高效</li><li>对称秘钥不能以明文直接发给服务器，必须用非对称秘钥加密</li><li>对称秘钥是长度较短的随机字符，适合用非对称秘钥加密</li></ul>]]></content>
    
    <summary type="html">
    
      https
    
    </summary>
    
      <category term="计算机网络" scheme="http://langonggong.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="https" scheme="http://langonggong.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/https/"/>
    
    
      <category term="https" scheme="http://langonggong.com/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>求二进制数中的1的个数</title>
    <link href="http://langonggong.com/2018/10/25/%E6%B1%82%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B8%AD%E7%9A%841%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://langonggong.com/2018/10/25/求二进制数中的1的个数/</id>
    <published>2018-10-24T16:18:50.000Z</published>
    <updated>2020-06-22T16:40:36.964Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="built_in">int</span> NumberOf1(<span class="built_in">int</span> <span class="built_in">n</span>) &#123;</span><br><span class="line">  <span class="built_in">int</span> <span class="built_in">count</span> = <span class="number">0</span>;</span><br><span class="line">  while (<span class="built_in">n</span> != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">count</span>++;</span><br><span class="line">    <span class="built_in">n</span> = <span class="built_in">n</span> &amp; (<span class="built_in">n</span> - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  return <span class="built_in">count</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      求二进制数中的1的个数
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="位运算" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="位运算" scheme="http://langonggong.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>适配器模式</title>
    <link href="http://langonggong.com/2018/10/24/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://langonggong.com/2018/10/24/适配器模式/</id>
    <published>2018-10-24T15:07:28.000Z</published>
    <updated>2020-06-22T16:40:36.967Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>配器就是一种适配中间件，它存在于不匹配的二者之间，用于连接二者，将不匹配变得匹配，简单点理解就是平常所见的转接头，转换器之类的存在</p><p>类适配器</p><ul><li>想要使用一个已经存在的类，但是它却不符合现有的接口规范，导致无法直接去访问，这时创建一个适配器就能间接去访问这个类中的方法</li><li>我们有一个类，想将其设计为可重用的类（可被多处访问），我们可以创建适配器来将这个类来适配其他没有提供合适接口的类</li></ul><p>接口适配器</p><ul><li>想要使用接口中的某个或某些方法，但是接口中有太多方法，我们要使用时必须实现接口并实现其中的所有方法，可以使用抽象类来实现接口，并不对方法进行实现（仅置空），然后我们再继承这个抽象类来通过重写想用的方法的方式来实现。这个抽象类就是适配器</li></ul><p>Ps2<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Ps2 &#123;</span><br><span class="line">   void isPs2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Usb<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Usb &#123;</span><br><span class="line">  void isUsb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Usber<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Usber</span> <span class="keyword">implements</span> <span class="title">Usb</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isUsb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"USB口"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Adapter<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Usber</span> <span class="title">implements</span> <span class="title">Ps2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void isPs2() &#123;</span><br><span class="line">        isUsb();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      适配器模式
    
    </summary>
    
      <category term="设计模式" scheme="http://langonggong.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://langonggong.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="适配器模式" scheme="http://langonggong.com/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>前序、中序序列构建二叉树</title>
    <link href="http://langonggong.com/2018/10/22/%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E5%BA%8F%E5%88%97%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://langonggong.com/2018/10/22/前序、中序序列构建二叉树/</id>
    <published>2018-10-22T14:12:56.000Z</published>
    <updated>2020-06-22T16:40:36.962Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>使用递归，在当前处理中获取前序和中序遍历中的头结点、左子树、右子树，递归处理左右子树，返回构建好的树结构</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode reConstructBinaryTree(<span class="type">int</span> [] pre,<span class="type">int</span> [] <span class="keyword">in</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> solve(pre, <span class="number">0</span>, pre.<span class="built_in">length</span> - <span class="number">1</span>, <span class="keyword">in</span>, <span class="number">0</span>, <span class="keyword">in</span>.<span class="built_in">length</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public TreeNode solve(<span class="type">int</span>[] pre, <span class="type">int</span> preStart, <span class="type">int</span> preEnd, <span class="type">int</span>[] <span class="keyword">in</span>, <span class="type">int</span> inStart, <span class="type">int</span> inEnd) &#123;</span><br><span class="line">  <span class="keyword">if</span> (preStart &gt; preEnd) &#123;</span><br><span class="line">    <span class="keyword">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (preStart == preEnd) &#123;</span><br><span class="line">    <span class="keyword">return</span> new TreeNode(pre[preStart]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> cur = pre[preStart];</span><br><span class="line">  <span class="type">int</span> <span class="keyword">index</span> = inStart;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">index</span> &lt;= inEnd &amp;&amp; cur != <span class="keyword">in</span>[<span class="keyword">index</span>]) &#123;</span><br><span class="line">    <span class="keyword">index</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//左子树的长度</span></span><br><span class="line">  <span class="type">int</span> leftLength = <span class="keyword">index</span> - inStart;</span><br><span class="line">  TreeNode head = new TreeNode(pre[preStart]);</span><br><span class="line">  TreeNode left = solve(pre, preStart + <span class="number">1</span>, preStart + leftLength, <span class="keyword">in</span>, inStart, <span class="keyword">index</span> - <span class="number">1</span>);</span><br><span class="line">  TreeNode right = solve(pre, preStart + leftLength + <span class="number">1</span>, preEnd, <span class="keyword">in</span>, <span class="keyword">index</span> + <span class="number">1</span>, inEnd);</span><br><span class="line">  head.left = left;</span><br><span class="line">  head.right = right;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      根据前序、中序遍历的序列构建二叉树
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://langonggong.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>判断完全二叉树</title>
    <link href="http://langonggong.com/2018/10/19/%E5%88%A4%E6%96%AD%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://langonggong.com/2018/10/19/判断完全二叉树/</id>
    <published>2018-10-19T13:20:47.000Z</published>
    <updated>2020-06-22T16:40:36.962Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">chk</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">   TreeNode[] arr = <span class="keyword">new</span> TreeNode[<span class="number">501</span>];</span><br><span class="line">   <span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line">   TreeNode cur;</span><br><span class="line">   arr[tail++] = root;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (head != tail) &#123;</span><br><span class="line">     cur = arr[head++];</span><br><span class="line">     <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">       arr[tail++] = cur.left;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">       arr[tail++] = cur.right;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///判断是否应该是最后一个节点</span></span><br><span class="line">   <span class="keyword">boolean</span> isTail = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tail;i++) &#123;</span><br><span class="line">     cur = arr[i];</span><br><span class="line">     <span class="keyword">if</span> (cur.left == <span class="keyword">null</span> || cur.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (cur.left == <span class="keyword">null</span> &amp;&amp; cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (!isTail) &#123;</span><br><span class="line">         isTail = <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(cur.left != <span class="keyword">null</span> || cur.right != <span class="keyword">null</span>)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      判断完全二叉树
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="完全二叉树" scheme="http://langonggong.com/tags/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>判断二叉平衡树</title>
    <link href="http://langonggong.com/2018/10/19/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    <id>http://langonggong.com/2018/10/19/判断二叉平衡树/</id>
    <published>2018-10-19T12:10:38.000Z</published>
    <updated>2020-06-22T16:40:36.962Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> boolean check(<span class="type">TreeNode</span> root) &#123;</span><br><span class="line">  <span class="keyword">return</span> chk(root) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> int chk(<span class="type">TreeNode</span> treeNode) &#123;</span><br><span class="line">  <span class="keyword">if</span> (treeNode == null) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int <span class="keyword">left</span> = chk(treeNode.<span class="keyword">left</span>);</span><br><span class="line">  int <span class="keyword">right</span> = chk(treeNode.<span class="keyword">right</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">left</span> &lt; <span class="number">0</span> || <span class="keyword">right</span> &lt; <span class="number">0</span> || <span class="type">Math</span>.<span class="built_in">abs</span>(<span class="keyword">left</span> - <span class="keyword">right</span>) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">Math</span>.<span class="built_in">max</span>(<span class="keyword">left</span>, <span class="keyword">right</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      判断二叉平衡树
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://langonggong.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="二叉平衡树" scheme="http://langonggong.com/tags/%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>非递归遍历二叉树</title>
    <link href="http://langonggong.com/2018/10/19/%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://langonggong.com/2018/10/19/遍历二叉树/</id>
    <published>2018-10-19T10:50:40.000Z</published>
    <updated>2020-06-22T16:40:36.967Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] pre(TreeNode node) &#123;</span><br><span class="line">  Stack&lt;TreeNode&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">  TreeNode cur;</span><br><span class="line">  List&lt;Integer&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="built_in">stack</span>.push(node);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">    cur = <span class="built_in">stack</span>.pop();</span><br><span class="line">    <span class="built_in">list</span>.add(cur.val);</span><br><span class="line">    <span class="keyword">if</span> (cur.right != null) &#123;</span><br><span class="line">      <span class="built_in">stack</span>.push(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur.left != null) &#123;</span><br><span class="line">      <span class="built_in">stack</span>.push(cur.left);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> list2arr(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] mid(TreeNode node) &#123;</span><br><span class="line">  Stack&lt;TreeNode&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">  TreeNode cur = node;</span><br><span class="line">  List&lt;Integer&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="built_in">stack</span>.push(node);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">while</span> (cur != null &amp;&amp; cur.left != null) &#123;</span><br><span class="line">      <span class="built_in">stack</span>.push(cur.left);</span><br><span class="line">      cur = cur.left;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = <span class="built_in">stack</span>.pop();</span><br><span class="line">    <span class="built_in">list</span>.add(cur.val);</span><br><span class="line">    <span class="keyword">if</span> (cur.right != null) &#123;</span><br><span class="line">      <span class="built_in">stack</span>.push(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">    cur = cur.right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> list2arr(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] after(TreeNode node) &#123;</span><br><span class="line">  Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">  Stack&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  TreeNode cur;</span><br><span class="line">  stack1.push(node);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">    cur = stack1.pop();</span><br><span class="line">    stack2.push(cur);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur.left != null) &#123;</span><br><span class="line">      stack1.push(cur.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur.right != null) &#123;</span><br><span class="line">      stack1.push(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List&lt;Integer&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">while</span> (!stack2.isEmpty()) &#123;</span><br><span class="line">    <span class="built_in">list</span>.add(stack2.pop().val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> list2arr(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] list2arr(List&lt;Integer&gt; <span class="built_in">list</span>) &#123;</span><br><span class="line">  <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">list</span>.size()];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.size(); i++) &#123;</span><br><span class="line">    arr[i] = <span class="built_in">list</span>.get(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      非递归遍历二叉树
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://langonggong.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>长连接</title>
    <link href="http://langonggong.com/2018/10/14/%E9%95%BF%E8%BF%9E%E6%8E%A5/"/>
    <id>http://langonggong.com/2018/10/14/长连接/</id>
    <published>2018-10-14T07:33:17.000Z</published>
    <updated>2020-06-22T16:40:36.967Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h1><p><img src="/images/short-connection.png"></p><p>（挥手的地方，第一次发送FIN应该是客户端而非服务端）<br>http协议是无状态协议，每次的请求响应都是独立的<br>客户端通过http进程发起与服务主机的tcp连接，向所建立的tcp连接相关的本地套接字发送一个http请求消息。服务器与tcp相关的本地套接字收到这个请求后，进行处理，经由同一个套接字发出相应消息，同时告知tcp关闭tcp连接</p><h1 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h1><p>http1.1采用持续连接机制，即客户端和服务器建立tcp连接后，多个http请求可以重复利用已经建立起来的tcp连接。这个持续的tcp连接会空闲一段特定的时间后关闭</p><h2 id="不带流水线"><a href="#不带流水线" class="headerlink" title="不带流水线"></a>不带流水线</h2><p>用户的http请求只能在上一个请求得到响应后发出<br><img src="/images/no-pipeline-long-connection.png"></p><h2 id="带流水线"><a href="#带流水线" class="headerlink" title="带流水线"></a>带流水线</h2><p>客户端在web页面发现引用时就可以发起请求，无需考虑上一个请求的响应是否已经收到<br><img src="/images/pipeline-long-connection.png"></p>]]></content>
    
    <summary type="html">
    
      长连接
    
    </summary>
    
      <category term="计算机网络" scheme="http://langonggong.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="http" scheme="http://langonggong.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http/"/>
    
    
      <category term="http" scheme="http://langonggong.com/tags/http/"/>
    
      <category term="长连接" scheme="http://langonggong.com/tags/%E9%95%BF%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>tomcat</title>
    <link href="http://langonggong.com/2018/10/13/tomcat/"/>
    <id>http://langonggong.com/2018/10/13/tomcat/</id>
    <published>2018-10-13T07:11:17.000Z</published>
    <updated>2020-06-22T16:40:36.961Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="tomcat架构"><a href="#tomcat架构" class="headerlink" title="tomcat架构"></a>tomcat架构</h1><p><a href="https://blog.csdn.net/xlgen157387/article/details/79006434" target="_blank" rel="noopener">Tomcat系统架构</a></p><p><a href="https://www.cnblogs.com/diegodu/p/5915300.html" target="_blank" rel="noopener">Tomcat系统架构</a></p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/index.html?ca=drs-" target="_blank" rel="noopener">Tomcat系统架构</a></p><h1 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h1><p><a href="https://blog.csdn.net/gchd19921992/article/details/79076926" target="_blank" rel="noopener">Connector 分析</a></p><h1 id="Tomcat中的设计模式"><a href="#Tomcat中的设计模式" class="headerlink" title="Tomcat中的设计模式"></a>Tomcat中的设计模式</h1><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat2/index.html?ca=drs-" target="_blank" rel="noopener">设计模式</a></p><p><a href="https://blog.csdn.net/u012810020/article/details/71194853" target="_blank" rel="noopener">责任链模式</a></p>]]></content>
    
    <summary type="html">
    
      tomcat
    
    </summary>
    
      <category term="tomcat" scheme="http://langonggong.com/categories/tomcat/"/>
    
    
      <category term="tomcat" scheme="http://langonggong.com/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>DispatcherServlet</title>
    <link href="http://langonggong.com/2018/10/13/DispatcherServlet/"/>
    <id>http://langonggong.com/2018/10/13/DispatcherServlet/</id>
    <published>2018-10-13T07:11:17.000Z</published>
    <updated>2020-06-22T16:40:36.955Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="容器配置"><a href="#容器配置" class="headerlink" title="容器配置"></a>容器配置</h1><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">&lt;context-param&gt;</span></span><br><span class="line">    <span class="params">&lt;param-name&gt;</span>contextConfigLocation<span class="params">&lt;/param-name&gt;</span></span><br><span class="line">    <span class="params">&lt;param-value&gt;</span></span><br><span class="line"><span class="symbol">        classpath:</span>redis/spring-redis.xml</span><br><span class="line">    <span class="params">&lt;/param-value&gt;</span></span><br><span class="line"><span class="params">&lt;/context-param&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="params">&lt;listener&gt;</span></span><br><span class="line">    <span class="params">&lt;listener-class&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="params">&lt;/listener-class&gt;</span></span><br><span class="line"><span class="params">&lt;/listener&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="params">&lt;servlet&gt;</span></span><br><span class="line">    <span class="params">&lt;servlet-name&gt;</span>springMVC<span class="params">&lt;/servlet-name&gt;</span></span><br><span class="line">    <span class="params">&lt;servlet-class&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="params">&lt;/servlet-class&gt;</span></span><br><span class="line">    <span class="params">&lt;init-param&gt;</span></span><br><span class="line">        <span class="params">&lt;param-name&gt;</span>contextConfigLocation<span class="params">&lt;/param-name&gt;</span></span><br><span class="line">        <span class="params">&lt;param-value&gt;</span></span><br><span class="line"><span class="symbol">            classpath:</span>spring/spring-mvc.xml</span><br><span class="line">        <span class="params">&lt;/param-value&gt;</span></span><br><span class="line">    <span class="params">&lt;/init-param&gt;</span></span><br><span class="line">    <span class="params">&lt;load-on-startup&gt;</span><span class="number">1</span><span class="params">&lt;/load-on-startup&gt;</span></span><br><span class="line">    <span class="params">&lt;async-supported&gt;</span>true<span class="params">&lt;/async-supported&gt;</span></span><br><span class="line"><span class="params">&lt;/servlet&gt;</span></span><br><span class="line"><span class="params">&lt;servlet-mapping&gt;</span></span><br><span class="line">    <span class="params">&lt;servlet-name&gt;</span>springMVC<span class="params">&lt;/servlet-name&gt;</span></span><br><span class="line">    <span class="params">&lt;url-pattern&gt;</span>/<span class="params">&lt;/url-pattern&gt;</span></span><br><span class="line"><span class="params">&lt;/servlet-mapping&gt;</span></span><br></pre></td></tr></table></figure><table>   <tr>      <td colspan="2">参数</td>      <td colspan="5">描述</td>      </tr>   <tr>      <td colspan="2"> contextClass </td>      <td colspan="5">实现WebApplicationContext接口的类，当前的servlet用它来创建上下文。如果这个参数没有指定， 默认使用XmlWebApplicationContext</td>      </tr>   <tr>      <td colspan="2"> contextConfigLocation </td>      <td colspan="5">传给上下文实例（由contextClass指定）的字符串，用来指定上下文的位置。这个字符串可以被分成多个字符串（使用逗号作为分隔符） 来支持多个上下文（在多上下文的情况下，如果同一个bean被定义两次，后面一个优先）</td>      </tr>   <tr>      <td colspan="2"> namespace </td>      <td colspan="5">WebApplicationContext命名空间。默认值是[server-name]-servlet</td>      </tr></table><p>ContextLoaderListener初始化的上下文和DispatcherServlet初始化的上下文关系</p><p><img src="/images/Spring-Dispatcher.jpg"></p><p>从图中可以看出</p><ul><li>ContextLoaderListener初始化的上下文加载的Bean是对于整个应用程序共享的，不管是使用什么表现层技术，一般如DAO层、Service层Bean</li><li>DispatcherServlet初始化的上下文加载的Bean是只对Spring Web MVC有效的Bean，如Controller、HandlerMapping、HandlerAdapter等等，该初始化上下文应该只加载Web相关组件</li></ul><h1 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h1><h2 id="Spring-MVC容器的初始化"><a href="#Spring-MVC容器的初始化" class="headerlink" title="Spring MVC容器的初始化"></a>Spring MVC容器的初始化</h2><p>ContextLoaderListener监听器的作用就是启动Web容器（如tomcat）时，自动装配ApplicationContext的配置信息。因为它实现了ServletContextListener这个接口，在web.xml配置了这个监听器，启动容器时，就会默认执行它实现的contextInitialized()方法初始化WebApplicationContext实例，并放入到ServletContext中。由于在ContextLoaderListener继承了ContextLoader这个类，所以整个加载配置过程由ContextLoader来完成</p><h3 id="ServletContextListener接口"><a href="#ServletContextListener接口" class="headerlink" title="ServletContextListener接口"></a>ServletContextListener接口</h3><p>ServletContextListener中的核心逻辑便是初始化WebApplicationContext实例并存放至ServletContext中</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletContextListener</span> <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ** Notification that the web application initialization</span></span><br><span class="line"><span class="comment"> ** process is starting.</span></span><br><span class="line"><span class="comment"> ** All ServletContextListeners are notified of context</span></span><br><span class="line"><span class="comment"> ** initialization before any filter or servlet in the web</span></span><br><span class="line"><span class="comment"> ** application is initialized.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> contextInitialized ( ServletContextEvent sce );</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ** Notification that the servlet context is about to be shut down.</span></span><br><span class="line"><span class="comment"> ** All servlets and filters have been destroy()ed before any</span></span><br><span class="line"><span class="comment"> ** ServletContextListeners are notified of context</span></span><br><span class="line"><span class="comment"> ** destruction.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> contextDestroyed ( ServletContextEvent sce );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ContextLoaderListener类"><a href="#ContextLoaderListener类" class="headerlink" title="ContextLoaderListener类"></a>ContextLoaderListener类</h3><p>这是ContextLoaderListener中的contextInitialized()方法，这里主要是用initWebApplicationContext()方法来初始化WebApplicationContext。这里涉及到一个常用类WebApplicationContext：它继承自ApplicationContext，在ApplicationContext的基础上又追加了一些特定于Web的操作及属性</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ContextLoaderListener</span> <span class="title">extends</span> <span class="title">ContextLoader</span> <span class="title">implements</span> <span class="title">ServletContextListener</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span>(<span class="params">WebApplicationContext context</span>) </span>&#123;</span><br><span class="line">super(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the root web application context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span>(<span class="params">ServletContextEvent <span class="keyword">event</span></span>) </span>&#123;</span><br><span class="line">initWebApplicationContext(<span class="keyword">event</span>.getServletContext());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Close the root web application context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span>(<span class="params">ServletContextEvent <span class="keyword">event</span></span>) </span>&#123;</span><br><span class="line">closeWebApplicationContext(<span class="keyword">event</span>.getServletContext());</span><br><span class="line">ContextCleanupListener.cleanupAttributes(<span class="keyword">event</span>.getServletContext());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ContextLoader类"><a href="#ContextLoader类" class="headerlink" title="ContextLoader类"></a>ContextLoader类</h3><p>在initWebApplicationContext()方法中主要体现了WebApplicationContext实例的创建过程。首先，验证WebApplicationContext的存在性，通过查看ServletContext实例中是否有对应key的属性验证WebApplicationContext是否已经创建过实例。如果没有通过createWebApplicationContext()方法来创建实例，并存放至ServletContext中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize Spring's web application context for the given servlet context,</span></span><br><span class="line"><span class="comment"> * using the application context provided at construction time, or creating a new one</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> WebApplicationContext initWebApplicationContext(ServletContext servletContext) &#123;</span><br><span class="line"><span class="keyword">if</span> (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> new IllegalStateException(</span><br><span class="line"><span class="string">"Cannot initialize context because there is already a root application context present - "</span> +</span><br><span class="line"><span class="string">"check whether you have multiple ContextLoader* definitions in your web.xml!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Log logger = LogFactory.getLog(ContextLoader.<span class="keyword">class</span>);</span><br><span class="line">servletContext.log(<span class="string">"Initializing Spring root WebApplicationContext"</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Root WebApplicationContext: initialization started"</span>);</span><br><span class="line">&#125;</span><br><span class="line">long startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.context == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.context = createWebApplicationContext(servletContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.context instanceof ConfigurableWebApplicationContext) &#123;</span><br><span class="line">ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) <span class="keyword">this</span>.context;</span><br><span class="line"><span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line"><span class="keyword">if</span> (cwac.getParent() == <span class="literal">null</span>) &#123;</span><br><span class="line">ApplicationContext parent = loadParentContext(servletContext);</span><br><span class="line">cwac.setParent(parent);</span><br><span class="line">&#125;</span><br><span class="line">configureAndRefreshWebApplicationContext(cwac, servletContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.context);</span><br><span class="line"></span><br><span class="line">ClassLoader ccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line"><span class="keyword">if</span> (ccl == ContextLoader.<span class="keyword">class</span>.getClassLoader()) &#123;</span><br><span class="line">currentContext = <span class="keyword">this</span>.context;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ccl != <span class="literal">null</span>) &#123;</span><br><span class="line">currentContextPerThread.put(ccl, <span class="keyword">this</span>.context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Published root WebApplicationContext as ServletContext attribute with name ["</span> +</span><br><span class="line">WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">long elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">logger.info(<span class="string">"Root WebApplicationContext: initialization completed in "</span> + elapsedTime + <span class="string">" ms"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.context;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line">servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">logger.error(<span class="string">"Context initialization failed"</span>, err);</span><br><span class="line">servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);</span><br><span class="line"><span class="keyword">throw</span> err;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在createWebApplicationContext()方法中，通过BeanUtils.instanceClass()方法创建实例，而WebApplicationContext的实现类名称则通过determineContextClass()方法获得</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate the root WebApplicationContext for this loader, either the</span></span><br><span class="line"><span class="comment"> * default context class or a custom context class if specified.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> WebApplicationContext createWebApplicationContext(ServletContext sc) &#123;</span><br><span class="line"><span class="keyword">Class</span>&lt;?&gt; contextClass = determineContextClass(sc);</span><br><span class="line"><span class="keyword">if</span> (!ConfigurableWebApplicationContext.<span class="keyword">class</span>.isAssignableFrom(contextClass)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Custom context class ["</span> + contextClass.getName() +</span><br><span class="line"><span class="string">"] is not of type ["</span> + ConfigurableWebApplicationContext.<span class="keyword">class</span>.getName() + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>determineContextClass()方法，通过defaultStrategies.getProperty()方法获得实现类的名称，而defaultStrategies是在ContextLoader类的静态代码块中赋值的。具体的途径，则是读取ContextLoader类的同目录下的ContextLoader.properties属性文件来确定的</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the WebApplicationContext implementation class to use, either the</span></span><br><span class="line"><span class="comment"> * default XmlWebApplicationContext or a custom context class if specified.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">Class</span>&lt;?&gt; determineContextClass(ServletContext servletContext) &#123;</span><br><span class="line">String contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM);</span><br><span class="line"><span class="keyword">if</span> (contextClassName != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line"><span class="string">"Failed to load custom context class ["</span> + contextClassName + <span class="string">"]"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">contextClassName = defaultStrategies.getProperty(WebApplicationContext.<span class="keyword">class</span>.getName());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ClassUtils.forName(contextClassName, ContextLoader.<span class="keyword">class</span>.getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line"><span class="string">"Failed to load default context class ["</span> + contextClassName + <span class="string">"]"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ContextLoader.properties</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.context</span><span class="selector-class">.WebApplicationContext</span>=org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.context</span><span class="selector-class">.support</span><span class="selector-class">.XmlWebApplicationContext</span></span><br></pre></td></tr></table></figure><h2 id="diapatcherServlet的初始化"><a href="#diapatcherServlet的初始化" class="headerlink" title="diapatcherServlet的初始化"></a>diapatcherServlet的初始化</h2><p>DispatcherServlet实现了Servlet接口的实现类。Servlet的生命周期分为3个阶段：初始化、运行和销毁。而其初始化阶段可分为</p><ul><li>Servlet容器加载Servlet类，把类的.class文件中的数据读到内存中</li><li>Servlet容器中创建一个ServletConfig对象。该对象中包含了Servlet的初始化配置信息</li><li>Servlet容器创建一个Servlet对象</li><li>Servlet容器调用Servlet对象的init()方法进行初始化</li></ul><h3 id="HttpServletBean"><a href="#HttpServletBean" class="headerlink" title="HttpServletBean"></a>HttpServletBean</h3><p>Servlet的初始化阶段会调用它的init()方法，DispatcherServlet也不例外，在它的父类HttpServletBean中找到了该方法</p><p>init()方法中先通过ServletConfigPropertiesValues()方法对Servlet初始化参数进行封装，然后再将这个Servlet转换成一个BeanWrapper对象，从而能够以spring的方式来对初始化参数的值进行注入。这些属性如contextConfigLocation、namespace等等。同时注册一个属性编辑器，一旦在属性注入的时候遇到Resource类型的属性就会使用ResourceEditor去解析。再留一个initBeanWrapper(bw)方法给子类覆盖，让子类处真正执行BeanWrapper的属性注入工作。但是HttpServletBean的子类FrameworkServlet和DispatcherServlet都没有覆盖其initBeanWrapper(bw)方法，所以创建的BeanWrapper对象没有任何作用</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServletBean</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span></span><br><span class="line"><span class="class"><span class="title">implements</span> <span class="title">EnvironmentCapable</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Map config parameters onto bean properties of this servlet, and</span></span><br><span class="line"><span class="comment"> * invoke subclass initialization.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">public <span class="keyword">final</span> void init() <span class="keyword">throws</span> <span class="type">ServletException</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Initializing servlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">PropertyValues</span> pvs = <span class="keyword">new</span> <span class="type">ServletConfigPropertyValues</span>(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span><br><span class="line"><span class="type">BeanWrapper</span> bw = <span class="type">PropertyAccessorFactory</span>.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line"><span class="type">ResourceLoader</span> resourceLoader = <span class="keyword">new</span> <span class="type">ServletContextResourceLoader</span>(getServletContext());</span><br><span class="line">bw.registerCustomEditor(<span class="type">Resource</span>.<span class="keyword">class</span>, <span class="keyword">new</span> <span class="type">ResourceEditor</span>(resourceLoader, getEnvironment()));</span><br><span class="line">initBeanWrapper(bw);</span><br><span class="line">bw.setPropertyValues(pvs, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="type">BeansException</span> ex) &#123;</span><br><span class="line">logger.error(<span class="string">"Failed to set bean properties on servlet '"</span> + getServletName() + <span class="string">"'"</span>, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">initServletBean();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Servlet '"</span> + getServletName() + <span class="string">"' configured successfully"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> void initServletBean() <span class="keyword">throws</span> <span class="type">ServletException</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FrameworkServlet"><a href="#FrameworkServlet" class="headerlink" title="FrameworkServlet"></a>FrameworkServlet</h3><p>程序接着往下走，运行到了initServletBean()方法。在之前，ContextLoaderListener加载的时候已经创建了WebApplicationContext实例，而在这里是对这个实例的进一步补充初始化。这个方法在HttpServletBean的子类FrameworkServlet中得到了重写</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameworkServlet</span> <span class="keyword">extends</span> <span class="title">HttpServletBean</span> <span class="title">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Overridden method of &#123;@link HttpServletBean&#125;, invoked after any bean properties</span></span><br><span class="line"><span class="comment"> * have been set. Creates this servlet's WebApplicationContext.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> void initServletBean() <span class="keyword">throws</span> <span class="type">ServletException</span> &#123;</span><br><span class="line">getServletContext().log(<span class="string">"Initializing Spring FrameworkServlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.info(<span class="string">"FrameworkServlet '"</span> + getServletName() + <span class="string">"': initialization started"</span>);</span><br><span class="line">&#125;</span><br><span class="line">long startTime = <span class="type">System</span>.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">initFrameworkServlet();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="type">ServletException</span> ex) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="type">RuntimeException</span> ex) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">long elapsedTime = <span class="type">System</span>.currentTimeMillis() - startTime;</span><br><span class="line"><span class="keyword">this</span>.logger.info(<span class="string">"FrameworkServlet '"</span> + getServletName() + <span class="string">"': initialization completed in "</span> +</span><br><span class="line">elapsedTime + <span class="string">" ms"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initWebApplicationContext()方法主要用于创建或刷新WebApplicationContext实例，并对Servlet功能所使用的变量进行初始化。它获得ContextLoaderListener中初始化的rootContext。再通过构造函数和Servlet的contextAttribute属性查找ServletContext来进行webApplicationContext实例的初始化，如果都不行，只能重新创建一个新的实例。最终都要执行configureAndRefreshWebApplicationContext()方法中的refresh()方法完成servlet中配置文件的加载和与rootContext的整合</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize and publish the WebApplicationContext for this servlet.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Delegates to &#123;<span class="doctag">@link</span> #createWebApplicationContext&#125; for actual creation</span></span><br><span class="line"><span class="comment"> * of the context. Can be overridden in subclasses.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the WebApplicationContext instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #FrameworkServlet(WebApplicationContext)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setContextClass</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setContextConfigLocation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> WebApplicationContext initWebApplicationContext() &#123;</span><br><span class="line">WebApplicationContext rootContext =</span><br><span class="line">WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">WebApplicationContext wac = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">wac = <span class="keyword">this</span>.webApplicationContext;</span><br><span class="line"><span class="keyword">if</span> (wac instanceof ConfigurableWebApplicationContext) &#123;</span><br><span class="line">ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line"><span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line"><span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line"><span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line"><span class="keyword">if</span> (cwac.getParent() == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line"><span class="comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line">cwac.setParent(rootContext);</span><br><span class="line">&#125;</span><br><span class="line">configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line"><span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line"><span class="comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line"><span class="comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line">wac = findWebApplicationContext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">wac = createWebApplicationContext(rootContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</span><br><span class="line"><span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class="line"><span class="comment">// support or the context injected at construction time had already been</span></span><br><span class="line"><span class="comment">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class="line">onRefresh(wac);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</span><br><span class="line"><span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line">String attrName = getServletContextAttributeName();</span><br><span class="line">getServletContext().setAttribute(attrName, wac);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.debug(<span class="string">"Published WebApplicationContext of servlet '"</span> + getServletName() +</span><br><span class="line"><span class="string">"' as ServletContext attribute with name ["</span> + attrName + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onRefresh(wac)方法是FrameworkServlet提供的模板方法，在其子类DispatcherServlet的onRefresh()方法中进行了重写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="comment">// For subclasses: do nothing by default.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h3><p>在onRefresh()方法中调用了initStrategies()方法来完成初始化工作，初始化Spring MVC的9个组件</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="keyword">DispatcherServlet </span><span class="keyword">extends </span>FrameworkServlet &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This implementation calls &#123;@link #initStrategies&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Override</span><br><span class="line">protected void onRefresh(ApplicationContext <span class="built_in">context</span>) &#123;</span><br><span class="line">initStrategies(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the strategy objects that this servlet uses.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">protected void initStrategies(ApplicationContext <span class="built_in">context</span>) &#123;</span><br><span class="line">initMultipartResolver(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">initLocaleResolver(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">initThemeResolver(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">initHandlerMappings(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">initHandlerAdapters(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">initHandlerExceptionResolvers(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">initRequestToViewNameTranslator(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">initViewResolvers(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">initFlashMapManager(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="DispatcherServlet详解"><a href="#DispatcherServlet详解" class="headerlink" title="DispatcherServlet详解"></a>DispatcherServlet详解</h1><h2 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h2><p>DispatcherServlet的默认配置在DispatcherServlet.properties（和DispatcherServlet类在一个包下）中，而且是当Spring配置文件中没有指定配置时使用的默认策略</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.LocaleResolver</span>=org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.i18n</span><span class="selector-class">.AcceptHeaderLocaleResolver</span></span><br><span class="line"></span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.ThemeResolver</span>=org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.theme</span><span class="selector-class">.FixedThemeResolver</span></span><br><span class="line"></span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.HandlerMapping</span>=org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.handler</span><span class="selector-class">.BeanNameUrlHandlerMapping</span>,\</span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.mvc</span><span class="selector-class">.annotation</span><span class="selector-class">.DefaultAnnotationHandlerMapping</span></span><br><span class="line"></span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.HandlerAdapter</span>=org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.mvc</span><span class="selector-class">.HttpRequestHandlerAdapter</span>,\</span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.mvc</span><span class="selector-class">.SimpleControllerHandlerAdapter</span>,\</span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.mvc</span><span class="selector-class">.annotation</span><span class="selector-class">.AnnotationMethodHandlerAdapter</span></span><br><span class="line"></span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.HandlerExceptionResolver</span>=org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.mvc</span><span class="selector-class">.annotation</span><span class="selector-class">.AnnotationMethodHandlerExceptionResolver</span>,\</span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.mvc</span><span class="selector-class">.annotation</span><span class="selector-class">.ResponseStatusExceptionResolver</span>,\</span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.mvc</span><span class="selector-class">.support</span><span class="selector-class">.DefaultHandlerExceptionResolver</span></span><br><span class="line"></span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.RequestToViewNameTranslator</span>=org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.view</span><span class="selector-class">.DefaultRequestToViewNameTranslator</span></span><br><span class="line"></span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.ViewResolver</span>=org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.view</span><span class="selector-class">.InternalResourceViewResolver</span></span><br><span class="line"></span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.FlashMapManager</span>=org<span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.servlet</span><span class="selector-class">.support</span><span class="selector-class">.SessionFlashMapManager</span></span><br></pre></td></tr></table></figure><h2 id="使用的特殊的Bean"><a href="#使用的特殊的Bean" class="headerlink" title="使用的特殊的Bean"></a>使用的特殊的Bean</h2><p>DispatcherServlet默认使用WebApplicationContext作为上下文，该上下文中有些特殊的Bean</p><ul><li>Controller<br>  处理器/页面控制器，做的是MVC中的C的事情，但控制逻辑转移到前端控制器了，用于对请求进行处理</li><li>HandlerMapping<br>  请求到处理器的映射，如果映射成功返回一个HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象、多个HandlerInterceptor拦截器）对象；如BeanNameUrlHandlerMapping将URL与Bean名字映射，映射成功的Bean就是此处的处理器</li><li>HandlerAdapter<br>  HandlerAdapter将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；如SimpleControllerHandlerAdapter将对实现了Controller接口的Bean进行适配，并且掉处理器的handleRequest方法进行功能处理</li><li>ViewResolver<br>  ViewResolver将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；如InternalResourceViewResolver将逻辑视图名映射为jsp视图</li><li>LocalResover<br>  本地化解析，因为Spring支持国际化，因此LocalResover解析客户端的Locale信息从而方便进行国际化</li><li>ThemeResovler<br>  主题解析，通过它来实现一个页面多套风格，即常见的类似于软件皮肤效果</li><li>MultipartResolver<br>  文件上传解析，用于支持文件上传</li><li>HandlerExceptionResolver<br>  处理器异常解析，可以将异常映射到相应的统一错误界面，从而显示用户友好的界面（而不是给用户看到具体的错误信息）</li><li>RequestToViewNameTranslator<br>  当处理器没有返回逻辑视图名等相关信息时，自动将请求URL映射为逻辑视图名</li><li>FlashMapManager<br>  用于管理FlashMap的策略接口，FlashMap用于存储一个请求的输出，当进入另一个请求时作为该请求的输入，通常用于重定向场景，后边会细述</li></ul><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p><img src="/images/DispatcherServlet.png"></p><p><img src="/images/dispatcher-chain.png"></p><ul><li>用户发请求—&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制。</li><li>DispatcherServlet—&gt;HandlerMapping，HandlerMapping将会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器,多个HandlerInterceptor拦截器)。</li><li>DispatcherServlet—&gt;HandlerAdapter,HandlerAdapter将会把处理器包装为适配器，从而支持多种类型的处理器。</li><li>HandlerAdapter—&gt;处理器功能处理方法的调用，HandlerAdapter将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理，并返回一个ModelAndView对象(包含模型数据，逻辑视图名)</li><li>ModelAndView的逻辑视图名—&gt;ViewResolver，ViewResoler将把逻辑视图名解析为具体的View。</li><li>View—&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构</li><li>返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户。</li></ul>]]></content>
    
    <summary type="html">
    
      DispatcherServlet原理讲解
    
    </summary>
    
      <category term="spring" scheme="http://langonggong.com/categories/spring/"/>
    
      <category term="spring mvc" scheme="http://langonggong.com/categories/spring/spring-mvc/"/>
    
    
      <category term="DispatcherServlet" scheme="http://langonggong.com/tags/DispatcherServlet/"/>
    
      <category term="SpringMvc" scheme="http://langonggong.com/tags/SpringMvc/"/>
    
  </entry>
  
  <entry>
    <title>代理</title>
    <link href="http://langonggong.com/2018/10/09/%E4%BB%A3%E7%90%86/"/>
    <id>http://langonggong.com/2018/10/09/代理/</id>
    <published>2018-10-09T15:45:25.000Z</published>
    <updated>2020-06-22T16:40:36.962Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h1><p>正向代理（Forward Proxy）方式下，使用者需要配置网络访问的代理服务器为Cache设备的地址，内网对互联网的所有访问都是通过代理服务器完成</p><p><img src="/images/forward-proxy1.png"></p><p>正向代理多用于与小企业网络环境，Cache设备作为企业网的出口网关提供代理服务（例如翻墙访问谷歌）、内容缓存、Internet访问控制、安全认证等功能</p><p><img src="/images/forward-proxy2.png"></p><h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><h1 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h1>]]></content>
    
    <summary type="html">
    
      代理
    
    </summary>
    
      <category term="计算机网络" scheme="http://langonggong.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://langonggong.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>CND加速</title>
    <link href="http://langonggong.com/2018/10/05/CND%E5%8A%A0%E9%80%9F/"/>
    <id>http://langonggong.com/2018/10/05/CND加速/</id>
    <published>2018-10-05T14:01:53.000Z</published>
    <updated>2020-06-22T16:40:36.953Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="网页加速"><a href="#网页加速" class="headerlink" title="网页加速"></a>网页加速</h1><p>CDN服务商通过将网页内容缓存到各个CND节点上，并将用户请求调度到最优节点上来获取所需的内容，从而加速页面相应速度、减轻源站点的访问负担</p><h1 id="流媒体加速"><a href="#流媒体加速" class="headerlink" title="流媒体加速"></a>流媒体加速</h1><p>将流媒体内容推送到离用户最近的POP点，使得用户能够从网络边缘获取内容，从而提高视频传输质量，缩短访问时间，节省骨干网络流量，避免单一中心的服务器瓶颈问题</p><h1 id="文件传输加速"><a href="#文件传输加速" class="headerlink" title="文件传输加速"></a>文件传输加速</h1><p>使用CND分布式POP点提供下载服务，网站可以将大量文件下载的性能压力和带宽压力交给CND来分担，提高用户的下载速度</p><h1 id="应用协议加速"><a href="#应用协议加速" class="headerlink" title="应用协议加速"></a>应用协议加速</h1><p>不针对特定内容类型进行加速，而是通过对TCP/IP等传输协议优化，或对SSL协议加速</p><h2 id="广域网应用加速"><a href="#广域网应用加速" class="headerlink" title="广域网应用加速"></a>广域网应用加速</h2><p>目的是“让广域网像局域网一样”</p><p>将分布式的IT基础设施如文件服务器、邮件服务器、网络附加存储（NAS）和远程办公室备份系统集中起来，整合到统一的数据中心</p><h2 id="SSL应用加速"><a href="#SSL应用加速" class="headerlink" title="SSL应用加速"></a>SSL应用加速</h2><p>由CDN的专用SSL加速硬件来完成加密解密运算工作，通过认证之后方可建立起数据传输通道。用户的源站点只需信任有限的CDN cache，而无需面对海量用户，从而减轻了繁重的运算和认证压力</p><h2 id="网页压缩"><a href="#网页压缩" class="headerlink" title="网页压缩"></a>网页压缩</h2><p>可以在服务器端对网页数据进行压缩，将压缩后的文件提供给用户，在浏览器端解压显示。<br>CDN为网站提供网页内容的压缩传输，从而加快内容传输速度</p>]]></content>
    
    <summary type="html">
    
      CND加速
    
    </summary>
    
      <category term="计算机网络" scheme="http://langonggong.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="CDN" scheme="http://langonggong.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CDN/"/>
    
    
      <category term="计算机网络" scheme="http://langonggong.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="CDN" scheme="http://langonggong.com/tags/CDN/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡</title>
    <link href="http://langonggong.com/2018/10/05/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://langonggong.com/2018/10/05/负载均衡/</id>
    <published>2018-10-05T13:52:21.000Z</published>
    <updated>2020-06-22T16:40:36.967Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="全局负载均衡（GSLB）"><a href="#全局负载均衡（GSLB）" class="headerlink" title="全局负载均衡（GSLB）"></a>全局负载均衡（GSLB）</h1><h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><h1 id="本地负载均衡（SLB）"><a href="#本地负载均衡（SLB）" class="headerlink" title="本地负载均衡（SLB）"></a>本地负载均衡（SLB）</h1><h2 id="4层调度"><a href="#4层调度" class="headerlink" title="4层调度"></a>4层调度</h2><h2 id="7层调度"><a href="#7层调度" class="headerlink" title="7层调度"></a>7层调度</h2><h2 id="链路负载调度"><a href="#链路负载调度" class="headerlink" title="链路负载调度"></a>链路负载调度</h2>]]></content>
    
    <summary type="html">
    
      CDN详解
    
    </summary>
    
      <category term="计算机网络" scheme="http://langonggong.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://langonggong.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>CDN</title>
    <link href="http://langonggong.com/2018/10/05/CDN/"/>
    <id>http://langonggong.com/2018/10/05/CDN/</id>
    <published>2018-10-05T13:49:15.000Z</published>
    <updated>2020-06-22T16:40:36.953Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>]]></content>
    
    <summary type="html">
    
      CDN详解
    
    </summary>
    
      <category term="计算机网络" scheme="http://langonggong.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="CDN" scheme="http://langonggong.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CDN/"/>
    
    
      <category term="计算机网络" scheme="http://langonggong.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="CDN" scheme="http://langonggong.com/tags/CDN/"/>
    
  </entry>
  
  <entry>
    <title>uml</title>
    <link href="http://langonggong.com/2018/10/03/uml/"/>
    <id>http://langonggong.com/2018/10/03/uml/</id>
    <published>2018-10-03T02:43:16.000Z</published>
    <updated>2020-06-22T16:40:36.961Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><img src="/images/uml-class.png"></p>]]></content>
    
    <summary type="html">
    
      uml类图
    
    </summary>
    
      <category term="软件工程" scheme="http://langonggong.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件工程" scheme="http://langonggong.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="uml" scheme="http://langonggong.com/tags/uml/"/>
    
  </entry>
  
  <entry>
    <title>linux IO模型</title>
    <link href="http://langonggong.com/2018/09/27/IO%E6%A8%A1%E5%9E%8B/"/>
    <id>http://langonggong.com/2018/09/27/IO模型/</id>
    <published>2018-09-27T11:49:04.000Z</published>
    <updated>2020-06-22T16:40:36.956Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在linux系统下面，根据IO操作的是否被阻塞以及同步异步问题进行分类，可以得到下面五种IO模型</p><ul><li>阻塞I/O（blocking I/O）</li><li>非阻塞I/O （nonblocking I/O）</li><li>I/O复用(select 和poll) （I/O multiplexing）</li><li>信号驱动I/O （signal driven I/O (SIGIO)）</li><li>异步I/O （asynchronous I/O (the POSIX aio_functions)）</li></ul><p>对于一个network IO (以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段：</p><ul><li>等待数据准备 (Waiting for the data to be ready)</li><li>将数据从内核拷贝到进程中(Copying the data from the kernel to the process)</li></ul><p>这些IO模型的区别就是在两个阶段上各有不同的情况</p><ul><li>阻塞IO（blocking IO）<br>  调用blocking IO会一直block住对应的进程直到操作完成</li><li>非阻塞IO（non-blocking IO）<br>  在kernel还在准备数据的情况下会立刻返回。在执行recvfrom这个系统调用的时候，如果kernel的数据没有准备好，这时候不会block进程。但是当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内进程是被block的</li><li>同步IO（synchronous IO）<br>  做IO 操作的时候会将进程阻塞。按照这个定义，blocking IO，non-blocking IO，IO multiplexing都属于同步IO</li><li>异步IO（asynchronous IO）<br>  当进程发起IO操作之后，就直接返回，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block</li></ul><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="阻塞IO（blocking-IO）"><a href="#阻塞IO（blocking-IO）" class="headerlink" title="阻塞IO（blocking IO）"></a>阻塞IO（blocking IO）</h2><p><img src="/images/Blocking-IO.png"></p><p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p><p>所以，blocking IO的特点就是在IO执行的两个阶段（等待数据和拷贝数据两个阶段）都被block了。</p><p>可能同时出现的上千甚至上万次的客户端请求，“线程池”或“连接池”或许可以缓解部分压力，但是不能解决所有问题。总之，多线程模型可以方便高效的解决小规模的服务请求，但面对大规模的服务请求，多线程模型也会遇到瓶颈，可以用非阻塞接口来尝试解决这个问题</p><h2 id="非阻塞IO（non-blocking-IO）"><a href="#非阻塞IO（non-blocking-IO）" class="headerlink" title="非阻塞IO（non-blocking IO）"></a>非阻塞IO（non-blocking IO）</h2><p>Linux下，可以通过设置socket使其变为non-blocking<br><img src="/images/Nonblocking-IO.png"></p><p>从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p><p>所以，在非阻塞式IO中，用户进程其实是需要不断的主动询问kernel数据准备好了没有。</p><p>循环调用recv()将大幅度推高CPU 占用率；此外，在这个方案中recv()更多的是起到检测“操作是否完成”的作用，实际操作系统提供了更为高效的检测“操作是否完成“作用的接口，例如select()多路复用模式，可以一次检测多个连接是否活跃</p><h2 id="多路复用IO（IO-multiplexing）"><a href="#多路复用IO（IO-multiplexing）" class="headerlink" title="多路复用IO（IO multiplexing）"></a>多路复用IO（IO multiplexing）</h2><p>有些地方也称这种IO方式为事件驱动IO(event driven IO)。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程</p><p><img src="/images/IO-multiplexing.png"></p><p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p><p>这个图和blocking IO的图其实并没有太大的不同，事实上还更差一些。因为这里需要使用两个系统调用(select和recvfrom)，而blocking IO只调用了一个系统调用(recvfrom)。但是，用select的优势在于它可以同时处理多个connection</p><p>在多路复用模型中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。因此select()与非阻塞IO类似</p><p>select()接口并不是实现“事件驱动”的最好选择。因为当需要探测的句柄值较大时，select()接口本身需要消耗大量时间去轮询各个句柄</p><h2 id="信号驱动I-O（signal-driven-I-O）"><a href="#信号驱动I-O（signal-driven-I-O）" class="headerlink" title="信号驱动I/O（signal driven I/O）"></a>信号驱动I/O（signal driven I/O）</h2><p><img src="/images/Signal-Driven-IO.png"></p><p>两次调用，两次返回<br>允许套接口进行信号驱动I/O,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据</p><h2 id="异步I-O-（asynchronous-I-O）"><a href="#异步I-O-（asynchronous-I-O）" class="headerlink" title="异步I/O （asynchronous I/O）"></a>异步I/O （asynchronous I/O）</h2><p><img src="/images/Asynchronous-IO.png"></p><p>用户进程发起read操作之后，立刻就可以开始去做其它的事。从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了</p><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>非阻塞IO ，IO请求时加上O_NONBLOCK一类的标志位，立刻返回，IO没有就绪会返回错误，需要请求进程主动轮询不断发IO请求直到返回正确。</p><p>IO复用同非阻塞IO本质一样，不过利用了新的select系统调用，由内核来负责本来是请求进程该做的轮询操作。看似比非阻塞IO还多了一个系统调用开销，不过因为可以支持多路IO，才算提高了效率。</p><p>信号驱动IO，调用sigaltion系统调用，当内核中IO数据就绪时以SIGIO信号通知请求进程，请求进程再把数据从内核读入到用户空间，这一步是阻塞的。</p><p>异步IO，如定义所说，不会因为IO操作阻塞，IO操作全部完成才通知请求进程</p><p><img src="/images/IO-Comparison.png"><br>左边四种方式，第一阶段不同，第二阶段相同（调用recvFrom发生阻塞）</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p><a href="https://blog.csdn.net/hguisu/article/details/7453390" target="_blank" rel="noopener">socket阻塞与非阻塞，同步与异步、I/O模型</a><br><a href="https://my.oschina.net/XYleung/blog/295122" target="_blank" rel="noopener">网络IO模型</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      linux IO模型
    
    </summary>
    
      <category term="linux" scheme="http://langonggong.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://langonggong.com/tags/linux/"/>
    
      <category term="IO" scheme="http://langonggong.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>BlockingQueue</title>
    <link href="http://langonggong.com/2018/09/25/BlockingQueue/"/>
    <id>http://langonggong.com/2018/09/25/BlockingQueue/</id>
    <published>2018-09-25T07:53:14.000Z</published>
    <updated>2020-06-22T16:40:36.953Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>阻塞队列与我们平常接触的普通队列(LinkedList或ArrayList等)的最大不同点，在于阻塞队列支持阻塞添加和阻塞删除方法</p><p>Java中的阻塞队列接口BlockingQueue继承自Queue接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量）</span></span><br><span class="line">    <span class="comment">//在成功时返回 true，如果此队列已满，则抛IllegalStateException。 </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量） </span></span><br><span class="line">    <span class="comment">// 将指定的元素插入此队列的尾部，如果该队列已满， </span></span><br><span class="line">    <span class="comment">//则在到达指定的等待时间之前等待可用的空间,该方法可中断 </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//将指定的元素插入此队列的尾部，如果该队列已满，则一直等到（阻塞）。 </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取并移除此队列的头部，如果没有元素则等待（阻塞）， </span></span><br><span class="line">    <span class="comment">//直到有元素将唤醒等待线程执行该操作 </span></span><br><span class="line">    <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取并移除此队列的头部，在指定的等待时间前一直等到获取元素， //超过时间方法将结束</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//从此队列中移除指定元素的单个实例（如果存在）。 </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>插入方法：<br>add(E e) : 添加成功返回true，失败抛IllegalStateException异常<br>offer(E e) : 成功返回 true，如果此队列已满，则返回 false。<br>put(E e) :将元素插入此队列的尾部，如果该队列已满，则一直阻塞</p></li><li><p>删除方法:<br>remove(Object o) :移除指定元素,成功返回true，失败返回false<br>poll() : 获取并移除此队列的头元素，若队列为空，则返回 null<br>take()：获取并移除此队列头元素，若没有元素则一直阻塞。</p></li><li><p>检查方法<br>element() ：获取但不移除此队列的头元素，没有元素则抛异常<br>peek() :获取但不移除此队列的头；若队列为空，则返回 null。</p></li></ul><h1 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>ArrayBlockingQueue的内部是通过一个可重入锁ReentrantLock和两个Condition条件对象来实现阻塞<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** 存储数据的数组 *</span>/</span></span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Object</span>[] items;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">**获取数据的索引，主要用于take，poll，peek，remove方法 *</span>/</span></span></span><br><span class="line">    <span class="built_in">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">**添加数据的索引，主要用于 put, offer, or add 方法*</span>/</span></span></span><br><span class="line">    <span class="built_in">int</span> putIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** 队列元素的个数 *</span>/</span></span></span><br><span class="line">    <span class="built_in">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** 控制并非访问的锁 *</span>/</span></span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">**notEmpty条件对象，用于通知take方法队列已有元素，可执行获取操作 *</span>/</span></span></span><br><span class="line">    private <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">**notFull条件对象，用于通知put方法队列未满，可执行添加操作 *</span>/</span></span></span><br><span class="line">    private <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">       迭代器</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    transient Itrs itrs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><p>put方法，它是一个阻塞添加的方法<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put方法，阻塞时可中断</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span>(<span class="params">E e</span>) throws InterruptedException </span>&#123;</span><br><span class="line">     checkNotNull(e);</span><br><span class="line">      final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">      <span class="keyword">lock</span>.lockInterruptibly();<span class="comment">//该方法可中断</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//当队列元素个数与数组长度相等时，无法添加元素</span></span><br><span class="line">          <span class="keyword">while</span> (count == items.length)</span><br><span class="line">              <span class="comment">//将当前调用线程挂起，添加到notFull条件队列中等待唤醒</span></span><br><span class="line">              notFull.<span class="keyword">await</span>();</span><br><span class="line">          enqueue(e);<span class="comment">//如果队列没有满直接添加。。</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">lock</span>.unlock();</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h2 id="take方法"><a href="#take方法" class="headerlink" title="take方法"></a>take方法</h2><p>take()方法，是一个阻塞方法，直接获取队列头元素并删除<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从队列头部删除，队列没有元素就阻塞，可中断</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">take</span>(<span class="params"></span>) throws InterruptedException </span>&#123;</span><br><span class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">      <span class="keyword">lock</span>.lockInterruptibly();<span class="comment">//中断</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//如果队列没有元素</span></span><br><span class="line">          <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">              <span class="comment">//执行阻塞操作</span></span><br><span class="line">              notEmpty.<span class="keyword">await</span>();</span><br><span class="line">          <span class="keyword">return</span> dequeue();<span class="comment">//如果队列有元素执行删除操作</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">lock</span>.unlock();</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h1 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h1><p>LinkedBlockingQueue是一个由链表实现的有界队列阻塞队列，但大小默认值为Integer.MAX_VALUE，所以在使用LinkedBlockingQueue时建议手动传值，为其提供我们所需的大小，避免队列过大造成机器负载或者内存爆满等情况</p><p>在正常情况下，链接队列的吞吐量要高于基于数组的队列（ArrayBlockingQueue），因为其内部实现添加和删除操作使用的两个ReenterLock来控制并发执行，而ArrayBlockingQueue内部只是使用一个ReenterLock控制并发，因此LinkedBlockingQueue的吞吐量要高于ArrayBlockingQueue<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue&lt;E&gt;</span> <span class="keyword">extends</span> <span class="title">AbstractQueue&lt;E&gt;</span></span></span><br><span class="line"><span class="class">        <span class="title">implements</span> <span class="title">BlockingQueue&lt;E&gt;</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点类，用于存储数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    static <span class="class"><span class="keyword">class</span> <span class="title">Node&lt;E&gt;</span> </span>&#123;</span><br><span class="line">        <span class="type">E</span> item;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span>&lt;<span class="type">E</span>&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span>(<span class="type">E</span> x) &#123; item = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 阻塞队列的大小，默认为Integer.MAX_VALUE */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当前阻塞队列中的元素个数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> count = <span class="keyword">new</span> <span class="type">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞队列的头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    transient <span class="type">Node</span>&lt;<span class="type">E</span>&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞队列的尾节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> transient <span class="type">Node</span>&lt;<span class="type">E</span>&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取并移除元素时使用的锁，如take, poll, etc */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> takeLock = <span class="keyword">new</span> <span class="type">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** notEmpty条件对象，当队列没有数据时用于挂起执行删除的线程 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 添加元素时使用的锁如 put, offer, etc */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> putLock = <span class="keyword">new</span> <span class="type">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** notFull条件对象，当队列数据已满时用于挂起执行添加的线程 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> notFull = putLock.newCondition();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="take方法-1"><a href="#take方法-1" class="headerlink" title="take方法"></a>take方法</h2><ul><li>如果队列没有数据就挂起当前线程到 notEmpty条件对象的等待队列中一直等待，如果有数据就删除节点并返回数据项，同时唤醒后续消费线程(如果不为空)</li><li>尝试唤醒条件对象notFull上等待队列中的添加线程</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">E</span> take() <span class="keyword">throws</span> <span class="type">InterruptedException</span> &#123;</span><br><span class="line">    <span class="type">E</span> x;</span><br><span class="line">    int <span class="built_in">c</span> = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="built_in">count</span> = this.<span class="built_in">count</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> takeLock = this.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">count</span>.<span class="keyword">get</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        <span class="built_in">c</span> = <span class="built_in">count</span>.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">c</span> &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">c</span> == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">signalNotFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="put方法-1"><a href="#put方法-1" class="headerlink" title="put方法"></a>put方法</h2><ul><li>如果队列已满就挂起当前线程到notFull条件对象的等待队列中一直等待，如果有空余节点就添加当前节点，同时唤醒后续生产线程(如果队列未满)</li><li>尝试唤醒条件对象notEmpty上等待队列中的添加线程</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> put(E e) <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger <span class="keyword">count</span> = <span class="keyword">this</span>.<span class="keyword">count</span>;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">count</span>.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(node);</span><br><span class="line">        c = <span class="keyword">count</span>.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ul><li><p>队列大小有所不同，ArrayBlockingQueue是有界的初始化必须指定大小，而LinkedBlockingQueue可以是有界的也可以是无界的(Integer.MAX_VALUE)，对于后者而言，当添加速度大于移除速度时，在无界的情况下，可能会造成内存溢出等问题。</p></li><li><p>数据存储容器不同，ArrayBlockingQueue采用的是数组作为数据存储容器，而LinkedBlockingQueue采用的则是以Node节点作为连接对象的链表。</p></li><li><p>由于ArrayBlockingQueue采用的是数组的存储容器，因此在插入或删除元素时不会产生或销毁任何额外的对象实例，而LinkedBlockingQueue则会生成一个额外的Node对象。这可能在长时间内需要高效并发地处理大批量数据的时，对于GC可能存在较大影响。</p></li><li><p>两者的实现队列添加或移除的锁不一样，ArrayBlockingQueue实现的队列中的锁是没有分离的，即添加操作和移除操作采用的同一个ReenterLock锁，而LinkedBlockingQueue实现的队列中的锁是分离的，其添加采用的是putLock，移除采用的则是takeLock，这样能大大提高队列的吞吐量，也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p></li></ul>]]></content>
    
    <summary type="html">
    
      java阻塞队列LinkedBlockingQueue与ArrayBlockingQueue
    
    </summary>
    
      <category term="java" scheme="http://langonggong.com/categories/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://langonggong.com/tags/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>synchronized</title>
    <link href="http://langonggong.com/2018/09/23/synchronized/"/>
    <id>http://langonggong.com/2018/09/23/synchronized/</id>
    <published>2018-09-23T07:59:04.000Z</published>
    <updated>2020-06-22T16:40:36.961Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><p><img src="/images/java-object2.png"></p><ul><li>对象头<br>标记字（32位虚拟机4B，64位虚拟机8B） + 类型指针（32位虚拟机4B，64位虚拟机8B）+ [数组长（对于数组对象才需要此部分信息）]。用于存储对象的元数据信息<ul><li>Mark Word：数据的长度在32位和64位虚拟机（未开启压缩指针）中分别为32bit和64bit，存储对象自身的运行时数据如哈希值等。Mark Word一般被设计为非固定的数据结构，以便存储更多的数据信息和复用自己的存储空间。</li><li>类型指针：指向它的类元数据的指针，用于判断对象属于哪个类的实例</li></ul></li><li>实例数据<br>存储的是真正有效数据，如各种字段内容，各字段的分配策略为longs/doubles、ints、shorts/chars、bytes/boolean、oops(ordinary object pointers)，相同宽度的字段总是被分配到一起，便于之后取数据。父类定义的变量会出现在子类定义的变量的前面</li><li>对齐填充<br>对于64位虚拟机来说，对象大小必须是8B的整数倍，不够的话需要占位填充。仅仅起到占位符的作用，并非必须</li></ul><h1 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h1><p>对象头信息是与对象自身定义的数据无关的额外存储成本，但是考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据，它会根据对象的状态复用自己的存储空间，也就是说，Mark Word会随着程序的运行发生变化，变化状态如下（32位虚拟机）</p><table style="text-align:center">   <tr>      <td rowspan="2">锁状态</td>      <td colspan="2">25 bit</td>      <td rowspan="2">4 bit</td>      <td>1 bit</td>      <td>2 bit</td>   </tr>   <tr>      <td>23 bit</td>      <td>2 bit</td>      <td>是否是偏向锁</td>      <td>锁标志位</td>   </tr>   <tr>      <td>无锁状态</td>      <td colspan="2">对象HashCode</td>      <td>对象分代年龄</td>      <td>0</td>      <td>01</td>   </tr>   <tr>      <td>轻量级锁</td>      <td colspan="4">指向栈中锁记录的指针</td>      <td colspan="1">00</td>   </tr>    <tr>      <td>偏向锁</td>      <td>线程ID</td>      <td> Epoch</td>      <td>对象分代年龄</td>      <td>1</td>      <td>01</td>   </tr>   <tr>      <td>重量级锁</td>      <td colspan="4">指向互斥量（重量级锁）的指针</td>      <td colspan="1">10</td>   </tr>   <tr>      <td>GC标记</td>      <td colspan="4">空</td>      <td colspan="1">11</td>   </tr></table><h1 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h1><p>重量级锁也就是通常说synchronized的对象锁，锁标识位为10，其中指针指向的是monitor对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">//记录个数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL; <span class="comment">//指向持有ObjectMonitor对象的线程</span></span><br><span class="line">    _WaitSet      = NULL; <span class="comment">//处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表( 每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSe t集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示</p><p><img src="/images/monitor2.png"></p><h1 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncCodeBlock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//同步代码库</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译上述代码并使用javap反编译后得到字节码如下</p><p><img src="/images/sync-code-block-monitor.png"></p><p>从字节码中可知同步语句块的实现使用的是monitorenter 和 monitorexit 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置，当执行monitorenter指令时，当前线程将试图获取 objectref(即对象锁) 所对应的 monitor 的持有权，当 objectref 的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。如果当前线程已经拥有 objectref 的 monitor 的持有权，那它可以重入这个 monitor (关于重入性稍后会分析)，重入时计数器的值也会加 1。倘若其他线程已经拥有 objectref 的 monitor 的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放 monitor(锁)并设置计数器值为0 ，其他线程将有机会持有 monitor 。值得注意的是编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。从字节码中也可以看出多了一个monitorexit指令，它就是异常结束时被执行的释放monitor 的指令</p><p>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。如果一个同步方法执行期间抛 出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用javap反编译后的字节码如下</p><p><img src="/images/sync-method-monitor.png"></p><h1 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h1><p>锁可以升级但不能降级，目的是为了提高获得锁和释放锁的效率<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">无锁</span> <span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">偏向锁</span> <span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">轻量级</span> <span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">重量级</span></span><br></pre></td></tr></table></figure></p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>引入背景：大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁，减少不必要的CAS操作。</p><p>加锁：当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程（此时会引发竞争，偏向锁会升级为轻量级锁）。</p><p>膨胀过程：当前线程执行CAS获取偏向锁失败（这一步是偏向锁的关键），表示在该锁对象上存在竞争并且这个时候另外一个线程获得偏向锁所有权。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，并从偏向锁所有者的私有Monitor Record列表中获取一个空闲的记录，并将Object设置LightWeight Lock状态并且Mark Word中的LockRecord指向刚才持有偏向锁线程的Monitor record，最后被阻塞在安全点的线程被释放，进入到轻量级锁的执行路径中，同时被撤销偏向锁的线程继续往下执行同步代码。</p><p><img src="/images/BiasedLockingExpand.png"></p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>引入背景：这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态（即单线程执行环境），在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒</p><p>加锁：<br>（1）当对象处于无锁状态时（RecordWord值为HashCode，状态位为001），线程首先从自己的可用moniter record列表中取得一个空闲的moniter record，初始Nest和Owner值分别被预先设置为1和该线程自己的标识，一旦monitor record准备好然后我们通过CAS原子指令安装该monitor record的起始地址到对象头的LockWord字段，如果存在其他线程竞争锁的情况而调用CAS失败，则只需要简单的回到monitorenter重新开始获取锁的过程即可。</p><p>（2）对象已经被膨胀同时Owner中保存的线程标识为获取锁的线程自己，这就是重入（reentrant）锁的情况，只需要简单的将Nest加1即可。不需要任何原子操作，效率非常高。</p><p>（3）对象已膨胀但Owner的值为NULL，当一个锁上存在阻塞或等待的线程同时锁的前一个拥有者刚释放锁时会出现这种状态，此时多个线程通过CAS原子指令在多线程竞争状态下试图将Owner设置为自己的标识来获得锁，竞争失败的线程在则会进入到第四种情况（4）的执行路径。</p><p>（4）对象处于膨胀状态同时Owner不为NULL(被锁住)，在调用操作系统的重量级的互斥锁之前先自旋一定的次数，当达到一定的次数时如果仍然没有成功获得锁，则开始准备进入阻塞状态，首先将rfThis的值原子性的加1，由于在加1的过程中可能会被其他线程破坏Object和monitor record之间的关联，所以在原子性加1后需要再进行一次比较以确保LockWord的值没有被改变，当发现被改变后则要重新monitorenter过程。同时再一次观察Owner是否为NULL，如果是则调用CAS参与竞争锁，锁竞争失败则进入到阻塞状态。</p><p><img src="/images/synchronizedExpand.png"></p><h1 id="不同锁的比较"><a href="#不同锁的比较" class="headerlink" title="不同锁的比较"></a>不同锁的比较</h1><div class="table-container"><table><thead><tr><th style="text-align:center">锁</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th><th style="text-align:center">适用场景</th></tr></thead><tbody><tr><td style="text-align:center">偏向锁</td><td style="text-align:center">加锁和解锁不需要额外的消耗，和执行非同步方法仅存在纳秒级差别</td><td style="text-align:center">如果线程间存在竞争，会带来额外的锁撤销的消耗</td><td style="text-align:center">适用于只有一个线程访问同步块的场景</td></tr><tr><td style="text-align:center">轻量级锁</td><td style="text-align:center">竞争的线程不会阻塞，提高响应速度</td><td style="text-align:center">始终得不到锁的竞争线程自旋消耗CPU</td><td style="text-align:center">追求响应时间，同步代码块执行较快</td></tr><tr><td style="text-align:center">重量级锁</td><td style="text-align:center">线程竞争不使用自旋，不消耗CPU</td><td style="text-align:center">线程阻塞，响应时间慢</td><td style="text-align:center">追求吞吐量，同步块执行比较慢</td></tr></tbody></table></div><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p><a href="https://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="noopener">深入理解Java并发之synchronized实现原理</a><br><a href="https://blog.csdn.net/u012465296/article/details/53022317" target="_blank" rel="noopener">Java中synchronized的实现原理与应用</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      synchronized原理详解
    
    </summary>
    
      <category term="java" scheme="http://langonggong.com/categories/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://langonggong.com/tags/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>condition</title>
    <link href="http://langonggong.com/2018/09/22/condition/"/>
    <id>http://langonggong.com/2018/09/22/condition/</id>
    <published>2018-09-22T01:14:04.000Z</published>
    <updated>2020-06-22T16:40:36.957Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在java中，对于任意一个java对象，它都拥有一组定义在java.lang.Object上监视器方法，包括wait()，wait(long timeout)，notify()，notifyAll()，这些方法配合synchronized关键字一起使用可以实现等待/通知模式。</p><p>同样，Condition接口也提供了类似Object监视器的方法，通过与Lock配合来实现等待/通知模式</p><div class="table-container"><table><thead><tr><th style="text-align:center">对比项</th><th style="text-align:center">Object监视器</th><th style="text-align:center">Condition</th></tr></thead><tbody><tr><td style="text-align:center">前置条件</td><td style="text-align:center">获取对象的锁</td><td style="text-align:center">调用Lock.lock获取锁，调用Lock.newCondition获取Condition对象</td></tr><tr><td style="text-align:center">调用方式</td><td style="text-align:center">直接调用，比如object.notify()</td><td style="text-align:center">直接调用，比如condition.await()</td></tr><tr><td style="text-align:center">等待队列的个数</td><td style="text-align:center">一个</td><td style="text-align:center">多个</td></tr><tr><td style="text-align:center">当前线程释放锁进入等待状态</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">当前线程释放锁进入等待状态，在等待状态中不断响中断</td><td style="text-align:center">不支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">当前线程释放锁并进入超时等待状态</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">当前线程释放锁并进入等待状态直到将来的某个时间</td><td style="text-align:center">不支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">唤醒等待队列中的一个线程</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">唤醒等待队列中的全部线程</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr></tbody></table></div><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>实现一个简单的有界队列，队列为空时，队列的删除操作将会阻塞直到队列中有新的元素，队列已满时，队列的插入操作将会阻塞直到队列出现空位</p><p><img src="/images/condition-queue.png"></p><h1 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 使当前线程进入等待状态直到被通知(signal)或中断</span></span><br><span class="line"><span class="comment">  * 当其他线程调用singal()或singalAll()方法时，该线程将被唤醒</span></span><br><span class="line"><span class="comment">  * 当其他线程调用interrupt()方法中断当前线程</span></span><br><span class="line"><span class="comment">  * await()相当于synchronized等待唤醒机制中的wait()方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//当前线程进入等待状态，直到被唤醒，该方法不响应中断要求</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//调用该方法，当前线程进入等待状态，直到被唤醒或被中断或超时</span></span><br><span class="line"> <span class="comment">//其中nanosTimeout指的等待超时时间，单位纳秒</span></span><br><span class="line"> <span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//同awaitNanos，但可以指明时间单位</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//调用该方法当前线程进入等待状态，直到被唤醒、中断或到达某个时</span></span><br><span class="line"> <span class="comment">//间期限(deadline),如果没到指定时间就被唤醒，返回true，其他情况返回false</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//唤醒一个等待在Condition上的线程，该线程从等待方法返回前必须</span></span><br><span class="line"> <span class="comment">//获取与Condition相关联的锁，功能与notify()相同</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//唤醒所有等待在Condition上的线程，该线程从等待方法返回前必须</span></span><br><span class="line"> <span class="comment">//获取与Condition相关联的锁，功能与notifyAll()相同</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>Condition的具体实现类是AQS的内部类ConditionObject。AQS中存在两种队列，一种是同步队列，一种是等待队列，而等待队列就相对于Condition而言的。注意在使用Condition前必须获得锁，同时在Condition的等待队列上的结点与前面同步队列的结点是同一个类即Node，其结点的waitStatus的值为CONDITION。在实现类ConditionObject中有两个结点分别是firstWaiter和lastWaiter，firstWaiter代表等待队列第一个等待结点，lastWaiter代表等待队列最后一个等待结点，如下</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> &#123;</span></span><br><span class="line">    <span class="comment">//等待队列第一个等待结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="comment">//等待队列最后一个等待结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">    <span class="comment">//省略其他代码.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个Condition都对应着一个等待队列，也就是说如果一个锁上创建了多个Condition对象，那么也就存在多个等待队列。等待队列是一个FIFO的队列，在队列中每一个节点都包含了一个线程的引用，而该线程就是Condition对象上等待的线程。当一个线程调用了await()相关的方法，那么该线程将会释放锁，并构建一个Node节点封装当前线程的相关信息加入到等待队列中进行等待，直到被唤醒、中断、超时才从队列中移出</p><h2 id="await-实现"><a href="#await-实现" class="headerlink" title="await()实现"></a>await()实现</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="comment">//判断线程是否被中断</span></span><br><span class="line">  <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">  <span class="comment">//创建新结点加入等待队列并返回</span></span><br><span class="line">  Node node = addConditionWaiter();</span><br><span class="line">  <span class="comment">//释放当前线程锁即释放同步状态</span></span><br><span class="line">  <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">  <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//判断结点是否同步队列(SyncQueue)中,即是否被唤醒</span></span><br><span class="line">  <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    <span class="comment">//挂起线程</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//判断是否被中断唤醒，如果是退出循环。</span></span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//被唤醒后执行自旋操作争取获得锁，同时判断线程是否被中断</span></span><br><span class="line">  <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">    interruptMode = REINTERRUPT;</span><br><span class="line">  <span class="comment">// clean up if cancelled</span></span><br><span class="line">  <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">//清理等待队列中不为CONDITION状态的结点</span></span><br><span class="line">    unlinkCancelledWaiters();</span><br><span class="line">  <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">    reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//添加到等待队列</span><br><span class="line">private <span class="keyword">Node</span> <span class="title">addConditionWaiter</span>() &#123;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">t</span> = lastWaiter;</span><br><span class="line">  // 判断是否为结束状态的结点并移除</span><br><span class="line">  if (t != null &amp;&amp; t.waitStatus != <span class="keyword">Node</span>.<span class="title">CONDITION</span>) &#123;</span><br><span class="line">    unlinkCancelledWaiters();</span><br><span class="line">    t = lastWaiter;</span><br><span class="line">  &#125;</span><br><span class="line">  //创建新结点状态为CONDITION</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">node</span> = new <span class="keyword">Node</span><span class="title">(Thread</span>.currentThread(), <span class="keyword">Node</span>.<span class="title">CONDITION</span>);</span><br><span class="line">  //加入等待队列</span><br><span class="line">  if (t == null) &#123;</span><br><span class="line">    firstWaiter = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">  &#125; else</span> &#123;</span><br><span class="line">    t.nextWaiter = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">  &#125;</span></span><br><span class="line"><span class="title">  lastWaiter</span> = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">  return</span> <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>调用addConditionWaiter()方法将当前线程封装成node结点加入等待队列</li><li>调用fullyRelease(node)方法释放同步状态并唤醒同步队列后继结点的线程</li><li>调用isOnSyncQueue(node)方法判断结点是否在同步队列中，注意是个while循环，如果同步队列中没有该结点就直接挂起该线程，如果线程被唤醒后就调用acquireQueued(node, savedState)执行自旋操作争取锁，即当前线程结点从等待队列转移到同步队列并开始努力获取锁</li></ul><p><img src="/images/condition-await.png"></p><h2 id="signal-实现"><a href="#signal-实现" class="headerlink" title="signal()实现"></a>signal()实现</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//判断是否持有独占锁，如果不是抛出异常</span></span><br><span class="line">  <span class="comment">//只有独占模式采用等待队列，而共享模式下是没有等待队列的，也就没法使用Condition</span></span><br><span class="line">  <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">  Node first = firstWaiter;</span><br><span class="line">  <span class="comment">//唤醒等待队列第一个结点的线程</span></span><br><span class="line">  <span class="keyword">if</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">    doSignal(first);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void doSignal(Node <span class="built_in">first</span>) &#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//移除条件等待队列中的第一个结点</span></span><br><span class="line">    <span class="comment">//然后重新维护条件等待队列的firstWaiter和lastWaiter的指向</span></span><br><span class="line">    if ((firstWaiter = <span class="built_in">first</span>.nextWaiter) == <span class="built_in">null</span>) &#123;</span><br><span class="line">      lastWaiter = <span class="built_in">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">first</span>.nextWaiter = <span class="built_in">null</span>;</span><br><span class="line">    <span class="comment">//如果被通知节点没有进入到同步队列并且条件等待队列还有不为空的节点，则继续循环通知后续结点</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (!transferForSignal(<span class="built_in">first</span>) &amp;&amp; (<span class="built_in">first</span> = firstWaiter) != <span class="built_in">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">final boolean transferForSignal(<span class="keyword">Node</span> <span class="title">node</span>) &#123;</span><br><span class="line">  //尝试设置唤醒结点的waitStatus为<span class="number">0</span>，即初始化状态</span><br><span class="line">  //如果设置失败，说明当前结点<span class="keyword">node</span><span class="title">的waitStatus</span>已不为</span><br><span class="line">  //CONDITION状态，那么只能是结束状态了，因此返回<span class="literal">false</span></span><br><span class="line">  //返回doSignal()方法中继续唤醒其他结点的线程，注意这里并</span><br><span class="line">  //不涉及并发问题，所以CAS操作失败只可能是预期值不为CONDITION，</span><br><span class="line">  //而不是多线程设置导致预期值变化，毕竟操作该方法的线程是持有锁的。</span><br><span class="line">  if (!compareAndSetWaitStatus(<span class="keyword">node</span><span class="title">, Node</span>.CONDITION, <span class="number">0</span>))</span><br><span class="line">    return <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  //加入同步队列并返回前驱结点p</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">p</span> = enq(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">  int</span> ws = p.waitStatus;</span><br><span class="line">  //判断前驱结点是否为结束结点(<span class="attr">CANCELLED=</span><span class="number">1</span>)或者在设置</span><br><span class="line">  //前驱节点状态为<span class="keyword">Node</span>.<span class="title">SIGNAL</span>状态失败时，唤醒被通知节点代表的线程</span><br><span class="line">  if (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, <span class="keyword">Node</span>.<span class="title">SIGNAL</span>))</span><br><span class="line">    //唤醒<span class="keyword">node</span><span class="title">结点的线程</span></span><br><span class="line"><span class="title">    LockSupport</span>.unpark(<span class="keyword">node</span>.<span class="title">thread</span>);</span><br><span class="line">  return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被唤醒后的线程，将从前面的await()方法中的while循环中退出，因为此时该线程的结点已在同步队列中，那么while (!isOnSyncQueue(node))将不在符合循环条件，进而调用AQS的acquireQueued()方法加入获取同步状态的竞争中，这就是等待唤醒机制的整个流程实现原理<br><img src="/images/condition-signal.png"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p><a href="https://blog.csdn.net/javazejian/article/details/75043422" target="_blank" rel="noopener">深入剖析基于并发AQS的(独占锁)重入锁(ReetrantLock)及其Condition实现原理</a><br><a href="https://www.jianshu.com/p/be2dc7c878dc" target="_blank" rel="noopener">java并发编程之Condition</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      condition原理详解
    
    </summary>
    
      <category term="java" scheme="http://langonggong.com/categories/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://langonggong.com/tags/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口算法</title>
    <link href="http://langonggong.com/2018/09/19/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/"/>
    <id>http://langonggong.com/2018/09/19/滑动窗口算法/</id>
    <published>2018-09-19T14:56:15.000Z</published>
    <updated>2020-06-22T16:40:36.965Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>题目描述</p><blockquote><p>有一个整型数组 arr 和一个大小为 w 的窗口从数组的最左边滑到最右边,窗口每次向右边滑一个位置。 返回一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值。 以数组为[4,3,5,4,3,3,6,7]，w=3为例。因为第一个窗口[4,3,5]的最大值为5，第二个窗口[3,5,4]的最大值为5，第三个窗口[5,4,3]的最大值为5。第四个窗口[4,3,3]的最大值为4。第五个窗口[3,3,6]的最大值为6。第六个窗口[3,6,7]的最大值为7。所以最终返回[5,5,5,4,6,7]。</p><p>给定整形数组arr及它的大小n，同时给定w，请返回res数组。保证w小于等于n，同时保证数组大小小于等于500。</p></blockquote><p>解题思路</p><blockquote><p>使用一个长度为w的双端队列，存储数组的索引。每次有新元素加入，将小于或等于改元素的值的原有元素对应的索引删掉，将不在该窗口范围的索引删掉。队列的索引对应的元素值倒序排序。则队列的第一个元素始终为该窗口内最大值的索引</p></blockquote><p>参考代码<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlideWindow</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] slide(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> w) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || arr.length &lt; w) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedList&lt;Integer&gt; <span class="keyword">list</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length - w + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="comment">//把较小的值挤掉，按照从大到小排序</span></span><br><span class="line">      <span class="keyword">while</span> (!<span class="keyword">list</span>.isEmpty() &amp;&amp; arr[<span class="keyword">list</span>.peekLast()] &lt;= arr[i]) &#123;</span><br><span class="line">        <span class="keyword">list</span>.pollLast();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">list</span>.addLast(i);</span><br><span class="line">      <span class="comment">//不在窗口里面的元素删掉</span></span><br><span class="line">      <span class="keyword">if</span> (i - <span class="keyword">list</span>.peekFirst() == w) &#123;</span><br><span class="line">        <span class="keyword">list</span>.pollFirst();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= w) &#123;</span><br><span class="line">        result[index++] = arr[<span class="keyword">list</span>.peekFirst()];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      滑动窗口算法
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="队列" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="队列" scheme="http://langonggong.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>小范围排序</title>
    <link href="http://langonggong.com/2018/09/07/%E5%B0%8F%E8%8C%83%E5%9B%B4%E6%8E%92%E5%BA%8F/"/>
    <id>http://langonggong.com/2018/09/07/小范围排序/</id>
    <published>2018-09-06T17:04:14.000Z</published>
    <updated>2020-06-22T16:40:36.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>题目描述</p><blockquote><p>已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序</p></blockquote><p>解题思路</p><blockquote><p>使用变种的堆排序：维护一个长度为k的最小根堆，将数组的元素不断的加入堆中，调整后将堆顶弹出赋给数组，将排序的范围始终限制在长度为k、近乎排序的堆中</p></blockquote><p>参考代码<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class ScaleSort &#123;</span><br><span class="line">  public <span class="type">int</span>[] sortElement(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == null || arr.<span class="built_in">length</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建长度为k的小根堆，此过程也可以在heap数组中进行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = k / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      headAdjust(arr, i, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将调整好的最小根堆赋值给heap数组</span></span><br><span class="line">    <span class="type">int</span>[] heap = new <span class="type">int</span>[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">      heap[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//每从最小跟堆中弹出堆顶给数组，就从数组中弹出一个元素给堆，再次调整为最小跟堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; arr.<span class="built_in">length</span>; i++) &#123;</span><br><span class="line">      arr[i - k] = heap[<span class="number">0</span>];</span><br><span class="line">      heap[<span class="number">0</span>] = arr[i];</span><br><span class="line">      headAdjust(heap, <span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最小根堆不能保证左右节点之间的大小顺序，所以不能直接将heap完整复制给arr</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = arr.<span class="built_in">length</span> - k; i &lt; arr.<span class="built_in">length</span>; i++) &#123;</span><br><span class="line">      arr[i] = heap[<span class="number">0</span>];</span><br><span class="line">      <span class="comment">//由于堆中没有新的元素加入，只能每次将堆顶放到后面，对前面一部分进行堆调整</span></span><br><span class="line">      swap(heap, <span class="number">0</span>, arr.<span class="built_in">length</span> - i - <span class="number">1</span>);</span><br><span class="line">      headAdjust(heap, <span class="number">0</span>, arr.<span class="built_in">length</span> - i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//堆调整，保证[index,length)这条支线满足最小根堆</span></span><br><span class="line">  private <span class="type">void</span> headAdjust(<span class="type">int</span>[] arr, <span class="type">int</span> <span class="keyword">index</span>, <span class="type">int</span> <span class="built_in">length</span>) &#123;</span><br><span class="line">    <span class="type">int</span> minIndex, left, right;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">index</span> &lt; <span class="built_in">length</span>) &#123;</span><br><span class="line">      minIndex = <span class="keyword">index</span>;</span><br><span class="line">      left = <span class="number">2</span> * <span class="keyword">index</span> + <span class="number">1</span>;</span><br><span class="line">      right = <span class="number">2</span> * <span class="keyword">index</span> + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (left &lt; <span class="built_in">length</span> &amp;&amp; arr[left] &lt; arr[minIndex]) &#123;</span><br><span class="line">        minIndex = left;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (right &lt; <span class="built_in">length</span> &amp;&amp; arr[right] &lt; arr[minIndex]) &#123;</span><br><span class="line">        minIndex = right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//临界条件，表示无需再调整</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">index</span> == minIndex) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(arr, <span class="keyword">index</span>, minIndex);</span><br><span class="line">      <span class="keyword">index</span> = minIndex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static <span class="type">void</span> swap(<span class="type">int</span>[] arr, <span class="type">int</span> index1, <span class="type">int</span> index2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index1 == index2) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tmp = arr[index1];</span><br><span class="line">    arr[index1] = arr[index2];</span><br><span class="line">    arr[index2] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      几乎有序的数组进行排序
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>DNS解析</title>
    <link href="http://langonggong.com/2018/09/06/DNS%E8%A7%A3%E6%9E%90/"/>
    <id>http://langonggong.com/2018/09/06/DNS解析/</id>
    <published>2018-09-06T08:46:42.000Z</published>
    <updated>2020-06-22T16:40:36.954Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>nslookup<br><img src="/images/nslook-baidu.png"></p><p>第一行Server是：DNS服务器的主机名—10.4.1.14<br>第二行Address是：它的IP地址—10.4.1.14#53</p><p>百度有一个cname = www.a.shifen.com的别名</p><p>下面的Name是：解析的URL—www.a.shifen.com<br>Address是：解析出来的IP—220.181.112.244和220.181.111.188</p><p>dig www.baidu.com +trace<br><img src="/images/dig-baidu.jpg">    </p><p>Dig工具会在本地计算机做迭代，然后记录查询的过程</p><ul><li>第一步，向我这台机器的ISPDNS获取到根域服务区的13个IP和主机名[b-j].root-servers.net.</li><li>第二步，向其中的一台根域服务器（m.root-servers.net）发送www.baidu.com的查询请求，他返回了com.顶级域的服务器名称</li><li>第三步，向com.域的一台服务器i.gtld-servers.net请求,www.baidu.com，他返回了baidu.com域的服务器IP（未显示）和名称，百度有5台顶级域的服务器</li><li>第四步，向百度的顶级域服务器（202.108.22.220）请求www.baidu.com，他发现这个www有个别名，而不是一台主机，别名是www.a.shifen.com</li></ul><p>当dns请求到别名的时候，查询不会终止，而是重新发起查询别名的请求，此处返回的是www.a.shifen.com，然后继续请求</p><p>使用dig www.a.shifen.com +trace查看<br><img src="/images/dig-shifen.jpg">    </p><p>再一次去请求com域，重复上面的步骤，最终从ns X.a.shifen.com中一台拿到了一条A记录，便是www.baidu.com的IP地址了</p>]]></content>
    
    <summary type="html">
    
      DNS解析
    
    </summary>
    
      <category term="计算机网络" scheme="http://langonggong.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://langonggong.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="DNS" scheme="http://langonggong.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>基数排序</title>
    <link href="http://langonggong.com/2018/09/05/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://langonggong.com/2018/09/05/基数排序/</id>
    <published>2018-09-05T15:41:05.000Z</published>
    <updated>2020-06-22T16:40:36.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>1、构造从0到9的10个桶，将数组的每个元素按照个位数的大小放入对应的桶中<br>2、构造新的10个桶，将原桶中的数字依次弹出，按照十位数的大小依次放入对应的新桶中<br>3、对百位、千位等按照上述步骤处理</p><p>需考虑负数</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RadixSort</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">radixSort</span>(<span class="params"><span class="keyword">int</span>[] arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> posNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        posNum++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] posArr = <span class="keyword">new</span> <span class="keyword">int</span>[posNum];</span><br><span class="line">    <span class="keyword">int</span>[] negArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length - posNum];</span><br><span class="line">    <span class="keyword">int</span> posIndex = <span class="number">0</span>, negIndex = <span class="number">0</span>, posMax = <span class="number">0</span>, negMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        posArr[posIndex++] = i;</span><br><span class="line">        posMax = Math.max(posMax, i);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> j = -i;</span><br><span class="line">        negArr[negIndex++] = j;</span><br><span class="line">        negMax = Math.max(j, negMax);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    radixSortForPositive(posArr, posMax);</span><br><span class="line">    radixSortForPositive(negArr, negMax);</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=negArr.length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">      arr[index++] = -negArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;posArr.length;i++) &#123;</span><br><span class="line">      arr[index++] = posArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//针对正数的基数排序</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSortForPositive</span>(<span class="params"><span class="keyword">int</span>[] arr, <span class="keyword">int</span> max</span>) </span>&#123;</span><br><span class="line">    List&lt;LinkedList&lt;Integer&gt;&gt; temp1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;LinkedList&lt;Integer&gt;&gt; temp2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      temp1.<span class="keyword">add</span>(<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">      temp2.<span class="keyword">add</span>(<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按照个位数的大小将元素放入桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">      temp1.<span class="keyword">get</span>(i % <span class="number">10</span>).<span class="keyword">add</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> <span class="keyword">base</span> = <span class="number">10</span>; <span class="keyword">base</span> &lt;= max; <span class="keyword">base</span> *= <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (LinkedList&lt;Integer&gt; integers : temp1) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!integers.isEmpty()) &#123;</span><br><span class="line">          Integer integer = integers.pop();</span><br><span class="line">          temp2.<span class="keyword">get</span>((integer / <span class="keyword">base</span>) % <span class="number">10</span>).<span class="keyword">add</span>(integer);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      List&lt;LinkedList&lt;Integer&gt;&gt; temp;</span><br><span class="line">      temp = temp1;</span><br><span class="line">      temp1 = temp2;</span><br><span class="line">      temp2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (LinkedList&lt;Integer&gt; integers : temp1) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Integer integer : integers) &#123;</span><br><span class="line">        arr[index++] = integer;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      按照位数从低到高依次排序
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>计数排序</title>
    <link href="http://langonggong.com/2018/09/05/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://langonggong.com/2018/09/05/计数排序/</id>
    <published>2018-09-05T15:37:25.000Z</published>
    <updated>2020-06-22T16:40:36.966Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>根据数组最大最小值构建数组，记录每个数字出现次数</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class CountingSort &#123;</span><br><span class="line"></span><br><span class="line">  public <span class="type">int</span>[] countingSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == null || arr.<span class="built_in">length</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">min</span> = arr[<span class="number">0</span>], <span class="built_in">max</span> = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.<span class="built_in">length</span>;i++) &#123;</span><br><span class="line">      <span class="built_in">min</span> = Math.<span class="built_in">min</span>(<span class="built_in">min</span>, arr[i]);</span><br><span class="line">      <span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] store = new <span class="type">int</span>[<span class="built_in">max</span> - <span class="built_in">min</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;arr.<span class="built_in">length</span>;j++) &#123;</span><br><span class="line">      store[arr[j] - <span class="built_in">min</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;store.<span class="built_in">length</span>;k++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (store[k]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        arr[<span class="keyword">index</span>++] = k + <span class="built_in">min</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      根据数组最大最小值构建数组，记录每个数字出现次数
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>希尔排序</title>
    <link href="http://langonggong.com/2018/09/05/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>http://langonggong.com/2018/09/05/希尔排序/</id>
    <published>2018-09-05T15:00:26.000Z</published>
    <updated>2020-06-22T16:40:36.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>令k=2<br>1、将数组分成k等分，构建length/2个间隔为k的数组，对每个数组进行插入排序<br>2、k=k*2,重复步骤1</p><p>插入排序:假设前面的数组已经有序，则找到改点合适的位置插入(该点下沉到合适的位置)</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] shellSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = arr.length ;</span><br><span class="line">    <span class="comment">//将数组2等分，4等分...直到一等分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = length &gt;&gt; <span class="number">1</span>; gap &gt; <span class="number">0</span>; gap &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">//对生成的多个数组进行插入排序</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> start = gap; start &lt; arr.length; start++) &#123;</span><br><span class="line">        <span class="comment">//对单个数组进行插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> <span class="keyword">index</span> = start; <span class="keyword">index</span> &gt;= gap; <span class="keyword">index</span> -= gap) &#123;</span><br><span class="line">          <span class="keyword">if</span> (arr[<span class="keyword">index</span> - gap] &gt; arr[<span class="keyword">index</span>]) &#123;</span><br><span class="line">            swap(arr, <span class="keyword">index</span> - gap, <span class="keyword">index</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> swap(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index1 == index2) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[index1];</span><br><span class="line">    arr[index1] = arr[index2];</span><br><span class="line">    arr[index2] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      直接插入排序的优化
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="http://langonggong.com/2018/09/05/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://langonggong.com/2018/09/05/堆排序/</id>
    <published>2018-09-04T16:28:14.000Z</published>
    <updated>2020-07-09T11:08:45.600Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>1、构建大根堆，满足父大于子，堆顶为最大值<br>2、将堆顶与最后一位进行替换，将前n-1位调整为大根堆<br>3、对前n-1位大根堆重复过程2</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class HeapSort &#123;</span><br><span class="line"></span><br><span class="line">  public <span class="type">int</span>[] heapSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == null || arr.<span class="built_in">length</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建大根堆，使整棵树满足:父&gt;子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = arr.<span class="built_in">length</span> / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="comment">//每次调整，都要保证将后面所有的都调整一遍</span></span><br><span class="line">      headAdjust(arr, i, arr.<span class="built_in">length</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将堆顶（最大值）替换到第j个点，然后将前面j-1个点调整为大根堆，</span></span><br><span class="line">    <span class="comment">//对前j-1个点重复此过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=arr.<span class="built_in">length</span><span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">      swap(arr, <span class="number">0</span>, j);</span><br><span class="line">      headAdjust(arr, <span class="number">0</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//不能保证[index,length)是大顶堆，只能尽量把大的点网上冒</span></span><br><span class="line">  private <span class="type">void</span> headAdjust(<span class="type">int</span>[] arr, <span class="type">int</span> <span class="keyword">index</span>,<span class="type">int</span> <span class="built_in">length</span>) &#123;</span><br><span class="line">  <span class="comment">//如果父节点与左右子节点进行交换，发生交换的子节点所在的堆可能不满足大顶堆，例如[2,10,null,4,5]-&gt;[10,2,null,4,5]</span></span><br><span class="line">  <span class="comment">//所以需要往底部继续遍历处理</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">index</span> &lt; <span class="built_in">length</span>) &#123;</span><br><span class="line">      <span class="type">int</span> left = <span class="number">2</span> * <span class="keyword">index</span> + <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> right = <span class="number">2</span> * <span class="keyword">index</span> + <span class="number">2</span>;</span><br><span class="line">      <span class="type">int</span> <span class="built_in">max</span> = <span class="keyword">index</span>;</span><br><span class="line">      <span class="keyword">if</span> (left &lt; <span class="built_in">length</span> &amp;&amp; arr[left] &gt; arr[<span class="keyword">index</span>]) &#123;</span><br><span class="line">        <span class="built_in">max</span> = left;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (right &lt; <span class="built_in">length</span> &amp;&amp; arr[right] &gt; arr[<span class="built_in">max</span>]) &#123;</span><br><span class="line">        <span class="built_in">max</span> = right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">index</span> == <span class="built_in">max</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(arr, <span class="keyword">index</span>, <span class="built_in">max</span>);</span><br><span class="line">      <span class="keyword">index</span> = <span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static <span class="type">void</span> swap(<span class="type">int</span>[] arr, <span class="type">int</span> index1, <span class="type">int</span> index2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index1 == index2) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tmp = arr[index1];</span><br><span class="line">    arr[index1] = arr[index2];</span><br><span class="line">    arr[index2] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      将数组作为堆结构进行处理
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://langonggong.com/2018/09/03/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://langonggong.com/2018/09/03/快速排序/</id>
    <published>2018-09-03T15:56:00.000Z</published>
    <updated>2020-06-22T16:40:36.964Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>选择任意一点，将元素划分为小于该值和大于该值的左右两部分，递归次过程</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> int[] <span class="built_in">quickSort</span>(int[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == null || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> void process(int[] arr, int <span class="keyword">left</span>, int <span class="keyword">right</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">left</span> &gt;= <span class="keyword">right</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    int random = <span class="keyword">left</span> + (int) <span class="type">Math</span>.random() * (<span class="keyword">right</span> - <span class="keyword">left</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">swap</span>(arr, random, <span class="keyword">right</span>);</span><br><span class="line">    int <span class="built_in">partition</span> = <span class="built_in">partition</span>(arr, <span class="keyword">left</span>, <span class="keyword">right</span>);</span><br><span class="line">    process(arr, <span class="keyword">left</span>, <span class="built_in">partition</span> - <span class="number">1</span>);</span><br><span class="line">    process(arr, <span class="built_in">partition</span> + <span class="number">1</span>, <span class="keyword">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将小于或等于right的元素替换到左边，大于right的元素保持不动</span></span><br><span class="line"><span class="comment">   * partition加一递增，指向最近一个被替换到左边的位置</span></span><br><span class="line"><span class="comment">   * 当数组遍历完，right处的元素被替换到partition所指的位置</span></span><br><span class="line"><span class="comment">   * partition左边的值全部小于或等于该值，右边的值全部大于该值</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> int <span class="built_in">partition</span>(int[] arr, int <span class="keyword">left</span>, int <span class="keyword">right</span>) &#123;</span><br><span class="line">    int <span class="built_in">partition</span> = <span class="keyword">left</span> - <span class="number">1</span>;</span><br><span class="line">    int index = <span class="keyword">left</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt;= <span class="keyword">right</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[index] &lt;= arr[<span class="keyword">right</span>]) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr, ++<span class="built_in">partition</span>, index);</span><br><span class="line">      &#125;</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">partition</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> void <span class="built_in">swap</span>(int[] arr, int index1, int index2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index1 == index2) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    int tmp = arr[index1];</span><br><span class="line">    arr[index1] = arr[index2];</span><br><span class="line">    arr[index2] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      选择任意一点，将元素划分为小于该值和大于该值的左右两部分，递归次过程
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="http://langonggong.com/2018/09/03/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://langonggong.com/2018/09/03/归并排序/</id>
    <published>2018-09-03T13:24:32.000Z</published>
    <updated>2020-07-09T08:25:14.117Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><p>二分后递归调用自身，然后对这两部分处理后的结果进行排序<br>时间复杂度：\(O (nlog_2 n)\)</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> MergeSort &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">int</span>[] mergeSort(<span class="built_in">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    divide(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    return arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> void divide(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">left</span> &gt;= <span class="built_in">right</span>) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>) / <span class="number">2</span>;</span><br><span class="line">    divide(arr, <span class="built_in">left</span>, <span class="built_in">mid</span>);</span><br><span class="line">    divide(arr, <span class="built_in">mid</span> + <span class="number">1</span>, <span class="built_in">right</span>);</span><br><span class="line">    merge(arr, <span class="built_in">left</span>, <span class="built_in">mid</span>, <span class="built_in">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> void merge(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">mid</span>, <span class="built_in">int</span> <span class="built_in">right</span>) &#123;</span><br><span class="line">    <span class="built_in">int</span>[] result = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="built_in">right</span> - <span class="built_in">left</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">int</span> i = <span class="built_in">left</span>, j = <span class="built_in">mid</span> + <span class="number">1</span>, index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= <span class="built_in">mid</span> &amp;&amp; j &lt;= <span class="built_in">right</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">        result[index++] = arr[i++];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result[index++] = arr[j++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= <span class="built_in">mid</span>) &#123;</span><br><span class="line">      result[index++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= <span class="built_in">right</span>) &#123;</span><br><span class="line">      result[index++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> k=<span class="number">0</span>;k&lt;result.length;k++) &#123;</span><br><span class="line">      arr[<span class="built_in">left</span> + k] = result[k];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度推导</p><p>如果假设一个序列有n个数的排序时间为T(n)，T(n)是一个关于n的函数，随着n的变化而变化。那么我们将n个数的序列，分为两个(n/2)的序列，那么</p><script type="math/tex; mode=display">T(n)=2*T(n/2)+合并时间</script><p>由于合并时，两个子序列已经组内排好序了，那我们将两个排好序的序列组合成一个大的有序序列，只需要一个if循环即可。if循环中有n个数需要比较，所以时间复杂度为n。那么</p><script type="math/tex; mode=display">T(n)=2*T(n/2)+n</script><p>将T(n/2)带入到T(n)中，\(T(n)=2*(2*T(n/4)+n/2)+n\) ，通过化简得到</p><script type="math/tex; mode=display">T(n)=4*T(n/4)+2n</script><p>将T(n/4)带入到黄色公式中，\(T(n)=4*(2*T(n/8)+n/4)+2n\),通过化简得到</p><script type="math/tex; mode=display">T(n)=8*T(n/8)+3n</script><p>最终可得</p><script type="math/tex; mode=display">T(n)=n*T(1)+(log_2n)*n</script><p>T(1)=0，那么</p><script type="math/tex; mode=display">T(n)=(log_2n)*n</script>]]></content>
    
    <summary type="html">
    
      二分后递归调用自身，然后对这两部分处理后的结果进行排序
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>插入排序</title>
    <link href="http://langonggong.com/2018/09/02/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://langonggong.com/2018/09/02/插入排序/</id>
    <published>2018-09-02T15:10:00.000Z</published>
    <updated>2020-06-22T16:40:36.964Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>假设前面的数组已经有序，则找到改点合适的位置插入(该点下沉到合适的位置)</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InsertionSort</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">insertionSort</span>(<span class="params"><span class="keyword">int</span>[] arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> j = i;</span><br><span class="line">      <span class="keyword">while</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">          swap(arr, j, j - <span class="number">1</span>);</span><br><span class="line">          j--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span>(<span class="params"><span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      假设前面的数组已经有序，则找到改点合适的位置插入
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>选择排序</title>
    <link href="http://langonggong.com/2018/09/02/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://langonggong.com/2018/09/02/选择排序/</id>
    <published>2018-09-02T14:58:40.000Z</published>
    <updated>2020-06-22T16:40:36.967Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>选择最小值与第一个数字交换</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SelectSort</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">selectionSort</span>(<span class="params"><span class="keyword">int</span>[] arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> mini = i;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">        mini = arr[j] &lt; arr[mini] ? j : mini;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(arr, i, mini);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span>(<span class="params"><span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      选择最小值与第一个数字交换
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="http://langonggong.com/2018/09/02/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://langonggong.com/2018/09/02/冒泡排序/</id>
    <published>2018-09-02T14:49:03.000Z</published>
    <updated>2020-06-22T16:40:36.962Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>最大值上浮</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BubbleSort</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">bubbleSort</span>(<span class="params"><span class="keyword">int</span>[] arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=arr.length<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">          swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span>(<span class="params"><span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      最大值上浮
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://langonggong.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>AQS</title>
    <link href="http://langonggong.com/2018/09/01/AQS/"/>
    <id>http://langonggong.com/2018/09/01/AQS/</id>
    <published>2018-09-01T06:14:14.000Z</published>
    <updated>2020-06-22T16:40:36.953Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在JDK1.5之前，一般是靠synchronized关键字来实现线程对共享变量的互斥访问。synchronized是在字节码上加指令，依赖于底层操作系统的Mutex Lock实现。<br>AQS定义了一套多线程访问共享资源的同步器框架，是整个java.util.concurrent包的基石，Lock、ReadWriteLock、CountDowndLatch、CyclicBarrier、Semaphore、ThreadPoolExecutor等都是在AQS的基础上实现的。</p><h1 id="同步队列-CLH"><a href="#同步队列-CLH" class="headerlink" title="同步队列(CLH)"></a>同步队列(CLH)</h1><p>AQS维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）</p><p><img src="/images/AQS同步队列模型.png"></p><p>AQS的内部队列是CLH同步锁的一种变形。其主要从两方面进行了改造，节点的结构与节点等待机制</p><ul><li>在结构上引入了头结点和尾节点，分别指向队列的头和尾，尝试获取锁、入队列、释放锁等实现都与头尾节点相关</li><li>为了可以处理timeout和cancel操作，每个node维护一个指向前驱的指针。如果一个node的前驱被cancel，这个node可以前向移动使用前驱的状态字段</li><li>在每个node里面使用一个状态字段来控制阻塞/唤醒，而不是自旋</li><li>head结点使用的是傀儡结点</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span>&#123;</span></span><br><span class="line"><span class="comment">//指向同步队列队头</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指向同步的队尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步状态，在不同的子类有不同的含义</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略其他代码......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h2><p>Node结点是对每一个访问同步代码的线程的封装，从图中的Node的数据结构也可看出，其包含了需要同步的线程本身以及线程的状态，如是否被阻塞，是否等待唤醒，是否已经被取消等。每个Node结点内部关联其前继结点prev和后继结点next，这样可以方便线程释放锁后快速唤醒下一个在等待的线程，Node是AQS的内部类，其数据结构如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">//共享模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">//独占模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标识线程已处于结束状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//等待被唤醒状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//条件状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//在共享模式中使用表示获得的同步状态会被传播</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待状态,存在CANCELLED、SIGNAL、CONDITION、PROPAGATE 4种</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同步队列中前驱结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">//同步队列中后继结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">//请求锁的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="comment">//等待队列中的后继结点，这个与Condition有关</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否为共享模式</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取前驱结点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中SHARED和EXCLUSIVE常量分别代表共享模式和独占模式，所谓共享模式是一个锁允许多条线程同时操作，如Semaphore、CountDownLatch采用的就是基于AQS的共享模式实现的，而独占模式则是同一个时间段只能有一个线程对共享资源进行操作，多余的请求线程需要排队等待，如ReentranLock。变量waitStatus则表示当前被封装成Node结点的等待状态，共有4种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE</p><ul><li>CANCELLED：值为1，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node的结点，其结点的waitStatus为CANCELLED，即结束状态，进入该状态后的结点将不会再变化。</li><li>SIGNAL：值为-1，被标识为该等待唤醒状态的后继结点，当其前继结点的线程释放了同步锁或被取消，将会通知该后继结点的线程执行。说白了，就是处于唤醒状态，只要前继结点释放锁，就会通知标识为SIGNAL状态的后继结点的线程执行。</li><li>CONDITION：值为-2，与Condition相关，该标识的结点处于等待队列中，结点的线程等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。</li><li>PROPAGATE：值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态。</li><li>0状态：值为0，代表初始化状态。</li></ul><h2 id="AQS-lock-操作"><a href="#AQS-lock-操作" class="headerlink" title="AQS lock()操作"></a>AQS lock()操作</h2><p><img src="/images/AQS-lock.png"></p><h1 id="Sync与State实现"><a href="#Sync与State实现" class="headerlink" title="Sync与State实现"></a>Sync与State实现</h1><h2 id="state机制"><a href="#state机制" class="headerlink" title="state机制"></a>state机制</h2><p>volatile 变量 state;  用于同步线程之间的共享状态。通过 CAS 和 volatile 保证其原子性和可见性。<br>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步状态 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//CAS </span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this  </span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> unsafe.<span class="title">compareAndSwapInt</span><span class="params">(<span class="keyword">this</span>, stateOffset, expect, update)</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同实现类的Sync与State"><a href="#不同实现类的Sync与State" class="headerlink" title="不同实现类的Sync与State"></a>不同实现类的Sync与State</h2><p>基于AQS构建的Synchronizer包括ReentrantLock,Semaphore,CountDownLatch, ReetrantRead WriteLock,FutureTask等，这些Synchronizer实际上最基本的东西就是原子状态的获取和释放，只是条件不一样而已</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>需要记录当前线程获取原子状态的次数，如果次数为零，那么就说明这个线程放弃了锁（也有可能其他线程占据着锁从而需要等待），如果次数大于1，也就是获得了重进入的效果，而其他线程只能被park住，直到这个线程重进入锁次数变成0而释放原子状态。以下为ReetranLock的FairSync的tryAcquire实现代码解析</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公平获取锁</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//如果当前重进入数为0,说明有机会取得锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果是第一个等待者，并且设置重进入数成功，那么当前线程获得锁</span></span><br><span class="line">        <span class="keyword">if</span> (isFirst(current) &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="comment">//如果当前线程本身就持有锁，那么叠加重进入数，并且继续获得锁</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">     <span class="comment">//以上条件都不满足，那么线程进入等待队列。</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平锁和非公平锁</p><ul><li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了</li><li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面</li></ul><p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态</p><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>信号量维护了一个许可集，我们在初始化Semaphore时需要为这个许可集传入一个数量值，该数量值代表同一时间能访问共享资源的线程数量。以下为Semaphore的FairSync实现</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> tryAcquireShared(<span class="keyword">int</span> acquires) &#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="built_in">for</span> (;;) &#123;</span><br><span class="line">         Thread first = getFirstQueuedThread();</span><br><span class="line">         <span class="comment">//如果当前等待队列的第一个线程不是当前线程，那么就返回-1表示当前线程需要等待</span></span><br><span class="line">         <span class="built_in">if</span> (first != null &amp;&amp; first != current)</span><br><span class="line">              <span class="built_in">return</span> <span class="number">-1</span>;</span><br><span class="line">         <span class="comment">//如果当前队列没有等待者，或者当前线程就是等待队列第一个等待者，</span></span><br><span class="line">         <span class="comment">//那么先取得semaphore还有几个许可证，并且减去当前线程需要的许可证得到剩下的值</span></span><br><span class="line">         <span class="keyword">int</span> <span class="built_in">available</span> = getState();</span><br><span class="line">         <span class="keyword">int</span> remaining = <span class="built_in">available</span> - acquires;</span><br><span class="line">         <span class="comment">//如果remining&lt;0，那么反馈给AQS当前线程需要等待，如果remaining&gt;0，并且设置availble成功设置成剩余数，</span></span><br><span class="line">         <span class="comment">//那么返回剩余值(&gt;0)，也就告知AQS当前线程拿到许可，可以继续执行。</span></span><br><span class="line">         <span class="built_in">if</span> (remaining &lt; <span class="number">0</span> ||compareAndSetState(<span class="built_in">available</span>, remaining))</span><br><span class="line">             <span class="built_in">return</span> remaining;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>void acquire()：从此信号量获取一个许可前线程将一直阻塞</li><li>void acquire(int n)：从此信号量获取给定数目许可，在提供这些许可前一直将线程阻塞</li><li>void release()：释放一个许可，将其返回给信号量</li><li>void release(int n)：释放n个许可</li></ul><p>使用场景：一般用于控制对某组资源的访问控制</p><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p><code>闭锁</code>则要保持其状态，在这个状态到达终止态之前，所有线程都会被park住，闭锁可以设定初始值，这个值的含义就是这个闭锁需要被countDown()几次，因为每次CountDown是sync.releaseShared(1),而一开始初始值为10的话，那么这个闭锁需要被countDown()十次，才能够将这个初始值减到0，从而释放原子状态，让等待的所有线程通过</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//await时候执行，只查看当前需要countDown数量减为0了，如果为0，说明可以继续执行，</span></span><br><span class="line"><span class="comment">//否则需要park住，等待countDown次数足够，并且unpark所有等待线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> getState() == <span class="number">0</span>? <span class="number">1</span> : -1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//countDown 时候执行，如果当前countDown数量为0，说明没有线程await，</span></span><br><span class="line"><span class="comment">//直接返回false而不需要唤醒park住线程，</span></span><br><span class="line"><span class="comment">//如果不为0，得到剩下需要 countDown的数量并且compareAndSet,</span></span><br><span class="line"><span class="comment">//最终返回剩下的countDown数量是否为0,供AQS判定是否释放所有await线程。</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         <span class="keyword">int</span> c = getState();</span><br><span class="line">         <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">int</span> nextc = c<span class="number">-1</span>;</span><br><span class="line">         <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">             <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>void await()：调用await()方法的线程会被挂起，它会等待直到countDown值为0才继续执行</li><li>boolean await(long timeout, TimeUnit unit)：await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</li><li>void countDown()：将countDown值减1</li></ul><p>使用场景：多个子线程都结束后才运行主线程，并且子线程不会阻塞，例如多步计算后的汇总工作</p><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>需要记录任务的执行状态，当调用其实例的get方法时,内部类Sync会去调用AQS的acquireSharedInterruptibly()方法，而这个方法会反向调用Sync实现的tryAcquireShared()方法，即让具体实现类决定是否让当前线程继续还是park,而FutureTask的tryAcquireShared方法所做的唯一事情就是检查状态，如果是RUNNING状态那么让当前线程park。而跑任务的线程会在任务结束时调用FutureTask 实例的set方法（与等待线程持相同的实例），设定执行结果，并且通过unpark唤醒正在等待的线程，返回结果</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get时待用，只检查当前任务是否完成或者被Cancel，如果未完成并且没有被cancel，那么告诉AQS当前线程需要进入等待队列并且park住</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> ignore)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> innerIsDone()? <span class="number">1</span> : -1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//判定任务是否完成或者被Cancel</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">innerIsDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ranOrCancelled(getState()) &amp;&amp;    runner == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//get时调用，对于CANCEL与其他异常进行抛错</span></span><br><span class="line"><span class="function">V <span class="title">innerGet</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquireSharedNanos(<span class="number">0</span>,nanosTimeout))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">    <span class="keyword">if</span> (getState() == CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(exception);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//任务的执行线程执行完毕调用（set(V v)）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">innerSet</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = getState();</span><br><span class="line">        <span class="comment">//如果线程任务已经执行完毕，那么直接返回（多线程执行任务？）</span></span><br><span class="line">        <span class="keyword">if</span> (s == RAN)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果被CANCEL了，那么释放等待线程，并且会抛错</span></span><br><span class="line">        <span class="keyword">if</span> (s == CANCELLED) &#123;</span><br><span class="line">            releaseShared(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">        <span class="comment">//如果成功设定任务状态为已完成，那么设定结果，unpark等待线程(调用get()方法而阻塞的线程),以及后续清理工作（一般由FutrueTask的子类实现）</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(s, RAN)) &#123;</span><br><span class="line">            result = v;</span><br><span class="line">            releaseShared(<span class="number">0</span>);</span><br><span class="line">            done();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><p>Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否锁定状态</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试获取资源，立即返回。成功则返回true，否则false。</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// 这里限定只能为1个量</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">//state为0才设置为1，不可重入！</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//设置为当前线程独占资源</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试释放资源，立即返回。成功则为true，否则false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// 限定为1个量</span></span><br><span class="line">    <span class="keyword">if</span> (getState() == <span class="number">0</span>)<span class="comment">//既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(<span class="number">0</span>);<span class="comment">//释放资源，放弃占有状态</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p><a href="https://blog.csdn.net/javazejian/article/details/75043422#aqs%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%A6%82%E8%A6%81" target="_blank" rel="noopener">深入剖析基于并发AQS的(独占锁)重入锁(ReetrantLock)及其Condition实现原理</a><br><a href="https://blog.csdn.net/javazejian/article/details/76167357" target="_blank" rel="noopener">剖析基于并发AQS的共享锁的实现(基于信号量Semaphore)</a><br><a href="https://blog.csdn.net/vernonzheng/article/details/8275624" target="_blank" rel="noopener">Java多线程（七）之同步器基础：AQS框架深入分析</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-jtp04186/" target="_blank" rel="noopener">非阻塞算法简介</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      AQS定义了一套多线程访问共享资源的同步器框架，是整个java.util.concurrent包的基石
    
    </summary>
    
      <category term="java" scheme="http://langonggong.com/categories/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://langonggong.com/tags/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>KMP</title>
    <link href="http://langonggong.com/2018/08/30/KMP/"/>
    <id>http://langonggong.com/2018/08/30/KMP/</id>
    <published>2018-08-29T16:44:12.000Z</published>
    <updated>2020-06-22T16:40:36.957Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h1><p>字符串组成为</p><script type="math/tex; mode=display">p_0...p_k...p_i...p_{i+k}...p_j...p_{j+k}...p_m...p_{m+k}...</script><p>假设\(next_{[i+k]}==next_{[m+k]}\)，表示\(p_0…p_{i+k}=p_j…p_{m+k}\) </p><ul><li>如果\(p_{i+k+1}=p_{m+k+1}\)，则\(next_{[m+k+1]}==next_{[m+k]}+1\) </li><li>如果\(p_{i+k+1}!=p_{m+k+1}\)，有\(next_{[i+k]}=k\)，表示\(p_0…p_{k}=p_i…p_{i+k}=p_m…p_{m+k}\)，<ul><li>如果\(p_{m+k+1}=p_{k+1}\)，则\(next_{[m+k+1]}=next_{[k]}+1\)</li><li>如果\(p_{m+k+1}!=p_{k+1}\)，则有\(next_{[k]}=l\)，继续上面的过程</li></ul></li></ul><p>总结下来，若\(next_{[i]}==next_{[j]}\)</p><ul><li>if \(p_{i+1}=p_{j+1}\), then \(next_{[j+1]}==next_{[j]+1}\)</li><li>else \(i==next_{[i]}\),继续上一步</li></ul><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> KMP &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] getNextArr(<span class="keyword">char</span>[] pattern) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pattern == <span class="keyword">null</span> || pattern.length == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] <span class="keyword">next</span> = <span class="keyword">new</span> <span class="keyword">int</span>[pattern.length];</span><br><span class="line">    <span class="keyword">next</span>[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">next</span>[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> currentNext=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos &lt; pattern.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pattern[pos - <span class="number">1</span>] == pattern[currentNext]) &#123;</span><br><span class="line">        <span class="keyword">next</span>[pos++] = ++currentNext;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentNext &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        currentNext = <span class="keyword">next</span>[currentNext];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">next</span>[pos++] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> getIndexOf(String ori, String pattern) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ori.length() &lt; pattern.length()) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] oriArr = ori.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] patternArr = pattern.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> indexOfOri = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> indexOfPattern = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] <span class="keyword">next</span> = getNextArr(patternArr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (indexOfOri &lt; oriArr.length &amp;&amp; indexOfPattern &lt; patternArr.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oriArr[indexOfOri] == patternArr[indexOfPattern]) &#123;</span><br><span class="line">        indexOfOri++;</span><br><span class="line">        indexOfPattern++;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">next</span>[indexOfPattern] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        indexOfPattern = <span class="keyword">next</span>[indexOfPattern];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        indexOfOri++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> indexOfPattern == patternArr.length ? indexOfOri - indexOfPattern : -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      KMP算法
    
    </summary>
    
      <category term="算法" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串匹配" scheme="http://langonggong.com/categories/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    
    
      <category term="算法" scheme="http://langonggong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串匹配" scheme="http://langonggong.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>内存屏障</title>
    <link href="http://langonggong.com/2018/08/23/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"/>
    <id>http://langonggong.com/2018/08/23/内存屏障/</id>
    <published>2018-08-23T15:15:18.000Z</published>
    <updated>2020-06-22T16:40:36.962Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="内存屏障的目的"><a href="#内存屏障的目的" class="headerlink" title="内存屏障的目的"></a>内存屏障的目的</h1><p>每个CPU都会有自己的缓存（有的甚至L1,L2,L3），缓存的目的就是为了提高性能，避免每次都要向内存取。但是这样的弊端也很明显：不能实时的和内存发生信息交换，分在不同CPU执行的不同线程对同一个变量的缓存值不同</p><h1 id="内存屏障的作用"><a href="#内存屏障的作用" class="headerlink" title="内存屏障的作用"></a>内存屏障的作用</h1><p>硬件层的内存屏障分为两种：Load Barrier 和 Store Barrier即读屏障和写屏障</p><ul><li>对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据</li><li>对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见</li></ul><p>内存屏障有两个作用</p><ul><li>阻止屏障两侧的指令重排序</li><li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效</li></ul><h1 id="java内存屏障"><a href="#java内存屏障" class="headerlink" title="java内存屏障"></a>java内存屏障</h1><p>内存屏障可以被分为以下几种类型:</p><ul><li><code>LoadLoad屏障</code>：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li><li><code>StoreStore屏障</code>：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li><li><code>LoadStore屏障</code>：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li><li><code>StoreLoad屏障</code>：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</li></ul><h1 id="volatile语义中的内存屏障"><a href="#volatile语义中的内存屏障" class="headerlink" title="volatile语义中的内存屏障"></a>volatile语义中的内存屏障</h1><p>volatile的内存屏障策略非常严格、悲观</p><ul><li>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障</li><li>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障</li></ul><p>volatile重排序规则：</p><ul><li>volatile写与之前的读写不能重排序</li><li>volatile读与之后的读写不能重排序</li><li>相邻的volatile之间不能重排序</li></ul><p><img src="/images/reordering-table.png"></p><p>volatile内存屏障规则：</p><ul><li>volatile写之前，所有的读写都必须已经完成</li><li>volatile读结束后，所有的读写才能开始</li><li>相邻的volatile必须有序实行</li></ul><p><img src="/images/fences-table.png"></p><h1 id="final语义中的内存屏障"><a href="#final语义中的内存屏障" class="headerlink" title="final语义中的内存屏障"></a>final语义中的内存屏障</h1><ul><li><p>新建对象过程中，构造体中对final域的初始化写入和这个对象赋值给其他引用变量，这两个操作不能重排序</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x.<span class="attr">finalField</span> = v; ... ;构建方法边界<span class="attr">sharedRef</span> = x;</span><br><span class="line">v.<span class="attr">afield</span> = <span class="number">1</span>; x.<span class="attr">finalField</span> = v; ... ; 构建方法边界<span class="attr">sharedRef</span> = x;</span><br><span class="line">这两条语句中，构建方法边界前后的指令都不能重排序。</span><br></pre></td></tr></table></figure></li><li><p>初次读包含final域的对象引用和读取这个final域，这两个操作不能重排序</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">x</span> = sharedRef<span class="comment">; ... ; i = x.finalField;</span></span><br></pre></td></tr></table></figure></li><li><p>为了保证final字段的特殊语义，也会在下面的语句加入内存屏障</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.<span class="attr">finalField</span> = v; StoreStore; <span class="attr">sharedRef</span> = x;</span><br></pre></td></tr></table></figure></li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://www.jianshu.com/p/2ab5e3d7e510" target="_blank" rel="noopener">内存屏障</a></li><li><a href="https://www.cnblogs.com/chenyangyao/p/5269622.html" target="_blank" rel="noopener">JVM内存模型、指令重排、内存屏障概念解析</a></li><li><a href="https://blog.csdn.net/coslay/article/details/41955899" target="_blank" rel="noopener">java内存模型 内存屏障</a></li></ul>]]></content>
    
    <summary type="html">
    
      内存屏障原理解析
    
    </summary>
    
      <category term="java" scheme="http://langonggong.com/categories/java/"/>
    
      <category term="内存模型" scheme="http://langonggong.com/categories/java/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
    
      <category term="java" scheme="http://langonggong.com/tags/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java内存模型" scheme="http://langonggong.com/tags/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>volatile</title>
    <link href="http://langonggong.com/2018/08/23/volatile/"/>
    <id>http://langonggong.com/2018/08/23/volatile/</id>
    <published>2018-08-23T12:54:28.000Z</published>
    <updated>2020-06-22T16:40:36.962Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><p>volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值</p><p><code>线程写volatile变量的过程</code></p><ul><li>改变线程工作内存中volatile变量副本的值</li><li>将改变后的副本的值从工作内存刷新到主内存</li></ul><p><code>线程读volatile变量的过程</code></p><ul><li>从主内存中读取volatile变量的最新值到线程的工作内存中</li><li>从工作内存中读取volatile变量的副本</li></ul><h3 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h3><p>多线程版本(错误的)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> Helper helper = <span class="keyword">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Helper <span class="title">getHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (helper == <span class="keyword">null</span>) </span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (helper == <span class="keyword">null</span>) </span><br><span class="line">          helper = <span class="keyword">new</span> Helper();</span><br><span class="line">      &#125;    </span><br><span class="line">    <span class="keyword">return</span> helper;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// other functions and members...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>volatile关键字修改版<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Helper helper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Helper <span class="title">getHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (helper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (helper == <span class="keyword">null</span>)</span><br><span class="line">                    helper = <span class="keyword">new</span> Helper();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在给helper对象初始化的过程中，jvm做了下面3件事:</p><ul><li>给helper对象分配内存</li><li>调用构造函数</li><li>将helper对象指向分配的内存空间</li></ul><p>由于jvm的”优化”,指令2和指令3的执行顺序是不一定的，当执行完指定3后，此时的helper对象就已经不在是null的了,但此时指令2不一定已经被执行。</p><p>假设线程1和线程2同时调用getHelper()方法，此时线程1执行完指令1和指令3，线程2抢到了执行权，此时helper对象是非空的</p><ul><li>volatile关键字可以保证jvm执行的一定的“有序性”，在指令1和指令2执行完之前，指定3一定不会被执行</li><li>volatile变量被修改后立刻刷新会驻内存中</li></ul><h3 id="不保证复合操作的原子性"><a href="#不保证复合操作的原子性" class="headerlink" title="不保证复合操作的原子性"></a>不保证复合操作的原子性</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        final Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        System.<span class="keyword">out</span>.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程A读取最新的值并在工作内存修改后，还未更新到主存就耗尽cpu时间片，等再次获取时间片后主存的变量值已被线程B修改，但线程A并未感知，继续将值更新到主存，导致B的修改无效</p>]]></content>
    
    <summary type="html">
    
      volatile原理解析
    
    </summary>
    
      <category term="java" scheme="http://langonggong.com/categories/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://langonggong.com/tags/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>hexo高级特性</title>
    <link href="http://langonggong.com/2018/08/19/cool/"/>
    <id>http://langonggong.com/2018/08/19/cool/</id>
    <published>2018-08-19T08:35:51.000Z</published>
    <updated>2020-06-22T16:40:36.957Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="网易云"><a href="#网易云" class="headerlink" title="网易云"></a>网易云</h1><h2 id="通过外链添加"><a href="#通过外链添加" class="headerlink" title="通过外链添加"></a>通过外链添加</h2><p>在网易云音乐的网页版生成歌单外链</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe <span class="attribute">frameborder</span>=<span class="string">"no"</span> <span class="attribute">border</span>=<span class="string">"0"</span> <span class="attribute">marginwidth</span>=<span class="string">"0"</span> <span class="attribute">marginheight</span>=<span class="string">"0"</span> <span class="attribute">width</span>=330 <span class="attribute">height</span>=450 <span class="attribute">src</span>=<span class="string">"//music.163.com/outchain/player?type=0&amp;id=2343741251&amp;auto=1&amp;height=430"</span>&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="450" src="//music.163.com/outchain/player?type=0&id=2343741251&auto=1&height=430"></iframe><h2 id="通过aplayer插件"><a href="#通过aplayer插件" class="headerlink" title="通过aplayer插件"></a>通过aplayer插件</h2><p><a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md#meingjs-%E6%94%AF%E6%8C%81-30-%E6%96%B0%E5%8A%9F%E8%83%BD" target="_blank" rel="noopener">MeingJS 支持</a><br>id为网页上url后面的id值<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% meting <span class="string">"468513829"</span> <span class="string">"netease"</span> <span class="string">"song"</span> <span class="string">"autoplay"</span> <span class="string">"mutex: true"</span> <span class="string">"listmaxheight:340px"</span> <span class="string">"preload:none"</span> <span class="string">"theme:#ad7a86"</span>%&#125;</span><br></pre></td></tr></table></figure></p>    <div id="aplayer-elysuqoy" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="468513829" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="none" data-theme="#ad7a86"></div><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% meting <span class="string">"384485381"</span> <span class="string">"netease"</span> <span class="string">"playlist"</span> <span class="string">"autoplay"</span> <span class="string">"mutex: true"</span> <span class="string">"listmaxheight:340px"</span> <span class="string">"preload:none"</span> <span class="string">"theme:#ad7a86"</span>%&#125;</span><br></pre></td></tr></table></figure>    <div id="aplayer-JHqcuuJP" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="2384642500" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="340px" data-preload="none" data-theme="#ad7a86"></div><h2 id="行间公式"><a href="#行间公式" class="headerlink" title="行间公式"></a>行间公式</h2><script type="math/tex; mode=display">f(n)=\begin{cases}n/2, & \text{如果$ x<=2 $}\\3n+1, & \text{如果$ x>2 $}\end{cases}</script><h2 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h2><p>比如 \(x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}\)</p>]]></content>
    
    <summary type="html">
    
      测试hexo系统新特性
    
    </summary>
    
      <category term="hexo" scheme="http://langonggong.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://langonggong.com/tags/hexo/"/>
    
      <category term="新特性" scheme="http://langonggong.com/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>mysql</title>
    <link href="http://langonggong.com/2018/08/19/mysql/"/>
    <id>http://langonggong.com/2018/08/19/mysql/</id>
    <published>2018-08-19T05:47:35.000Z</published>
    <updated>2020-06-22T16:40:36.959Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="mysql体系结构"><a href="#mysql体系结构" class="headerlink" title="mysql体系结构"></a>mysql体系结构</h2><p><img src="/images/mysql-server.jpg"></p><p><a href="https://www.cnblogs.com/Survivalist/p/7954977.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><div class="table-container"><table><thead><tr><th style="text-align:center">特点</th><th style="text-align:center">MyISAM</th><th style="text-align:center">BDB</th><th style="text-align:center">Memory</th><th style="text-align:center">InnoDB</th><th style="text-align:center">Archive</th></tr></thead><tbody><tr><td style="text-align:center">存储限制</td><td style="text-align:center">没有</td><td style="text-align:center">没有</td><td style="text-align:center">有</td><td style="text-align:center">64TB</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center">事务安全</td><td style="text-align:center"></td><td style="text-align:center">支持</td><td style="text-align:center"></td><td style="text-align:center">支持</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">锁机制</td><td style="text-align:center">表锁</td><td style="text-align:center">页锁</td><td style="text-align:center">表锁</td><td style="text-align:center">行锁</td><td style="text-align:center">行锁</td></tr><tr><td style="text-align:center">B数索引</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">哈希索引</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">全文索引</td><td style="text-align:center">支持</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">集群索引</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">支持</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">数据缓存</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">索引缓存</td><td style="text-align:center">支持</td><td style="text-align:center"></td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">数据可压缩</td><td style="text-align:center">支持</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">空间使用</td><td style="text-align:center">低</td><td style="text-align:center">低</td><td style="text-align:center">N/A</td><td style="text-align:center">高</td><td style="text-align:center">非常低</td></tr><tr><td style="text-align:center">内存使用</td><td style="text-align:center">低</td><td style="text-align:center">低</td><td style="text-align:center">中等</td><td style="text-align:center">高</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">批量插入的速度</td><td style="text-align:center">高</td><td style="text-align:center">高</td><td style="text-align:center">高</td><td style="text-align:center">低</td><td style="text-align:center">非常高</td></tr><tr><td style="text-align:center">支持外键</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">支持</td></tr></tbody></table></div><p><a href="https://blog.csdn.net/len9596/article/details/80206532" target="_blank" rel="noopener">InnoDB与MyISAM原理比较</a></p><p><a href="https://www.cnblogs.com/wangdake-qq/p/7358322.html" target="_blank" rel="noopener">InnoDB与MyISAM索引比较</a></p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h2><h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h3><p><a href="https://blog.csdn.net/mine_song/article/details/63251546" target="_blank" rel="noopener">参考链接</a><br>B树中关键字集合分布在整棵树中，叶节点中不包含任何关键字信息，而B+树关键字集合分布在叶子结点中，非叶节点只是叶子结点中关键字的索引</p><h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><p><a href="https://www.cnblogs.com/heiming/p/5865101.html" target="_blank" rel="noopener">B Tree索引和哈希索引的区别</a></p><p>缺点<br>不支持范围查询和排序、最左匹配规则</p><h3 id="空间-R-Tree-索引"><a href="#空间-R-Tree-索引" class="headerlink" title="空间(R-Tree)索引"></a>空间(R-Tree)索引</h3><p><img src="/images/RTree.jpg"></p><p><a href="https://blog.csdn.net/MongChia1993/article/details/69941783#toc_16" target="_blank" rel="noopener">参考链接</a></p><h3 id="全文-Full-text-索引"><a href="#全文-Full-text-索引" class="headerlink" title="全文(Full-text)索引"></a>全文(Full-text)索引</h3><p>类似es搜索的Lucene分词策略</p><p><a href="https://www.cnblogs.com/itxiongwei/p/7064252.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="索引策略"><a href="#索引策略" class="headerlink" title="索引策略"></a>索引策略</h2><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p><a href="https://blog.csdn.net/john1337/article/details/71081827" target="_blank" rel="noopener">高性能mysql章节</a></p><p>概念<br>使用该列开始的部分长度字符串作</p><p>注意<br>选择足够长的前缀以保证较高的选择性，同时又不能太长以便节约空间</p><p>缺点<br>mysql无法使用其前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描</p><h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p><a href="https://www.cnblogs.com/codeAB/p/6387148.html" target="_blank" rel="noopener">mysql多列索引的生效规则</a></p><h3 id="聚簇索引-Clustered-Indexes-及二级索引-辅助索引"><a href="#聚簇索引-Clustered-Indexes-及二级索引-辅助索引" class="headerlink" title="聚簇索引(Clustered Indexes)及二级索引(辅助索引)"></a>聚簇索引(Clustered Indexes)及二级索引(辅助索引)</h3><p><a href="https://www.linuxidc.com/Linux/2018-02/150809.htm" target="_blank" rel="noopener">高性能mysql章节</a></p><p><a href="https://blog.csdn.net/mine_song/article/details/63251546" target="_blank" rel="noopener">InnoDB与MyISAM的主键索引和二级索引的区别</a></p><ul><li><p>聚集索引<br>表数据按照索引的顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序一致。对于聚集索引，叶子结点即存储了真实的数据行，不再有另外单独的数据页。 在一张表上最多只能创建一个聚集索引，因为真实数据的物理顺序只能有一种</p></li><li><p>非聚集索引<br>表数据存储顺序与索引顺序无关。对于非聚集索引，叶结点包含索引字段值及指向数据页数据行的逻辑指针，其行数量与数据表行数据量一致</p></li></ul><h3 id="覆盖索引-Covering-Indexes"><a href="#覆盖索引-Covering-Indexes" class="headerlink" title="覆盖索引(Covering Indexes)"></a>覆盖索引(Covering Indexes)</h3><p>建立索引的字段正好是覆盖查询语句[select子句]与查询条件[Where子句]中所涉及的字段,数据列只用从索引中就能够取得，不必从数据表中读取<br>参考&lt;&lt;高性能mysql&gt;&gt;</p><p><a href="https://www.cnblogs.com/happyflyingpig/p/7662881.html" target="_blank" rel="noopener">参考链接</a><br><a href="https://www.cnblogs.com/Profound/p/8763022.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="压缩-前缀压缩-索引"><a href="#压缩-前缀压缩-索引" class="headerlink" title="压缩(前缀压缩)索引"></a>压缩(前缀压缩)索引</h3><p><a href="https://blog.csdn.net/yirentianran/article/details/79423908" target="_blank" rel="noopener">参考链接</a></p><h3 id="重复索引"><a href="#重复索引" class="headerlink" title="重复索引"></a>重复索引</h3><p>相同列上按照相同的顺序创建的相同类型的索引    </p><h3 id="冗余索引"><a href="#冗余索引" class="headerlink" title="冗余索引"></a>冗余索引</h3><p>若存在索引(a,b),则(a)是冗余,因为a是前缀,(a,b)可以当成(a)使用;（b,a）和(b)不是冗余索引</p><h3 id="分形树-fractal-treeindex-索引"><a href="#分形树-fractal-treeindex-索引" class="headerlink" title="分形树(fractal treeindex)索引"></a>分形树(fractal treeindex)索引</h3><h3 id="块级别元数据"><a href="#块级别元数据" class="headerlink" title="块级别元数据"></a>块级别元数据</h3><p><img src="/images/ib.png"></p><p><a href="https://blog.csdn.net/hguisu/article/details/11848411" target="_blank" rel="noopener">Infobright高性能数据仓库</a></p><h1 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h1><h2 id="explain关键字"><a href="#explain关键字" class="headerlink" title="explain关键字"></a>explain关键字</h2><p><a href="https://www.cnblogs.com/butterfly100/archive/2018/01/15/8287569.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="查询路径"><a href="#查询路径" class="headerlink" title="查询路径"></a>查询路径</h2><p><img src="/images/mysql-query.png"></p><p><a href="https://www.cnblogs.com/yuyue2014/p/3826941.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p><a href="https://www.cnblogs.com/shengdimaya/p/7123069.html" target="_blank" rel="noopener">join原理</a></p><p>JOIN算法</p><ul><li>Nested-Loop Join<ul><li>Simple Nested-Loop Join</li><li>Index Nested-Loop Join</li><li>Block Nested-Loop Join    </li></ul></li><li>哈希关联</li><li>合并连接</li></ul><h1 id="mysql高级特性"><a href="#mysql高级特性" class="headerlink" title="mysql高级特性"></a>mysql高级特性</h1><h2 id="分库、分区、分表、分片"><a href="#分库、分区、分表、分片" class="headerlink" title="分库、分区、分表、分片"></a>分库、分区、分表、分片</h2><p><a href="http://langonggong.com/2018/07/14/mysql%E5%88%86%E5%BA%93-%E5%88%86%E5%8C%BA-%E5%88%86%E8%A1%A8-%E5%88%86%E7%89%87/">参考链接</a></p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h2 id="内部存储代码"><a href="#内部存储代码" class="headerlink" title="内部存储代码"></a>内部存储代码</h2><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><h3 id="绑定变量"><a href="#绑定变量" class="headerlink" title="绑定变量"></a>绑定变量</h3><h3 id="XA"><a href="#XA" class="headerlink" title="XA"></a>XA</h3><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><h1 id="mvcc与锁"><a href="#mvcc与锁" class="headerlink" title="mvcc与锁"></a>mvcc与锁</h1><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p><a href="https://www.cnblogs.com/chenpingzhao/p/5065316.html" target="_blank" rel="noopener">原理</a></p><h3 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h3><h3 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h3>]]></content>
    
    <summary type="html">
    
      《高性能mysql》读书笔记
    
    </summary>
    
      <category term="mysql" scheme="http://langonggong.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://langonggong.com/tags/mysql/"/>
    
      <category term="DB" scheme="http://langonggong.com/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>spring cloud</title>
    <link href="http://langonggong.com/2018/08/19/springcloud/"/>
    <id>http://langonggong.com/2018/08/19/springcloud/</id>
    <published>2018-08-19T05:12:12.000Z</published>
    <updated>2020-06-22T16:40:36.960Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p><img src="/images/spring-cloud-architecture.png"></p><h2 id="四大神器"><a href="#四大神器" class="headerlink" title="四大神器"></a>四大神器</h2><ul><li>auto-configuration</li><li>starters<br>  <img src="/images/spring-cloud-stater.png"></li><li>cli：Spring Boot Commad Line    </li><li>Autuator监控</li></ul><h1 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h1><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p><img src="/images/aws-eureka.png"></p><p><a href="https://luyiisme.github.io/2017/04/22/spring-cloud-service-discovery-products/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">参考链接</a></p><div class="table-container"><table><thead><tr><th style="text-align:center">Feature</th><th style="text-align:center">Consul</th><th style="text-align:center">zookeeper</th><th style="text-align:center">etcd</th><th style="text-align:center">Eureka</th></tr></thead><tbody><tr><td style="text-align:center">服务健康检查</td><td style="text-align:center">服务状态，内存，硬盘等</td><td style="text-align:center">(弱)长连接，keepalive</td><td style="text-align:center">连接心跳</td><td style="text-align:center">可配支持</td></tr><tr><td style="text-align:center">多数据中心</td><td style="text-align:center">支持</td><td style="text-align:center">—</td><td style="text-align:center">—</td><td style="text-align:center">—</td></tr><tr><td style="text-align:center">kv存储服务</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">—</td></tr><tr><td style="text-align:center">一致性</td><td style="text-align:center">raft</td><td style="text-align:center">paxos</td><td style="text-align:center">raft</td><td style="text-align:center">—</td></tr><tr><td style="text-align:center">cap</td><td style="text-align:center">ca</td><td style="text-align:center">cp</td><td style="text-align:center">cp</td><td style="text-align:center">ap</td></tr><tr><td style="text-align:center">使用接口(多语言能力)</td><td style="text-align:center">支持http和dns</td><td style="text-align:center">客户端</td><td style="text-align:center">http/grpc</td><td style="text-align:center">http（sidecar）</td></tr><tr><td style="text-align:center">watch支持</td><td style="text-align:center">全量/支持long polling    支持</td><td style="text-align:center">支持</td><td style="text-align:center">long polling</td><td style="text-align:center">支持 long polling/大部分增量</td></tr><tr><td style="text-align:center">自身监控</td><td style="text-align:center">metrics</td><td style="text-align:center">—</td><td style="text-align:center">metrics</td><td style="text-align:center">metrics</td></tr><tr><td style="text-align:center">安全</td><td style="text-align:center">acl /https</td><td style="text-align:center">acl    https支持（弱）</td><td style="text-align:center">—</td></tr><tr><td style="text-align:center">spring cloud集成</td><td style="text-align:center">已支持</td><td style="text-align:center">已支持</td><td style="text-align:center">已支持</td><td style="text-align:center">已支持</td></tr></tbody></table></div><h2 id="CAP理论与BASE思想"><a href="#CAP理论与BASE思想" class="headerlink" title="CAP理论与BASE思想"></a>CAP理论与BASE思想</h2><h2 id="服务发现的方式"><a href="#服务发现的方式" class="headerlink" title="服务发现的方式"></a>服务发现的方式</h2><ul><li>客户端发现<br><img src="/images/client-find.png"></li><li>服务器端发现<br><img src="/images/server-find.png"></li></ul><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><h2 id="LB方案"><a href="#LB方案" class="headerlink" title="LB方案"></a>LB方案</h2><p><a href="https://www.cnblogs.com/mindwind/p/5339657.html" target="_blank" rel="noopener">参考链接1</a></p><p><a href="https://www.cnblogs.com/LittleHann/p/3963255.html" target="_blank" rel="noopener">参考链接2</a></p><p><img src="/images/lb-whole.jpg"></p><ul><li>硬负载</li><li>软负载</li><li>DNS负载</li><li>CDN负载</li></ul><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p><strong>核心组件</strong></p><ul><li>ServerList<br>  用于获取地址列表。它既可以是静态的(提供一组固定的地址)，也可以是动态的(从注册中心中定期查询地址列表)    </li><li>ServerListFilter<br>  仅当使用动态ServerList时使用，用于在原始的服务列表中使用一定策略过虑掉一部分地址    </li><li>IRule<br>  选择一个最终的服务地址作为LB结果。选择策略有轮询、根据响应时间加权、断路器(当Hystrix可用时)等    </li></ul><h1 id="rest调用"><a href="#rest调用" class="headerlink" title="rest调用"></a>rest调用</h1><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><h1 id="容错处理"><a href="#容错处理" class="headerlink" title="容错处理"></a>容错处理</h1><p><a href="http://blog.51cto.com/developerycj/1950881" target="_blank" rel="noopener">参考链接1</a><br><a href="https://www.cnblogs.com/leeSmall/p/8847652.html" target="_blank" rel="noopener">参考链接2</a></p><h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><ul><li>限流</li><li>降级</li><li>熔断</li></ul><h2 id="Dashboard-服务监控"><a href="#Dashboard-服务监控" class="headerlink" title="Dashboard 服务监控"></a>Dashboard 服务监控</h2><h2 id="Turbine-聚合监控"><a href="#Turbine-聚合监控" class="headerlink" title="Turbine 聚合监控"></a>Turbine 聚合监控</h2><h1 id="微服务网关"><a href="#微服务网关" class="headerlink" title="微服务网关"></a>微服务网关</h1><h2 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h2><h3 id="过滤器机制"><a href="#过滤器机制" class="headerlink" title="过滤器机制"></a>过滤器机制</h3><p><img src="/images/zuul-filter.png"></p><h3 id="标准过滤器类型"><a href="#标准过滤器类型" class="headerlink" title="标准过滤器类型"></a>标准过滤器类型</h3><ul><li>PRE<ul><li>鉴权</li><li>流量转发</li></ul></li><li>ROUTING</li><li>POST<ul><li>跨域</li><li>统计</li></ul></li><li>ERROR</li></ul><h3 id="request生命周期"><a href="#request生命周期" class="headerlink" title="request生命周期"></a>request生命周期</h3><p><img src="/images/zuul-filter-lifecyle.png"></p><p><a href="http://www.scienjus.com/api-gateway-and-netflix-zuul/#Netflix-Zuul" target="_blank" rel="noopener">参考链接1</a></p><p><a href="https://www.cnblogs.com/lexiaofei/p/7080257.html" target="_blank" rel="noopener">参考链接2</a></p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><ul><li>隔离机制</li><li>重试机制</li></ul><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul><li>验证与安全保障</li><li>审查与监控</li><li>动态路由</li><li>压力测试</li><li>负载分配</li><li>静态响应处理</li><li>多区域弹性</li></ul><h1 id="微服务配置"><a href="#微服务配置" class="headerlink" title="微服务配置"></a>微服务配置</h1><h2 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h2><p><img src="/images/spring-cloud-config.png"></p><h2 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h2><p><img src="/images/configbus2.jpg"></p><p><a href="https://www.cnblogs.com/ityouknow/p/6931958.html" target="_blank" rel="noopener">参考链接</a></p><ul><li>提交代码触发post请求给bus/refresh</li><li>server端接收到请求并发送给Spring Cloud Bus</li><li>Spring Cloud bus接到消息并通知给其它客户端</li><li>其它客户端接收到通知，请求Server端获取最新配置</li><li>全部客户端均获取到最新的配置</li></ul><h1 id="微服务跟踪"><a href="#微服务跟踪" class="headerlink" title="微服务跟踪"></a>微服务跟踪</h1><h2 id="Spring-Cloud-Sleuth"><a href="#Spring-Cloud-Sleuth" class="headerlink" title="Spring Cloud Sleuth"></a>Spring Cloud Sleuth</h2><h2 id="ZipKin"><a href="#ZipKin" class="headerlink" title="ZipKin"></a>ZipKin</h2><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2>]]></content>
    
    <summary type="html">
    
      微服务概念学习
    
    </summary>
    
      <category term="spring" scheme="http://langonggong.com/categories/spring/"/>
    
      <category term="spring cloud" scheme="http://langonggong.com/categories/spring/spring-cloud/"/>
    
    
      <category term="java" scheme="http://langonggong.com/tags/java/"/>
    
      <category term="spring cloud" scheme="http://langonggong.com/tags/spring-cloud/"/>
    
      <category term="网关" scheme="http://langonggong.com/tags/%E7%BD%91%E5%85%B3/"/>
    
      <category term="docker" scheme="http://langonggong.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>java-concurrency</title>
    <link href="http://langonggong.com/2018/08/19/java-concurrency/"/>
    <id>http://langonggong.com/2018/08/19/java-concurrency/</id>
    <published>2018-08-19T04:48:15.000Z</published>
    <updated>2020-06-22T16:40:36.958Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="concurrent包"><a href="#concurrent包" class="headerlink" title="concurrent包"></a>concurrent包</h1><p><img src="/images/concurrent-package.png"></p><p><img src="/images/java-concurrent.png"></p><h2 id="locks-锁"><a href="#locks-锁" class="headerlink" title="locks(锁)"></a>locks(锁)</h2><p><img src="/images/locks.png"></p><h3 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h3><p><a href="http://www.importnew.com/19472.html" target="_blank" rel="noopener">锁分类1</a><br><a href="https://www.cnblogs.com/qifengshi/p/6831055.html" target="_blank" rel="noopener">锁分类2</a></p><ul><li>公平锁/非公平锁</li><li>可重入锁</li><li>可中断锁</li><li>独享锁/共享锁</li><li>互斥锁/读写锁</li><li>乐观锁/悲观锁</li><li>分段锁</li><li>偏向锁/轻量级锁/重量级锁</li><li>自旋锁</li></ul><h3 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h3><p><a href="https://my.oschina.net/hosee/blog/615865" target="_blank" rel="noopener">锁的优化</a></p><ul><li>减少锁持有时间</li><li>减小锁粒度</li><li>锁分离</li><li>锁粗化</li><li>锁消除</li></ul><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>参考链接<br><a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">参考1</a><br><a href="https://segmentfault.com/a/1190000008471362" target="_blank" rel="noopener">参考2</a><br><a href="https://blog.csdn.net/javazejian/article/details/75043422" target="_blank" rel="noopener">AQS、ReetrantLock、Condition实现原理</a></p><p>重要方法:        </p><ul><li>isHeldExclusively()</li><li>tryAcquire(int)</li><li>tryRelease(int)</li><li>tryAcquireShared(int)</li><li>tryReleaseShared(int)</li></ul><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>参考链接<br><a href="https://www.cnblogs.com/aishangJava/p/6555291.html" target="_blank" rel="noopener">参考1</a><br><a href="https://www.cnblogs.com/dolphin0520/p/3923167.html" target="_blank" rel="noopener">参考2</a></p><p>重要方法</p><ul><li>lock()</li><li>lockInterruptibly() throws InterruptedException</li><li>tryLock()</li><li>tryLock(long time, TimeUnit unit) throws InterruptedException</li><li>unlock()</li><li>Condition newCondition()</li></ul><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p><img src="/images/ReentrantLock.gif"></p><p>参考链接<br>    <a href="https://www.cnblogs.com/onlywujun/articles/3531568.html" target="_blank" rel="noopener">参考1</a></p><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p><img src="/images/ReentrantReadWriteLock.jpg"></p><p>参考链接<br><a href="https://www.cnblogs.com/skywang12345/p/3505809.html" target="_blank" rel="noopener">参考1</a><br><a href="https://www.cnblogs.com/grefr/p/6094922.html" target="_blank" rel="noopener">参考2</a></p><h3 id="condition"><a href="#condition" class="headerlink" title="condition"></a>condition</h3><p><a href="https://blog.csdn.net/bohu83/article/details/51098106" target="_blank" rel="noopener">参考链接</a></p><p><a href="https://www.cnblogs.com/Ming8006/p/7243858.html" target="_blank" rel="noopener">生产者、消费者三种实现</a></p><h2 id="atomic-原子变量"><a href="#atomic-原子变量" class="headerlink" title="atomic(原子变量)"></a>atomic(原子变量)</h2><ul><li>AtomicInteger</li><li>AtomicLong</li><li>AtomicBoolean</li><li>AtomicReference</li><li>AtomicIntegerArray/AtomicLongArray/AtomicReferenceArray</li></ul><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>Unsafe类<br>ABA问题</p><h2 id="executor-线程池"><a href="#executor-线程池" class="headerlink" title="executor(线程池)"></a>executor(线程池)</h2><p><a href="https://www.cnblogs.com/aspirant/p/6920418.html" target="_blank" rel="noopener">参考链接</a></p><h3 id="框架类图"><a href="#框架类图" class="headerlink" title="框架类图"></a>框架类图</h3><p><img src="/images/Executor.png"></p><ul><li><p><strong>ThreadPoolExecutor</strong></p><p>  <a href="https://blog.csdn.net/qq_25806863/article/details/71126867" target="_blank" rel="noopener">构造方法和规则</a></p><p>  <a href="http://www.cnblogs.com/trust-freedom/p/6681948.html" target="_blank" rel="noopener">执行原理</a></p><p>  <a href="http://www.cnblogs.com/trust-freedom/p/6693601.html" target="_blank" rel="noopener">线程池终止</a></p><p>  关键参数</p><ul><li>workQueue(排队策略)</li><li>threadFactory</li><li><p>RejectedExecutionHandler(饱和策略)</p><p>常用方法</p></li></ul></li><li><p><strong>Executors</strong></p><p>  创建线程池</p><ul><li>newFixedThreadPool</li><li>newCachedThreadPool</li><li>newSingleThreadExecutor</li><li>newScheduledThreadPool</li></ul></li></ul><h2 id="collections-并发容器"><a href="#collections-并发容器" class="headerlink" title="collections(并发容器)"></a>collections(并发容器)</h2><h3 id="List和Set"><a href="#List和Set" class="headerlink" title="List和Set"></a>List和Set</h3><p><img src="/images/list&set.jpg"></p><ul><li><p>CopyOnWriteArrayList    </p><p>  <a href="http://www.cnblogs.com/skywang12345/p/3498483.html" target="_blank" rel="noopener">参考1</a></p></li><li><p>CopyOnWriteArraySet</p><p>  <a href="http://www.cnblogs.com/skywang12345/p/3498497.html" target="_blank" rel="noopener">参考1</a></p></li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><img src="/images/map.jpg"></p><ul><li><p>ConcurrentHashMap</p><p>  <a href="http://www.cnblogs.com/skywang12345/p/3498537.html" target="_blank" rel="noopener">参考</a></p></li><li><p>ConcurrentSkipListMap</p><p>  <a href="http://www.cnblogs.com/skywang12345/p/3498556.html" target="_blank" rel="noopener">参考</a></p></li><li><p>ConcurrentSkipListSet</p></li></ul><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p><img src="/images/queue.jpg"></p><ul><li><p>ArrayBlockingQueue</p>  <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure><p>  notEmpty和notFull是锁的两个Condition条件<br>  <a href="https://blog.csdn.net/javazejian/article/details/77410889" target="_blank" rel="noopener">实现原理</a></p></li><li><p>LinkedBlockingQueue</p></li><li>LinkedBlockingDeque</li><li>ConcurrentLinkedQueue</li><li>ConcurrentLinkedDeque</li></ul><h2 id="tools-同步工具"><a href="#tools-同步工具" class="headerlink" title="tools(同步工具)"></a>tools(同步工具)</h2><ul><li>CountDownLatch</li><li>CyclicBarrier</li><li>Semaphore</li></ul><h1 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h1><p><a href="https://blog.csdn.net/javazejian/article/details/72772461" target="_blank" rel="noopener">java内存模型</a><br><a href="https://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="noopener">synchronized原理</a></p><h2 id="内存模型概述"><a href="#内存模型概述" class="headerlink" title="内存模型概述"></a>内存模型概述</h2><p><img src="/images/jmm-summary.png"></p><ul><li>主内存</li><li>工作内存</li></ul><h2 id="Java内存模型与硬件内存架构的关系"><a href="#Java内存模型与硬件内存架构的关系" class="headerlink" title="Java内存模型与硬件内存架构的关系"></a>Java内存模型与硬件内存架构的关系</h2><p><img src="/images/jmm-hardware.png"></p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>原子性</li><li>可见性</li><li>有序性</li></ul><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><ul><li>指令重排</li><li>编译器重排</li></ul><h2 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h2><h2 id="happens-before-原则"><a href="#happens-before-原则" class="headerlink" title="happens-before 原则"></a>happens-before 原则</h2><ul><li>程序顺序原则</li><li>锁规则</li><li>volatile规则</li><li>线程启动规则</li><li>传递性</li><li>线程终止规则</li><li>线程中断规则</li><li>对象终结规则</li></ul><h2 id="volatile内存语义"><a href="#volatile内存语义" class="headerlink" title="volatile内存语义"></a>volatile内存语义</h2><ul><li>可见性</li><li>禁止重排优化</li></ul><h2 id="内存屏障（Memory-Barrier）"><a href="#内存屏障（Memory-Barrier）" class="headerlink" title="内存屏障（Memory Barrier）"></a>内存屏障（Memory Barrier）</h2><p><a href="http://ifeve.com/jmm-cookbook-mb/" target="_blank" rel="noopener">参考链接</a></p><ul><li>LoadLoad Barriers</li><li>StoreStore  Barriers</li><li>LoadStore Barriers</li><li>StoreLoad Barriers</li></ul>]]></content>
    
    <summary type="html">
    
      Java Concurrency in Practice读书笔记
    
    </summary>
    
      <category term="java" scheme="http://langonggong.com/categories/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://langonggong.com/tags/java/"/>
    
      <category term="多线程" scheme="http://langonggong.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="jvm" scheme="http://langonggong.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch常用搜索</title>
    <link href="http://langonggong.com/2018/08/19/Elasticsearch/"/>
    <id>http://langonggong.com/2018/08/19/Elasticsearch/</id>
    <published>2018-08-19T04:41:41.000Z</published>
    <updated>2020-06-22T16:40:36.956Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="多字段查找"><a href="#多字段查找" class="headerlink" title="多字段查找"></a>多字段查找</h2><p><code>multi_match</code>        </p><p>以下表达式等价于<code>field1 = value1 or field2 = value1</code></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET <span class="built_in">index</span>/<span class="built_in">type</span>/_<span class="built_in">search</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span><span class="symbol">:</span> &#123;</span><br><span class="line">    <span class="string">"multi_match"</span><span class="symbol">:</span> &#123;</span><br><span class="line">      <span class="string">"query"</span><span class="symbol">:</span> <span class="string">"value1"</span>,</span><br><span class="line">      <span class="string">"fields"</span><span class="symbol">:</span> [<span class="string">"field1"</span>,<span class="string">"field2"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  , <span class="string">"_source"</span><span class="symbol">:</span> [<span class="string">"field1"</span>,<span class="string">"field2"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="布尔查询"><a href="#布尔查询" class="headerlink" title="布尔查询"></a>布尔查询</h2><p><code>must</code>等价于<code>and</code>,<code>must_not</code>等价于<code>not</code>,    <code>should</code>等价于<code>or</code>        </p><p>以下表达式等价于<code>( field1 = value1 or field2 = value2 ) and field3 != value3</code></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">GET index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"size"</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"bool"</span>: &#123;</span><br><span class="line">      <span class="string">"must"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"bool"</span>: &#123;</span><br><span class="line">            <span class="string">"should"</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="string">"match"</span>: &#123;</span><br><span class="line">                  <span class="string">"field1"</span>: <span class="string">"value1"</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="string">"match"</span>: &#123;</span><br><span class="line">                  <span class="string">"field2"</span>: <span class="string">"value2"</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">"must_not"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"match"</span>: &#123;</span><br><span class="line">            <span class="string">"field3"</span>: <span class="string">"value3"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"_source"</span>: [</span><br><span class="line">    <span class="string">"field1"</span>,<span class="string">"field2"</span>,<span class="string">"field3"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p><code>fuzziness</code></p><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/languages.html" target="_blank" rel="noopener">参考链接</a></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">GET index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"size"</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"bool"</span>: &#123;</span><br><span class="line">      <span class="string">"must"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"match"</span>: &#123;</span><br><span class="line">            <span class="string">"city"</span>: &#123;</span><br><span class="line">              <span class="string">"query"</span>: <span class="string">"Hoiliste"</span>,</span><br><span class="line">              <span class="string">"fuzziness"</span>: <span class="string">"auto"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"_source"</span>: [</span><br><span class="line">    <span class="string">"city"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通配符查询"><a href="#通配符查询" class="headerlink" title="通配符查询"></a>通配符查询</h2><p><code>*</code>匹配零个或多个字符</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GET index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"size"</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"bool"</span>: &#123;</span><br><span class="line">      <span class="string">"must"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"wildcard"</span>: &#123;</span><br><span class="line">            <span class="string">"field1"</span>: &#123;</span><br><span class="line">              <span class="string">"value"</span>: <span class="string">"wu*"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"_source"</span>: [</span><br><span class="line">    <span class="string">"field1"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正则查询"><a href="#正则查询" class="headerlink" title="正则查询"></a>正则查询</h2><p><code>regexp</code></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET <span class="built_in">index</span>/<span class="built_in">type</span>/_<span class="built_in">search</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"size"</span><span class="symbol">:</span> <span class="number">100</span>,</span><br><span class="line">  <span class="string">"query"</span><span class="symbol">:</span> &#123;</span><br><span class="line">    <span class="string">"regexp"</span><span class="symbol">:</span>&#123;</span><br><span class="line">      <span class="string">"field1"</span><span class="symbol">:</span><span class="string">"[a-zA-Z]+[0-9]*"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"_source"</span><span class="symbol">:</span> [</span><br><span class="line">    <span class="string">"field1"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h2><p><code>range</code></p><figure class="highlight flix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET <span class="keyword">index</span>/<span class="keyword">type</span>/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"size"</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"range"</span>: &#123;</span><br><span class="line">      <span class="string">"field1"</span>: &#123;</span><br><span class="line">        <span class="string">"from"</span>: <span class="string">"2018-04-16 05:22:39"</span>,</span><br><span class="line">        <span class="string">"to"</span>: <span class="string">"2018-06-23 05:22:39"</span>,</span><br><span class="line">        <span class="string">"include_lower"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"include_upper"</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"_source"</span>: [</span><br><span class="line">    <span class="string">"field1"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><code>sort</code></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"size"</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"bool"</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"sort"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"field1"</span>: &#123;</span><br><span class="line">        <span class="string">"order"</span>: <span class="string">"desc"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"_source"</span>: [</span><br><span class="line">    <span class="string">"field1"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多重过滤"><a href="#多重过滤" class="headerlink" title="多重过滤"></a>多重过滤</h2><p><code>filter</code></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">GET index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"size"</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"bool"</span>: &#123;</span><br><span class="line">      <span class="string">"filter"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"bool"</span>: &#123;</span><br><span class="line">            <span class="string">"must"</span>: &#123;</span><br><span class="line">              <span class="string">"term"</span>: &#123;</span><br><span class="line">                <span class="string">"field1"</span>: <span class="string">"value1"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"bool"</span>: &#123;</span><br><span class="line">            <span class="string">"must"</span>: &#123;</span><br><span class="line">              <span class="string">"term"</span>: &#123;</span><br><span class="line">                <span class="string">"field2"</span>: <span class="string">"value1"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">"_source"</span>: [<span class="string">"cityTerm"</span>, <span class="string">"mlsOrgId"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="脚本查询"><a href="#脚本查询" class="headerlink" title="脚本查询"></a>脚本查询</h2><p><a href="https://my.oschina.net/secisland/blog/683518" target="_blank" rel="noopener">参考链接</a></p><p><code>script</code><br>支持Groovy、java等多种语言的脚本</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"bool"</span>: &#123;</span><br><span class="line">            <span class="attr">"filter"</span>: &#123;</span><br><span class="line">              <span class="attr">"script"</span>: &#123;</span><br><span class="line">                <span class="attr">"script"</span>: &#123;</span><br><span class="line">                  <span class="attr">"inline"</span>: <span class="string">"doc['field1'].value - doc['field2'].value &gt; 0"</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Elasticsearch常用搜索
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://langonggong.com/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://langonggong.com/tags/Elasticsearch/"/>
    
      <category term="DSL" scheme="http://langonggong.com/tags/DSL/"/>
    
  </entry>
  
  <entry>
    <title>mysql分库、分区、分表、分片</title>
    <link href="http://langonggong.com/2018/08/19/mysql%E5%88%86%E5%BA%93%E3%80%81%E5%88%86%E5%8C%BA%E3%80%81%E5%88%86%E8%A1%A8%E3%80%81%E5%88%86%E7%89%87/"/>
    <id>http://langonggong.com/2018/08/19/mysql分库、分区、分表、分片/</id>
    <published>2018-08-19T01:20:32.000Z</published>
    <updated>2020-06-22T16:40:36.959Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>mysql的分表是真正的分表，一张表分成很多表后，每一个小表都是完正的一张表，都对应三个文件（MyISAM引擎：一个.MYD数据文件，.MYI索引文件，.frm表结构文件）<br>分表后数据都是存放在分表里，总表只是一个外壳，存取数据发生在一个一个的分表里面</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>一张表的查询速度已经慢到影响使用的时候</li><li>当频繁插入或者联合查询时，速度变慢</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>利用merge存储引擎来实现分表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb_member1`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`sex`</span> tinyint(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM AUTO_INCREMENT=<span class="number">2</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb_member2`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`sex`</span> tinyint(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM AUTO_INCREMENT=<span class="number">2</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb_member`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`sex`</span> tinyint(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MRG_MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 INSERT_METHOD=<span class="keyword">LAST</span> <span class="keyword">UNION</span>=(<span class="string">`tb_member1`</span>,<span class="string">`tb_member2`</span>)</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>分表数据库引擎是MyISAM</li><li>分表与主表的字段定义一致</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/miketwais/articles/mysql_partition.html" target="_blank" rel="noopener">参考链接1</a></p><p><a href="https://www.cnblogs.com/lucky-man/p/6207873.html" target="_blank" rel="noopener">参考链接2</a></p><h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>把存放数据的文件分成了许多小块，分区后的表还是一张表</p><h2 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>一张表的查询速度已经慢到影响使用的时候</li><li>表中的数据是分段的</li><li>对数据的操作往往只涉及一部分数据，而不是所有的数据</li></ul><p>历史数据或不常访问的数据占很大部分，最新或热点数据占的比例不是很大，可以根据有些条件进行表分区。例如，表中有大量的历史记录，而“热数据”却位于表的末尾</p><h2 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h2><div class="table-container"><table><thead><tr><th style="text-align:center">分区类型</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center">RANGE</td><td style="text-align:center">基于属于一个给定连续区间的列值，把多行分配给分区</td></tr><tr><td style="text-align:center">LIST</td><td style="text-align:center">类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择</td></tr><tr><td style="text-align:center">HASH</td><td style="text-align:center">基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式</td></tr><tr><td style="text-align:center">KEY</td><td style="text-align:center">类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值</td></tr></tbody></table></div><h2 id="操作方式"><a href="#操作方式" class="headerlink" title="操作方式"></a>操作方式</h2><p>创建分区</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sales (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT,</span><br><span class="line">    amount <span class="keyword">DOUBLE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    order_day DATETIME <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>, order_day)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">Innodb</span> </span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(<span class="keyword">YEAR</span>(order_day)) (</span><br><span class="line">    <span class="keyword">PARTITION</span> p_2010 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2010</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p_2011 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2011</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p_2012 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2012</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p_catchall <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> MAXVALUE);</span><br></pre></td></tr></table></figure><p>常用操作</p><p><img src="/images/mysql-PARTITION-use.jpg"></p><h2 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/laoyang360/article/details/52886987" target="_blank" rel="noopener">参考链接1</a></p><p><a href="https://www.cnblogs.com/mliudong/p/3625522.html" target="_blank" rel="noopener">参考链接2</a></p><h1 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h1><p><a href="https://www.cnblogs.com/sunny3096/p/8595058.html" target="_blank" rel="noopener">参考链接</a></p><h1 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h1><p><a href="https://www.cnblogs.com/vadim/p/6985430.html" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      《高性能mysql》读书笔记
    
    </summary>
    
      <category term="mysql" scheme="http://langonggong.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://langonggong.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>java虚拟机</title>
    <link href="http://langonggong.com/2018/08/19/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://langonggong.com/2018/08/19/java虚拟机/</id>
    <published>2018-08-18T22:07:10.000Z</published>
    <updated>2020-06-22T16:40:36.959Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><p><img src="/images/jvm_ architect.png"></p><h2 id="Java堆（Heap）"><a href="#Java堆（Heap）" class="headerlink" title="Java堆（Heap）"></a>Java堆（Heap）</h2><p>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中<code>最大</code>的一块。Java堆是被所有线程共享的一块内存区域，<code>在虚拟机启动时创建</code>。此内存区域的唯一目的就是存放对象实例，<code>几乎所有的对象实例都在这里分配内存</code>。</p><p>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“<code>GC堆</code>”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。</p><p>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。</p><p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，<code>它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</code>。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p><p>对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“<code>永久代</code>”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。</p><p>Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。</p><p>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><h2 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h2><p>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是<code>当前线程所执行的字节码的行号指示器</code>。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），<code>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</code>。 </p><p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 </p><p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。</p><p><code>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域</code>。</p><h2 id="JVM栈（JVM-Stacks）"><a href="#JVM栈（JVM-Stacks）" class="headerlink" title="JVM栈（JVM Stacks）"></a>JVM栈（JVM Stacks）</h2><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，<code>它的生命周期与线程相同</code>。虚拟机栈描述的是Java方法执行的内存模型：<code>每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息</code>。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。<br><a href="https://blog.csdn.net/xtayfjpk/article/details/41924283" target="_blank" rel="noopener">运行时栈帧结构</a></p><p>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p><p>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p>在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。</p><h2 id="本地方法栈（Native-Method-Stacks）"><a href="#本地方法栈（Native-Method-Stacks）" class="headerlink" title="本地方法栈（Native Method Stacks）"></a>本地方法栈（Native Method Stacks）</h2><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是<code>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务</code>。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><h3 id="句柄方式"><a href="#句柄方式" class="headerlink" title="句柄方式"></a>句柄方式</h3><p>如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息</p><p>优点<br>使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改</p><p><img src="/images/jvm_obj_handle.png"></p><h3 id="直接指针方式"><a href="#直接指针方式" class="headerlink" title="直接指针方式"></a>直接指针方式</h3><p>如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址</p><p>优点<br>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本</p><p><img src="/images/jvm_obj_ cursor.png"></p><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><h2 id="对象存活分析"><a href="#对象存活分析" class="headerlink" title="对象存活分析"></a>对象存活分析</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>原理<br>给对象中每一个对象分配一个引用计数器，每当有地方引用该对象时，引用计数器的值加一，当引用失效时，引用计数器的值减一，不管什么时候，只要引用计数器的值等于0了，说明该对象不可能再被使用了</p><p>优缺点<br>实现原理简单，而且判定效率很高。大部分情况下都是一个不错的算法。但很难解决对象之间相互循环引用的问题</p><h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>原理<br>通过一系列被称为“GC Roots‘’的对象作为起始点，从这些节点向下搜索，搜索所走过的路径叫做引用链，当一个节点到GC Roots没有任何引用链时，证明该对象不可用了</p><p>被作为GC Roots的对象有以下几种:</p><ul><li>虚拟机栈中引用的对象（栈帧中的引用变量表）</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中Native方法（JNI）引用的对象</li></ul><h2 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h2><p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类</p><p>废弃常量回收<br>回收废弃常量与回收Java堆中的对象非常相似。以常量池中字面量的回收为例，若字符串“abc”已经进入常量池中，但当前系统没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用该字面量，若发生内存回收，且必要的话，该“abc”就会被系统清理出常量池。常量池中其他的类（接口）、方法、字段的符号引用与此类似</p><p>无用的类回收</p><ul><li>该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例</li><li>加载该类的ClassLoader已经被回收</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul><p>在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出</p><h2 id="新生代、老年代以及永久代"><a href="#新生代、老年代以及永久代" class="headerlink" title="新生代、老年代以及永久代"></a>新生代、老年代以及永久代</h2><p><img src="/images/java-heap.jpeg"></p><p>堆大小 = 新生代 + 老年代</p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>1个Eden区和2个Survivor区（分别叫from和to）,默认比例为8：1。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。</p><p>因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在<code>年轻代的垃圾回收算法使用的是复制算法</code></p><p>在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”</p><p><img src="/images/java-new-generation.png"></p><h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>老年代与新生代不同，对象存活的时间比较长，比较稳定，因此采用标记（Mark）算法来进行回收</p><h3 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h3><p>在JDK的HotSpot虚拟机中，可以认为方法区就是永久代，但是在其他类型的虚拟机中，没有永久代的概念</p><h2 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h2><ul><li><p>Minor GC<br>  发生在新生代中的垃圾收集动作，所采用的是复制算法</p></li><li><p>FullGC (Major GC)<br>  发生在老年代的垃圾收集动作，所采用的是标记-清除算法</p></li></ul><h2 id="JVM内存管理参数"><a href="#JVM内存管理参数" class="headerlink" title="JVM内存管理参数"></a>JVM内存管理参数</h2><p><a href="https://blog.csdn.net/Thousa_Ho/article/details/77278656" target="_blank" rel="noopener">JVM参数使用总结</a></p><ul><li>-Xms 设置堆的最小空间大小</li><li>-Xmx 设置堆的最大空间大小</li><li>-XX:NewSize 设置新生代最小空间大小</li><li>-XX:MaxNewSize 设置新生代最大空间大小</li><li>-Xmn:设置新生代的内存空间大小</li><li>-XX:PermSize 设置永久代最小空间大小</li><li>-XX:MaxPermSize 设置永久代最大空间大小</li><li>-Xss 设置每个线程的堆栈大小。</li><li>-XX:NewRatio 设置新生代和老生代的相对大小</li><li>-XX:SurvivorRatio 指定Eden区和Survivor区的大小比例,注意两个幸存区是一样大的</li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><ul><li><p>复制算法(新生代)<br>该算法的核心是将可用内存按容量划分为大小相等的两块, 每次只用其中一块, 当这一块的内存用完, 就将还存活的对象复制到另外一块上面, 然后把已使用过的内存空间一次清理掉</p></li><li><p>标记清除算法(老年代)(mark-sweep)<br>该算法分为“标记”和“清除”两个阶段: 首先标记出所有需要回收的对象(可达性分析), 在标记完成后统一清理掉所有被标记的对象</p><p>  该算法会有以下两个问题</p><ul><li>效率问题: 标记和清除过程的效率都不高;</li><li>空间问题: 标记清除后会产生大量不连续的内存碎片, 空间碎片太多可能会导致在运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集</li></ul></li><li><p>标记整理算法(老年代)(mark-compact)<br>标记清除算法会产生内存碎片问题, 而复制算法需要有额外的内存担保空间, 于是针对老年代的特点, 又有了标记整理算法. 标记整理算法的标记过程与标记清除算法相同, 但后续步骤不再对可回收对象直接清理, 而是让所有存活的对象都向一端移动,然后清理掉端边界以外的内存</p></li></ul><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="/images/GC-collertor2.jpg"></p><p><a href="https://blog.csdn.net/qq_33938256/article/details/52502502" target="_blank" rel="noopener">GC收集器</a><br><a href="http://www.importnew.com/23035.html" target="_blank" rel="noopener">内存分配、GC原理与垃圾收集器</a></p><ul><li>串行收集器 Serial开头的 <ul><li>Serial</li><li>Serial Old(MSC)</li></ul></li><li>并行收集器 Parallel开头的 <ul><li>ParNew</li><li>Parallel Scavenge</li><li>Parallel Old</li></ul></li><li>并发收集器 <ul><li>CMS (Concurrent Mark Sweep)</li></ul></li><li>G1(Garbage First)<br>  图片中的问号位置<br>  JDK 1.7后有G1</li></ul><p>说明：</p><ul><li>Parallel Scanvenge<br>  也叫吞吐量优先收集器，吞吐量=运行用户代码时间/(运行用户代码时间 + GC时间)。停顿时间短，适合与用户交互的程序；高吞吐量，可以有效利用CPU时间，尽管完成计算任务，适合后台运算而不需要太多交互的任务</li><li>CMS<br>  目标：最短回收停顿时间。并发收集，低停顿，适合B/S架构，需要低延迟时间的应用需求</li></ul><h2 id="GC日志"><a href="#GC日志" class="headerlink" title="GC日志"></a>GC日志</h2><p>日志格式<br><img src="/images/gc_log.png"></p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">GC（GC类型，当前是Minor</span> GC） (<span class="name">Allocation</span> Failure) [<span class="name">DefNew（GC的区域，当前为新生代）:</span> <span class="number">5688</span>K（垃圾回收前的大小）-&gt;790K（垃圾回收以后的大小）(<span class="name">9216K</span>)（该区域总大小）, <span class="number">0.0060899</span> secs] <span class="number">5688</span>K（堆在垃圾回收前的大小）-&gt;4886K（堆在垃圾回收后的大小）(<span class="name">19456K</span>)（堆的总大小）, <span class="number">0.0061183</span> secs] [<span class="name">Times:</span> user=0.00（用户态消耗CPU时间） sys=0.01（内核态小时CPU时间）, real=0.00 secs（操作的实际时间）]</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/fd1d4f21733a" target="_blank" rel="noopener">理解GC日志</a><br><a href="https://www.cnblogs.com/duke2016/p/6250766.html" target="_blank" rel="noopener">GC收集器与GC日志</a></p><ul><li>大对象直接进入老年代</li><li>长期存活的对象进入老年代</li></ul><h1 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h1><p><img src="/images/class.png"></p><p><a href="https://blog.csdn.net/column/details/jvm-principle.html" target="_blank" rel="noopener">参考系列</a></p><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><p><img src="/images/class-load.png"></p><p><a href="https://blog.csdn.net/fgets/article/details/52934178" target="_blank" rel="noopener">参考链接</a><br><a href="https://blog.csdn.net/shakespeare001/article/details/51765353" target="_blank" rel="noopener">参考章节</a></p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><ul><li>通过一个类的全限定名来获取其定义的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口</li></ul><p>除了可以使用系统提供的引导类加载器外，还可以使用用户自定义的类加载器。任意一个类，都需要由加载它的类加载器和这个类本身共同确定其在Java 虚拟机中的唯一性</p><p>类加载器</p><p><img src="/images/classLoader.png"></p><ul><li>启动类加载器：启动类加载器无法被 java 程序直接引用，如需要，直接使用 null 代替即可</li><li>扩展类加载器</li><li>应用程序类加载器：它负责加载用户路径(ClassPath)上所指定的类库，开发者可以使用这个类加载器，如果应用程序没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器</li></ul><p>双亲委派模型<br>如果一个类加载器收到了类加载器的请求，它首先不会自己尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类时），子加载类才会尝试自己去加载</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</p><ul><li>文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理</li><li>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，主要是验证类的继承关系、数据类型是否符合</li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。对类的方法体进行校验分析，以保证被校验类的方法在运行时不会做出危害虚拟机安全的事件</li><li>符号引用验证：发生在虚拟机将符号引用转化为直接引用的时候,对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验</li></ul><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配</p><ul><li>这阶段进行内存分配的仅包括类变量（即被static修饰的变量），不包括实例变量</li><li>这里所说的初始值“通常情况”下是数据类型的零值</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程</p><ul><li>符号引用（Symbolic References）：即用一组符号来描述所引用的目标。它与虚拟机的内存布局无关，引用的目标不一定已经加载到内存中</li><li>直接引用（Direct References）：直接引用可以是指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。它是和虚拟机内存布局相关的，如果有了直接引用，那引用的目标必定已经在内存中存在了</li></ul><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7类符号引用进行</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化是类加载过程的最后一步，此阶段才开始真正执行类中定义的Java程序代码（或者说字节码，也仅限与执行<clinit>()方法）。在准备阶段，我们已经给变量付过一次系统要求的初始值（零值），而在初始化阶段，则会根据程序员的意愿给类变量和其他资源赋值。主要是通过<clinit>()方法来执行的</clinit></clinit></p><h1 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h1><p><a href="https://blog.csdn.net/u013678930/article/details/51980460" target="_blank" rel="noopener">章节参考</a></p><h1 id="Java编译期优化"><a href="#Java编译期优化" class="headerlink" title="Java编译期优化"></a>Java编译期优化</h1><p><img src="/images/jvm_complier.png"></p><h2 id="解析与填充符号表过程"><a href="#解析与填充符号表过程" class="headerlink" title="解析与填充符号表过程"></a>解析与填充符号表过程</h2><p>解析步骤包含了词法分析和语法分析两个过程，首先词法分析是将源代码的字符流转变成为标记集合（token），然后语法分析是根据token序列来构造抽象语法树（一种用来描述程序代码语法结构的树状表示方式）。完成词法分析和语法分析之后，下一步是填充符号表，符号表是由一组符号地址和符号信息构成的表格，符号表中所登记的信息在编译的不同阶段都要用到（比如语义分析中符号表所登记的内容将用于语义检查和产生中间代码，目标代码生成阶段当对符号名进行地址分配时，符号表是地址分配的依据）</p><h2 id="插入式注解处理器的注解处理过程"><a href="#插入式注解处理器的注解处理过程" class="headerlink" title="插入式注解处理器的注解处理过程"></a>插入式注解处理器的注解处理过程</h2><p>插入式注解处理器可以看做是一组编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，那么编译器将回到解析及填充符号表的过程重新处理，直到所有的插入式注解处理器都没有再对语法树进行修改为止</p><h2 id="语义分析与字节码生成过程"><a href="#语义分析与字节码生成过程" class="headerlink" title="语义分析与字节码生成过程"></a>语义分析与字节码生成过程</h2><p>语法分析之后，编译器获得了程序代码的抽象语法树表示，语法树能够表示结构正确的源程序的抽象，但是无法保证源程序是否符合逻辑，而语义分析主要是对结构上正确的源程序进行上下文有关性质的检查</p><h3 id="标注检查"><a href="#标注检查" class="headerlink" title="标注检查"></a>标注检查</h3><p>标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配，等等。还有一个重要的动作称为常量折叠也在此阶段完成</p><h3 id="数据及控制流分析"><a href="#数据及控制流分析" class="headerlink" title="数据及控制流分析"></a>数据及控制流分析</h3><p>数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否有返回值、是否所有的受查异常都被正确处理了等问题</p><h3 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h3><p>语法糖是指在计算机语言中添加某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。java中的泛型，变长参数，自动拆箱与装箱，条件编译等就属于语法糖，它们在编译阶段就被还原成简单的语法结构（比如List<string>和List<integer>在运行期间其实是同一个类）</integer></string></p><h3 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h3><p>此过程是javac编译过程的最后一个阶段，字节码生成阶段将之前各个步骤所生成的信息转化成字节码写到磁盘中，另外还进行少量的代码添加和转换工作</p><h1 id="Java运行期优化"><a href="#Java运行期优化" class="headerlink" title="Java运行期优化"></a>Java运行期优化</h1><p><img src="/images/jvm_jit.png"></p><p>在部分商用虚拟机中，java程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块运行特别频繁，就会把这些代码认定为“热点代码”，为了提高热点代码的执行效率，在运行时，虚拟机就会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器或JIT编译器。</p><p>即时编译器并不是虚拟机必须的部分，但是即时编译器编译性能的好坏、代码优化程度的高低确是衡量一款商用虚拟机优秀与否的最关键的指标之一。</p><p>众多主流的虚拟机都同时包含解释器和JIT编译器，解释器与JIT编译器各有优势：当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行。当程序运行后，随着事件的推移，JIT编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率</p><p>会被即时编译器编译的热点代码有两类</p><ul><li>被多次调用的方法体</li><li>被多次调用的循环体</li></ul><p>即时编译器会以整个方法作为编译对象，将其编译成机器码。这种编译方式因为编译发生在方法执行过程之中，因此被称作栈上替换（OSR）</p><p>判断一段代码是否是热点代码的方式（热点探测）有两种</p><ul><li>基于采样的热点探测：此方法会周期性检查各个线程的栈顶，如果发现某个或某些方法经常出现在栈顶，那么这个方法就是热点方法。此方法的缺点是很难精确地确认一个方法的热度，容易受到诸如线程阻塞等因素影响</li><li>基于计数器的热点探测：此方法会为每个方法甚至是代码块建立计数器，统计方法的执行次数，如果执行次数超过一个阀值就认为它是热点方法</li></ul><p>默认设置下，执行引擎并不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成。当编译工作完成之后，这个方法的调用入口地址就会被系统自动改写成新的地址，下一次调用该方法时就会使用已编译的版本。也就是说，在编译器还未完成之前，执行引擎仍按照解释方式继续执行，而编译动作则在后台的编译线程中进行</p><p>优化技术<br>一般来说即时编译器所产生的本地代码会比javac产生的字节码更优秀。即时编译器采用了一系列的技术来优化代码，比如公共子表达式消除，数组范围内检查消除，方法内联，逃逸分析等</p>]]></content>
    
    <summary type="html">
    
      《深入理解JAVA虚拟机实战》读书笔记
    
    </summary>
    
      <category term="java" scheme="http://langonggong.com/categories/java/"/>
    
      <category term="jvm" scheme="http://langonggong.com/categories/java/jvm/"/>
    
    
      <category term="java" scheme="http://langonggong.com/tags/java/"/>
    
      <category term="jvm" scheme="http://langonggong.com/tags/jvm/"/>
    
  </entry>
  
</feed>

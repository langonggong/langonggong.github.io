<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>武汉旭神</title>
  
  <subtitle>路漫漫其修远兮，吾将上下而求索</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-03T13:26:59.658Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>lanxu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>归并排序</title>
    <link href="http://yoursite.com/2018/09/03/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/09/03/归并排序/</id>
    <published>2018-09-03T13:24:32.000Z</published>
    <updated>2018-09-03T13:26:59.658Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>不断二分递归调用自身，然后对局部排序</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> MergeSort &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">int</span>[] mergeSort(<span class="built_in">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    divide(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    return arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> void divide(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">left</span> &gt;= <span class="built_in">right</span>) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>) / <span class="number">2</span>;</span><br><span class="line">    divide(arr, <span class="built_in">left</span>, <span class="built_in">mid</span>);</span><br><span class="line">    divide(arr, <span class="built_in">mid</span> + <span class="number">1</span>, <span class="built_in">right</span>);</span><br><span class="line">    merge(arr, <span class="built_in">left</span>, <span class="built_in">mid</span>, <span class="built_in">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> void merge(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">mid</span>, <span class="built_in">int</span> <span class="built_in">right</span>) &#123;</span><br><span class="line">    <span class="built_in">int</span>[] result = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="built_in">right</span> - <span class="built_in">left</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">int</span> i = <span class="built_in">left</span>, j = <span class="built_in">mid</span> + <span class="number">1</span>, index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= <span class="built_in">mid</span> &amp;&amp; j &lt;= <span class="built_in">right</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">        result[index++] = arr[i++];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result[index++] = arr[j++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= <span class="built_in">mid</span>) &#123;</span><br><span class="line">      result[index++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= <span class="built_in">right</span>) &#123;</span><br><span class="line">      result[index++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> k=<span class="number">0</span>;k&lt;result.length;k++) &#123;</span><br><span class="line">      arr[<span class="built_in">left</span> + k] = result[k];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      不断二分递归调用自身，然后对局部排序
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>插入排序</title>
    <link href="http://yoursite.com/2018/09/02/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/09/02/插入排序/</id>
    <published>2018-09-02T15:10:00.000Z</published>
    <updated>2018-09-03T13:24:47.923Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>假设前面的数组已经有序，则找到改点合适的位置插入(该点下沉到合适的位置)</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InsertionSort</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">insertionSort</span>(<span class="params"><span class="keyword">int</span>[] arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> j = i;</span><br><span class="line">      <span class="keyword">while</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">          swap(arr, j, j - <span class="number">1</span>);</span><br><span class="line">          j--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span>(<span class="params"><span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      假设前面的数组已经有序，则找到改点合适的位置插入
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>选择排序</title>
    <link href="http://yoursite.com/2018/09/02/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/09/02/选择排序/</id>
    <published>2018-09-02T14:58:40.000Z</published>
    <updated>2018-09-02T15:10:08.521Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>选择最小值与第一个数字交换</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SelectSort</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">selectionSort</span>(<span class="params"><span class="keyword">int</span>[] arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> mini = i;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">        mini = arr[j] &lt; arr[mini] ? j : mini;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(arr, i, mini);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span>(<span class="params"><span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      选择最小值与第一个数字交换
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="http://yoursite.com/2018/09/02/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/09/02/冒泡排序/</id>
    <published>2018-09-02T14:49:03.000Z</published>
    <updated>2018-09-02T15:10:10.918Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>最大值上浮</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BubbleSort</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">bubbleSort</span>(<span class="params"><span class="keyword">int</span>[] arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=arr.length<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">          swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span>(<span class="params"><span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      最大值上浮
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>AQS</title>
    <link href="http://yoursite.com/2018/09/01/AQS/"/>
    <id>http://yoursite.com/2018/09/01/AQS/</id>
    <published>2018-09-01T06:14:14.000Z</published>
    <updated>2018-09-02T13:22:55.788Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在JDK1.5之前，一般是靠synchronized关键字来实现线程对共享变量的互斥访问。synchronized是在字节码上加指令，依赖于底层操作系统的Mutex Lock实现。<br>AQS定义了一套多线程访问共享资源的同步器框架，是整个java.util.concurrent包的基石，Lock、ReadWriteLock、CountDowndLatch、CyclicBarrier、Semaphore、ThreadPoolExecutor等都是在AQS的基础上实现的。</p><h1 id="同步队列-CLH"><a href="#同步队列-CLH" class="headerlink" title="同步队列(CLH)"></a>同步队列(CLH)</h1><p>AQS维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）</p><p><img src="/images/AQS同步队列模型.png"></p><p>AQS的内部队列是CLH同步锁的一种变形。其主要从两方面进行了改造，节点的结构与节点等待机制</p><ul><li>在结构上引入了头结点和尾节点，分别指向队列的头和尾，尝试获取锁、入队列、释放锁等实现都与头尾节点相关</li><li>为了可以处理timeout和cancel操作，每个node维护一个指向前驱的指针。如果一个node的前驱被cancel，这个node可以前向移动使用前驱的状态字段</li><li>在每个node里面使用一个状态字段来控制阻塞/唤醒，而不是自旋</li><li>head结点使用的是傀儡结点</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span>&#123;</span></span><br><span class="line"><span class="comment">//指向同步队列队头</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指向同步的队尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步状态，在不同的子类有不同的含义</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略其他代码......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h2><p>Node结点是对每一个访问同步代码的线程的封装，从图中的Node的数据结构也可看出，其包含了需要同步的线程本身以及线程的状态，如是否被阻塞，是否等待唤醒，是否已经被取消等。每个Node结点内部关联其前继结点prev和后继结点next，这样可以方便线程释放锁后快速唤醒下一个在等待的线程，Node是AQS的内部类，其数据结构如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">//共享模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">//独占模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标识线程已处于结束状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//等待被唤醒状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//条件状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//在共享模式中使用表示获得的同步状态会被传播</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待状态,存在CANCELLED、SIGNAL、CONDITION、PROPAGATE 4种</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同步队列中前驱结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">//同步队列中后继结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">//请求锁的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="comment">//等待队列中的后继结点，这个与Condition有关</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否为共享模式</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取前驱结点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中SHARED和EXCLUSIVE常量分别代表共享模式和独占模式，所谓共享模式是一个锁允许多条线程同时操作，如信号量Semaphore采用的就是基于AQS的共享模式实现的，而独占模式则是同一个时间段只能有一个线程对共享资源进行操作，多余的请求线程需要排队等待，如ReentranLock。变量waitStatus则表示当前被封装成Node结点的等待状态，共有4种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE</p><ul><li>CANCELLED：值为1，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node的结点，其结点的waitStatus为CANCELLED，即结束状态，进入该状态后的结点将不会再变化。</li><li>SIGNAL：值为-1，被标识为该等待唤醒状态的后继结点，当其前继结点的线程释放了同步锁或被取消，将会通知该后继结点的线程执行。说白了，就是处于唤醒状态，只要前继结点释放锁，就会通知标识为SIGNAL状态的后继结点的线程执行。</li><li>CONDITION：值为-2，与Condition相关，该标识的结点处于等待队列中，结点的线程等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。</li><li>PROPAGATE：值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态。</li><li>0状态：值为0，代表初始化状态。</li></ul><h2 id="AQS-lock-操作"><a href="#AQS-lock-操作" class="headerlink" title="AQS lock()操作"></a>AQS lock()操作</h2><p><img src="/images/AQS-lock.png"></p><h1 id="Sync与State实现"><a href="#Sync与State实现" class="headerlink" title="Sync与State实现"></a>Sync与State实现</h1><h2 id="state机制"><a href="#state机制" class="headerlink" title="state机制"></a>state机制</h2><p>volatile 变量 state;  用于同步线程之间的共享状态。通过 CAS 和 volatile 保证其原子性和可见性。<br>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步状态 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//CAS </span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this  </span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> unsafe.<span class="title">compareAndSwapInt</span><span class="params">(<span class="keyword">this</span>, stateOffset, expect, update)</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同实现类的Sync与State"><a href="#不同实现类的Sync与State" class="headerlink" title="不同实现类的Sync与State"></a>不同实现类的Sync与State</h2><p>基于AQS构建的Synchronizer包括ReentrantLock,Semaphore,CountDownLatch, ReetrantRead WriteLock,FutureTask等，这些Synchronizer实际上最基本的东西就是原子状态的获取和释放，只是条件不一样而已</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>需要记录当前线程获取原子状态的次数，如果次数为零，那么就说明这个线程放弃了锁（也有可能其他线程占据着锁从而需要等待），如果次数大于1，也就是获得了重进入的效果，而其他线程只能被park住，直到这个线程重进入锁次数变成0而释放原子状态。以下为ReetranLock的FairSync的tryAcquire实现代码解析</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公平获取锁</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//如果当前重进入数为0,说明有机会取得锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果是第一个等待者，并且设置重进入数成功，那么当前线程获得锁</span></span><br><span class="line">        <span class="keyword">if</span> (isFirst(current) &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="comment">//如果当前线程本身就持有锁，那么叠加重进入数，并且继续获得锁</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">     <span class="comment">//以上条件都不满足，那么线程进入等待队列。</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>信号量维护了一个许可集，我们在初始化Semaphore时需要为这个许可集传入一个数量值，该数量值代表同一时间能访问共享资源的线程数量。以下为Semaphore的FairSync实现</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> tryAcquireShared(<span class="keyword">int</span> acquires) &#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="built_in">for</span> (;;) &#123;</span><br><span class="line">         Thread first = getFirstQueuedThread();</span><br><span class="line">         <span class="comment">//如果当前等待队列的第一个线程不是当前线程，那么就返回-1表示当前线程需要等待</span></span><br><span class="line">         <span class="built_in">if</span> (first != null &amp;&amp; first != current)</span><br><span class="line">              <span class="built_in">return</span> <span class="number">-1</span>;</span><br><span class="line">         <span class="comment">//如果当前队列没有等待者，或者当前线程就是等待队列第一个等待者，那么先取得semaphore还有几个许可证，并且减去当前线程需要的许可证得到剩下的值</span></span><br><span class="line">         <span class="keyword">int</span> <span class="built_in">available</span> = getState();</span><br><span class="line">         <span class="keyword">int</span> remaining = <span class="built_in">available</span> - acquires;</span><br><span class="line">         <span class="comment">//如果remining&lt;0，那么反馈给AQS当前线程需要等待，如果remaining&gt;0，并且设置availble成功设置成剩余数，那么返回剩余值(&gt;0)，也就告知AQS当前线程拿到许可，可以继续执行。</span></span><br><span class="line">         <span class="built_in">if</span> (remaining &lt; <span class="number">0</span> ||compareAndSetState(<span class="built_in">available</span>, remaining))</span><br><span class="line">             <span class="built_in">return</span> remaining;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>闭锁则要保持其状态，在这个状态到达终止态之前，所有线程都会被park住，闭锁可以设定初始值，这个值的含义就是这个闭锁需要被countDown()几次，因为每次CountDown是sync.releaseShared(1),而一开始初始值为10的话，那么这个闭锁需要被countDown()十次，才能够将这个初始值减到0，从而释放原子状态，让等待的所有线程通过</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//await时候执行，只查看当前需要countDown数量减为0了，如果为0，说明可以继续执行，否则需要park住，等待countDown次数足够，并且unpark所有等待线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> getState() == <span class="number">0</span>? <span class="number">1</span> : -1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//countDown 时候执行，如果当前countDown数量为0，说明没有线程await，直接返回false而不需要唤醒park住线程，如果不为0，得到剩下需要 countDown的数量并且compareAndSet,最终返回剩下的countDown数量是否为0,供AQS判定是否释放所有await线程。</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         <span class="keyword">int</span> c = getState();</span><br><span class="line">         <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">int</span> nextc = c<span class="number">-1</span>;</span><br><span class="line">         <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">             <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>需要记录任务的执行状态，当调用其实例的get方法时,内部类Sync会去调用AQS的acquireSharedInterruptibly()方法，而这个方法会反向调用Sync实现的tryAcquireShared()方法，即让具体实现类决定是否让当前线程继续还是park,而FutureTask的tryAcquireShared方法所做的唯一事情就是检查状态，如果是RUNNING状态那么让当前线程park。而跑任务的线程会在任务结束时调用FutureTask 实例的set方法（与等待线程持相同的实例），设定执行结果，并且通过unpark唤醒正在等待的线程，返回结果</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get时待用，只检查当前任务是否完成或者被Cancel，如果未完成并且没有被cancel，那么告诉AQS当前线程需要进入等待队列并且park住</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> ignore)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> innerIsDone()? <span class="number">1</span> : -1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//判定任务是否完成或者被Cancel</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">innerIsDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ranOrCancelled(getState()) &amp;&amp;    runner == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//get时调用，对于CANCEL与其他异常进行抛错</span></span><br><span class="line"><span class="function">V <span class="title">innerGet</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquireSharedNanos(<span class="number">0</span>,nanosTimeout))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">    <span class="keyword">if</span> (getState() == CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(exception);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//任务的执行线程执行完毕调用（set(V v)）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">innerSet</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = getState();</span><br><span class="line">        <span class="comment">//如果线程任务已经执行完毕，那么直接返回（多线程执行任务？）</span></span><br><span class="line">        <span class="keyword">if</span> (s == RAN)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果被CANCEL了，那么释放等待线程，并且会抛错</span></span><br><span class="line">        <span class="keyword">if</span> (s == CANCELLED) &#123;</span><br><span class="line">            releaseShared(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">        <span class="comment">//如果成功设定任务状态为已完成，那么设定结果，unpark等待线程(调用get()方法而阻塞的线程),以及后续清理工作（一般由FutrueTask的子类实现）</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(s, RAN)) &#123;</span><br><span class="line">            result = v;</span><br><span class="line">            releaseShared(<span class="number">0</span>);</span><br><span class="line">            done();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><p>Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否锁定状态</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试获取资源，立即返回。成功则返回true，否则false。</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// 这里限定只能为1个量</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">//state为0才设置为1，不可重入！</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//设置为当前线程独占资源</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试释放资源，立即返回。成功则为true，否则false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// 限定为1个量</span></span><br><span class="line">    <span class="keyword">if</span> (getState() == <span class="number">0</span>)<span class="comment">//既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(<span class="number">0</span>);<span class="comment">//释放资源，放弃占有状态</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p><a href="https://blog.csdn.net/javazejian/article/details/75043422#aqs%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%A6%82%E8%A6%81" target="_blank" rel="noopener">深入剖析基于并发AQS的(独占锁)重入锁(ReetrantLock)及其Condition实现原理</a><br><a href="https://blog.csdn.net/javazejian/article/details/76167357" target="_blank" rel="noopener">剖析基于并发AQS的共享锁的实现(基于信号量Semaphore)</a><br><a href="https://blog.csdn.net/vernonzheng/article/details/8275624" target="_blank" rel="noopener">Java多线程（七）之同步器基础：AQS框架深入分析</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-jtp04186/" target="_blank" rel="noopener">非阻塞算法简介</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      AQS定义了一套多线程访问共享资源的同步器框架，是整个java.util.concurrent包的基石
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>KMP</title>
    <link href="http://yoursite.com/2018/08/30/KMP/"/>
    <id>http://yoursite.com/2018/08/30/KMP/</id>
    <published>2018-08-29T16:44:12.000Z</published>
    <updated>2018-09-02T14:40:31.120Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h1><p>字符串组成为</p><script type="math/tex; mode=display">p_0...p_k...p_i...p_{i+k}...p_j...p_{j+k}...p_m...p_{m+k}...</script><p>假设\(next_{[i+k]}==next_{[m+k]}\)，表示\(p_0…p_{i+k}=p_j…p_{m+k}\) </p><ul><li>如果\(p_{i+k+1}=p_{m+k+1}\)，则\(next_{[m+k+1]}==next_{[m+k]}+1\) </li><li>如果\(p_{i+k+1}!=p_{m+k+1}\)，有\(next_{[i+k]}=k\)，表示\(p_0…p_{k}=p_i…p_{i+k}=p_m…p_{m+k}\)，<ul><li>如果\(p_{m+k+1}=p_{k+1}\)，则\(next_{[m+k+1]}=next_{[k]}+1\)</li><li>如果\(p_{m+k+1}!=p_{k+1}\)，则有\(next_{[k]}=l\)，继续上面的过程</li></ul></li></ul><p>总结下来，若\(next_{[i]}==next_{[j]}\)</p><ul><li>if \(p_{i+1}=p_{j+1}\), then \(next_{[j+1]}==next_{[j]+1}\)</li><li>else \(i==next_{[i]}\),继续上一步</li></ul><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> KMP &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] getNextArr(<span class="keyword">char</span>[] pattern) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pattern == <span class="keyword">null</span> || pattern.length == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] <span class="keyword">next</span> = <span class="keyword">new</span> <span class="keyword">int</span>[pattern.length];</span><br><span class="line">    <span class="keyword">next</span>[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">next</span>[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> currentNext=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos &lt; pattern.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pattern[pos - <span class="number">1</span>] == pattern[currentNext]) &#123;</span><br><span class="line">        <span class="keyword">next</span>[pos++] = ++currentNext;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentNext &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        currentNext = <span class="keyword">next</span>[currentNext];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">next</span>[pos++] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> getIndexOf(String ori, String pattern) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ori.length() &lt; pattern.length()) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] oriArr = ori.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] patternArr = pattern.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> indexOfOri = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> indexOfPattern = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] <span class="keyword">next</span> = getNextArr(patternArr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (indexOfOri &lt; oriArr.length &amp;&amp; indexOfPattern &lt; patternArr.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oriArr[indexOfOri] == patternArr[indexOfPattern]) &#123;</span><br><span class="line">        indexOfOri++;</span><br><span class="line">        indexOfPattern++;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">next</span>[indexOfPattern] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        indexOfPattern = <span class="keyword">next</span>[indexOfPattern];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        indexOfOri++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> indexOfPattern == patternArr.length ? indexOfOri - indexOfPattern : -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      KMP算法
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串匹配" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>内存屏障</title>
    <link href="http://yoursite.com/2018/08/23/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"/>
    <id>http://yoursite.com/2018/08/23/内存屏障/</id>
    <published>2018-08-23T15:15:18.000Z</published>
    <updated>2018-08-23T17:20:20.571Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="内存屏障的目的"><a href="#内存屏障的目的" class="headerlink" title="内存屏障的目的"></a>内存屏障的目的</h1><p>每个CPU都会有自己的缓存（有的甚至L1,L2,L3），缓存的目的就是为了提高性能，避免每次都要向内存取。但是这样的弊端也很明显：不能实时的和内存发生信息交换，分在不同CPU执行的不同线程对同一个变量的缓存值不同</p><h1 id="内存屏障的作用"><a href="#内存屏障的作用" class="headerlink" title="内存屏障的作用"></a>内存屏障的作用</h1><p>硬件层的内存屏障分为两种：Load Barrier 和 Store Barrier即读屏障和写屏障</p><ul><li>对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据</li><li>对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见</li></ul><p>内存屏障有两个作用</p><ul><li>阻止屏障两侧的指令重排序</li><li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效</li></ul><h1 id="java内存屏障"><a href="#java内存屏障" class="headerlink" title="java内存屏障"></a>java内存屏障</h1><p>内存屏障可以被分为以下几种类型:</p><ul><li><code>LoadLoad屏障</code>：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li><li><code>StoreStore屏障</code>：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li><li><code>LoadStore屏障</code>：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li><li><code>StoreLoad屏障</code>：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</li></ul><h1 id="volatile语义中的内存屏障"><a href="#volatile语义中的内存屏障" class="headerlink" title="volatile语义中的内存屏障"></a>volatile语义中的内存屏障</h1><p>volatile的内存屏障策略非常严格、悲观</p><ul><li>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障</li><li>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障</li></ul><p>volatile重排序规则：</p><ul><li>volatile写与之前的读写不能重排序</li><li>volatile读与之后的读写不能重排序</li><li>相邻的volatile之间不能重排序</li></ul><p><img src="/images/reordering-table.png"></p><p>volatile内存屏障规则：</p><ul><li>volatile写之前，所有的读写都必须已经完成</li><li>volatile读结束后，所有的读写才能开始</li><li>相邻的volatile必须有序实行</li></ul><p><img src="/images/fences-table.png"></p><h1 id="final语义中的内存屏障"><a href="#final语义中的内存屏障" class="headerlink" title="final语义中的内存屏障"></a>final语义中的内存屏障</h1><ul><li><p>新建对象过程中，构造体中对final域的初始化写入和这个对象赋值给其他引用变量，这两个操作不能重排序</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x.<span class="attr">finalField</span> = v; ... ;构建方法边界<span class="attr">sharedRef</span> = x;</span><br><span class="line">v.<span class="attr">afield</span> = <span class="number">1</span>; x.<span class="attr">finalField</span> = v; ... ; 构建方法边界<span class="attr">sharedRef</span> = x;</span><br><span class="line">这两条语句中，构建方法边界前后的指令都不能重排序。</span><br></pre></td></tr></table></figure></li><li><p>初次读包含final域的对象引用和读取这个final域，这两个操作不能重排序</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">x</span> = sharedRef<span class="comment">; ... ; i = x.finalField;</span></span><br></pre></td></tr></table></figure></li><li><p>为了保证final字段的特殊语义，也会在下面的语句加入内存屏障</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.<span class="attr">finalField</span> = v; StoreStore; <span class="attr">sharedRef</span> = x;</span><br></pre></td></tr></table></figure></li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://www.jianshu.com/p/2ab5e3d7e510" target="_blank" rel="noopener">内存屏障</a></li><li><a href="https://www.cnblogs.com/chenyangyao/p/5269622.html" target="_blank" rel="noopener">JVM内存模型、指令重排、内存屏障概念解析</a></li><li><a href="https://blog.csdn.net/coslay/article/details/41955899" target="_blank" rel="noopener">java内存模型 内存屏障</a></li></ul>]]></content>
    
    <summary type="html">
    
      内存屏障原理解析
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java内存模型" scheme="http://yoursite.com/tags/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>volatile</title>
    <link href="http://yoursite.com/2018/08/23/volatile/"/>
    <id>http://yoursite.com/2018/08/23/volatile/</id>
    <published>2018-08-23T12:54:28.000Z</published>
    <updated>2018-08-23T17:20:24.513Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><p>volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值</p><p><code>线程写volatile变量的过程</code></p><ul><li>改变线程工作内存中volatile变量副本的值</li><li>将改变后的副本的值从工作内存刷新到主内存</li></ul><p><code>线程读volatile变量的过程</code></p><ul><li>从主内存中读取volatile变量的最新值到线程的工作内存中</li><li>从工作内存中读取volatile变量的副本</li></ul><h3 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h3><p>多线程版本(错误的)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> Helper helper = <span class="keyword">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Helper <span class="title">getHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (helper == <span class="keyword">null</span>) </span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (helper == <span class="keyword">null</span>) </span><br><span class="line">          helper = <span class="keyword">new</span> Helper();</span><br><span class="line">      &#125;    </span><br><span class="line">    <span class="keyword">return</span> helper;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// other functions and members...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>volatile关键字修改版<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Helper helper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Helper <span class="title">getHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (helper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (helper == <span class="keyword">null</span>)</span><br><span class="line">                    helper = <span class="keyword">new</span> Helper();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在给helper对象初始化的过程中，jvm做了下面3件事:</p><ul><li>给helper对象分配内存</li><li>调用构造函数</li><li>将helper对象指向分配的内存空间</li></ul><p>由于jvm的”优化”,指令2和指令3的执行顺序是不一定的，当执行完指定3后，此时的helper对象就已经不在是null的了,但此时指令2不一定已经被执行。</p><p>假设线程1和线程2同时调用getHelper()方法，此时线程1执行完指令1和指令3，线程2抢到了执行权，此时helper对象是非空的</p><ul><li>volatile关键字可以保证jvm执行的一定的“有序性”，在指令1和指令2执行完之前，指定3一定不会被执行</li><li>volatile变量被修改后立刻刷新会驻内存中</li></ul><h3 id="不保证复合操作的原子性"><a href="#不保证复合操作的原子性" class="headerlink" title="不保证复合操作的原子性"></a>不保证复合操作的原子性</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        final Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        System.<span class="keyword">out</span>.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程A读取最新的值并在工作内存修改后，还未更新到主存就耗尽cpu时间片，等再次获取时间片后主存的变量值已被线程B修改，但线程A并未感知，继续将值更新到主存，导致B的修改无效</p>]]></content>
    
    <summary type="html">
    
      volatile原理解析
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>hexo高级特性</title>
    <link href="http://yoursite.com/2018/08/19/cool/"/>
    <id>http://yoursite.com/2018/08/19/cool/</id>
    <published>2018-08-19T08:35:51.000Z</published>
    <updated>2018-08-29T17:22:41.544Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="网易云"><a href="#网易云" class="headerlink" title="网易云"></a>网易云</h1><h2 id="通过外链添加"><a href="#通过外链添加" class="headerlink" title="通过外链添加"></a>通过外链添加</h2><p>在网易云音乐的网页版生成歌单外链</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe <span class="attribute">frameborder</span>=<span class="string">"no"</span> <span class="attribute">border</span>=<span class="string">"0"</span> <span class="attribute">marginwidth</span>=<span class="string">"0"</span> <span class="attribute">marginheight</span>=<span class="string">"0"</span> <span class="attribute">width</span>=330 <span class="attribute">height</span>=450 <span class="attribute">src</span>=<span class="string">"//music.163.com/outchain/player?type=0&amp;id=2343741251&amp;auto=1&amp;height=430"</span>&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="450" src="//music.163.com/outchain/player?type=0&id=2343741251&auto=1&height=430"></iframe><h2 id="通过aplayer插件"><a href="#通过aplayer插件" class="headerlink" title="通过aplayer插件"></a>通过aplayer插件</h2><p><a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md#meingjs-%E6%94%AF%E6%8C%81-30-%E6%96%B0%E5%8A%9F%E8%83%BD" target="_blank" rel="noopener">MeingJS 支持</a><br>id为网页上url后面的id值<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% meting <span class="string">"468513829"</span> <span class="string">"netease"</span> <span class="string">"song"</span> <span class="string">"autoplay"</span> <span class="string">"mutex: true"</span> <span class="string">"listmaxheight:340px"</span> <span class="string">"preload:none"</span> <span class="string">"theme:#ad7a86"</span>%&#125;</span><br></pre></td></tr></table></figure></p>    <div id="aplayer-vZOWQWQS" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="468513829" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="none" data-theme="#ad7a86"></div><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% meting <span class="string">"384485381"</span> <span class="string">"netease"</span> <span class="string">"playlist"</span> <span class="string">"autoplay"</span> <span class="string">"mutex: true"</span> <span class="string">"listmaxheight:340px"</span> <span class="string">"preload:none"</span> <span class="string">"theme:#ad7a86"</span>%&#125;</span><br></pre></td></tr></table></figure>    <div id="aplayer-rtbKMEMj" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="60198" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="340px" data-preload="none" data-theme="#ad7a86"></div><h2 id="行间公式"><a href="#行间公式" class="headerlink" title="行间公式"></a>行间公式</h2><script type="math/tex; mode=display">f(n)=\begin{cases}n/2, & \text{如果$ x<=2 $}\\3n+1, & \text{如果$ x>2 $}\end{cases}</script><h2 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h2><p>比如 \(x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}\)</p>]]></content>
    
    <summary type="html">
    
      测试hexo系统新特性
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="新特性" scheme="http://yoursite.com/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>mysql</title>
    <link href="http://yoursite.com/2018/08/19/mysql/"/>
    <id>http://yoursite.com/2018/08/19/mysql/</id>
    <published>2018-08-19T05:47:35.000Z</published>
    <updated>2018-08-19T05:55:49.435Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="mysql体系结构"><a href="#mysql体系结构" class="headerlink" title="mysql体系结构"></a>mysql体系结构</h2><p><img src="/images/mysql-server.jpg"></p><p><a href="https://www.cnblogs.com/Survivalist/p/7954977.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><div class="table-container"><table><thead><tr><th style="text-align:center">特点</th><th style="text-align:center">MyISAM</th><th style="text-align:center">BDB</th><th style="text-align:center">Memory</th><th style="text-align:center">InnoDB</th><th style="text-align:center">Archive</th></tr></thead><tbody><tr><td style="text-align:center">存储限制</td><td style="text-align:center">没有</td><td style="text-align:center">没有</td><td style="text-align:center">有</td><td style="text-align:center">64TB</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center">事务安全</td><td style="text-align:center"></td><td style="text-align:center">支持</td><td style="text-align:center"></td><td style="text-align:center">支持</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">锁机制</td><td style="text-align:center">表锁</td><td style="text-align:center">页锁</td><td style="text-align:center">表锁</td><td style="text-align:center">行锁</td><td style="text-align:center">行锁</td></tr><tr><td style="text-align:center">B数索引</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">哈希索引</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">全文索引</td><td style="text-align:center">支持</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">集群索引</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">支持</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">数据缓存</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">索引缓存</td><td style="text-align:center">支持</td><td style="text-align:center"></td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">数据可压缩</td><td style="text-align:center">支持</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">空间使用</td><td style="text-align:center">低</td><td style="text-align:center">低</td><td style="text-align:center">N/A</td><td style="text-align:center">高</td><td style="text-align:center">非常低</td></tr><tr><td style="text-align:center">内存使用</td><td style="text-align:center">低</td><td style="text-align:center">低</td><td style="text-align:center">中等</td><td style="text-align:center">高</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">批量插入的速度</td><td style="text-align:center">高</td><td style="text-align:center">高</td><td style="text-align:center">高</td><td style="text-align:center">低</td><td style="text-align:center">非常高</td></tr><tr><td style="text-align:center">支持外键</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">支持</td></tr></tbody></table></div><p><a href="https://blog.csdn.net/len9596/article/details/80206532" target="_blank" rel="noopener">InnoDB与MyISAM原理比较</a></p><p><a href="https://www.cnblogs.com/wangdake-qq/p/7358322.html" target="_blank" rel="noopener">InnoDB与MyISAM索引比较</a></p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h2><h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h3><p><a href="https://blog.csdn.net/mine_song/article/details/63251546" target="_blank" rel="noopener">参考链接</a><br>B树中关键字集合分布在整棵树中，叶节点中不包含任何关键字信息，而B+树关键字集合分布在叶子结点中，非叶节点只是叶子结点中关键字的索引</p><h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><p><a href="https://www.cnblogs.com/heiming/p/5865101.html" target="_blank" rel="noopener">B Tree索引和哈希索引的区别</a></p><p>缺点<br>不支持范围查询和排序、最左匹配规则</p><h3 id="空间-R-Tree-索引"><a href="#空间-R-Tree-索引" class="headerlink" title="空间(R-Tree)索引"></a>空间(R-Tree)索引</h3><p><img src="/images/RTree.jpg"></p><p><a href="https://blog.csdn.net/MongChia1993/article/details/69941783#toc_16" target="_blank" rel="noopener">参考链接</a></p><h3 id="全文-Full-text-索引"><a href="#全文-Full-text-索引" class="headerlink" title="全文(Full-text)索引"></a>全文(Full-text)索引</h3><p>类似es搜索的Lucene分词策略</p><p><a href="https://www.cnblogs.com/itxiongwei/p/7064252.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="索引策略"><a href="#索引策略" class="headerlink" title="索引策略"></a>索引策略</h2><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p><a href="https://blog.csdn.net/john1337/article/details/71081827" target="_blank" rel="noopener">高性能mysql章节</a></p><p>概念<br>使用该列开始的部分长度字符串作</p><p>注意<br>选择足够长的前缀以保证较高的选择性，同时又不能太长以便节约空间</p><p>缺点<br>mysql无法使用其前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描</p><h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p><a href="https://www.cnblogs.com/codeAB/p/6387148.html" target="_blank" rel="noopener">mysql多列索引的生效规则</a></p><h3 id="聚簇索引-Clustered-Indexes-及二级索引-辅助索引"><a href="#聚簇索引-Clustered-Indexes-及二级索引-辅助索引" class="headerlink" title="聚簇索引(Clustered Indexes)及二级索引(辅助索引)"></a>聚簇索引(Clustered Indexes)及二级索引(辅助索引)</h3><p><a href="https://www.linuxidc.com/Linux/2018-02/150809.htm" target="_blank" rel="noopener">高性能mysql章节</a></p><p><a href="https://blog.csdn.net/mine_song/article/details/63251546" target="_blank" rel="noopener">InnoDB与MyISAM的主键索引和二级索引的区别</a></p><ul><li><p>聚集索引<br>表数据按照索引的顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序一致。对于聚集索引，叶子结点即存储了真实的数据行，不再有另外单独的数据页。 在一张表上最多只能创建一个聚集索引，因为真实数据的物理顺序只能有一种</p></li><li><p>非聚集索引<br>表数据存储顺序与索引顺序无关。对于非聚集索引，叶结点包含索引字段值及指向数据页数据行的逻辑指针，其行数量与数据表行数据量一致</p></li></ul><h3 id="覆盖索引-Covering-Indexes"><a href="#覆盖索引-Covering-Indexes" class="headerlink" title="覆盖索引(Covering Indexes)"></a>覆盖索引(Covering Indexes)</h3><p>建立索引的字段正好是覆盖查询语句[select子句]与查询条件[Where子句]中所涉及的字段,数据列只用从索引中就能够取得，不必从数据表中读取<br>参考&lt;&lt;高性能mysql&gt;&gt;</p><p><a href="https://www.cnblogs.com/happyflyingpig/p/7662881.html" target="_blank" rel="noopener">参考链接</a><br><a href="https://www.cnblogs.com/Profound/p/8763022.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="压缩-前缀压缩-索引"><a href="#压缩-前缀压缩-索引" class="headerlink" title="压缩(前缀压缩)索引"></a>压缩(前缀压缩)索引</h3><p><a href="https://blog.csdn.net/yirentianran/article/details/79423908" target="_blank" rel="noopener">参考链接</a></p><h3 id="重复索引"><a href="#重复索引" class="headerlink" title="重复索引"></a>重复索引</h3><p>相同列上按照相同的顺序创建的相同类型的索引    </p><h3 id="冗余索引"><a href="#冗余索引" class="headerlink" title="冗余索引"></a>冗余索引</h3><p>若存在索引(a,b),则(a)是冗余,因为a是前缀,(a,b)可以当成(a)使用;（b,a）和(b)不是冗余索引</p><h3 id="分形树-fractal-treeindex-索引"><a href="#分形树-fractal-treeindex-索引" class="headerlink" title="分形树(fractal treeindex)索引"></a>分形树(fractal treeindex)索引</h3><h3 id="块级别元数据"><a href="#块级别元数据" class="headerlink" title="块级别元数据"></a>块级别元数据</h3><p><img src="/images/ib.png"></p><p><a href="https://blog.csdn.net/hguisu/article/details/11848411" target="_blank" rel="noopener">Infobright高性能数据仓库</a></p><h1 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h1><h2 id="explain关键字"><a href="#explain关键字" class="headerlink" title="explain关键字"></a>explain关键字</h2><p><a href="https://www.cnblogs.com/butterfly100/archive/2018/01/15/8287569.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="查询路径"><a href="#查询路径" class="headerlink" title="查询路径"></a>查询路径</h2><p><img src="/images/mysql-query.png"></p><p><a href="https://www.cnblogs.com/yuyue2014/p/3826941.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p><a href="https://www.cnblogs.com/shengdimaya/p/7123069.html" target="_blank" rel="noopener">join原理</a></p><p>JOIN算法</p><ul><li>Nested-Loop Join<ul><li>Simple Nested-Loop Join</li><li>Index Nested-Loop Join</li><li>Block Nested-Loop Join    </li></ul></li><li>哈希关联</li><li>合并连接</li></ul><h1 id="mysql高级特性"><a href="#mysql高级特性" class="headerlink" title="mysql高级特性"></a>mysql高级特性</h1><h2 id="分库、分区、分表、分片"><a href="#分库、分区、分表、分片" class="headerlink" title="分库、分区、分表、分片"></a>分库、分区、分表、分片</h2><p><a href="http://langonggong.com/2018/07/14/mysql%E5%88%86%E5%BA%93-%E5%88%86%E5%8C%BA-%E5%88%86%E8%A1%A8-%E5%88%86%E7%89%87/" target="_blank" rel="noopener">参考链接</a></p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h2 id="内部存储代码"><a href="#内部存储代码" class="headerlink" title="内部存储代码"></a>内部存储代码</h2><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><h3 id="绑定变量"><a href="#绑定变量" class="headerlink" title="绑定变量"></a>绑定变量</h3><h3 id="XA"><a href="#XA" class="headerlink" title="XA"></a>XA</h3><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><h1 id="mvcc与锁"><a href="#mvcc与锁" class="headerlink" title="mvcc与锁"></a>mvcc与锁</h1><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p><a href="https://www.cnblogs.com/chenpingzhao/p/5065316.html" target="_blank" rel="noopener">原理</a></p><h3 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h3><h3 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h3><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><h3 id="Read-Uncommited"><a href="#Read-Uncommited" class="headerlink" title="Read Uncommited"></a>Read Uncommited</h3><h3 id="Read-Committed-RC"><a href="#Read-Committed-RC" class="headerlink" title="Read Committed (RC)"></a>Read Committed (RC)</h3><h3 id="Repeatable-Read-RR"><a href="#Repeatable-Read-RR" class="headerlink" title="Repeatable Read (RR)"></a>Repeatable Read (RR)</h3><h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><h2 id="InnoDB两种类型的行锁"><a href="#InnoDB两种类型的行锁" class="headerlink" title="InnoDB两种类型的行锁"></a>InnoDB两种类型的行锁</h2><h3 id="共享锁（S）—读锁"><a href="#共享锁（S）—读锁" class="headerlink" title="共享锁（S）—读锁"></a>共享锁（S）—读锁</h3><h3 id="排他锁（X）—写锁"><a href="#排他锁（X）—写锁" class="headerlink" title="排他锁（X）—写锁"></a>排他锁（X）—写锁</h3><h2 id="行锁的三种情形"><a href="#行锁的三种情形" class="headerlink" title="行锁的三种情形"></a>行锁的三种情形</h2><h3 id="Record-lock"><a href="#Record-lock" class="headerlink" title="Record lock"></a>Record lock</h3><h3 id="Gap-lock"><a href="#Gap-lock" class="headerlink" title="Gap lock"></a>Gap lock</h3><h3 id="Next-key-Lock"><a href="#Next-key-Lock" class="headerlink" title="Next-key Lock"></a>Next-key Lock</h3><h2 id="InnoDB表锁"><a href="#InnoDB表锁" class="headerlink" title="InnoDB表锁"></a>InnoDB表锁</h2><h3 id="意向共享锁（IS）"><a href="#意向共享锁（IS）" class="headerlink" title="意向共享锁（IS）"></a>意向共享锁（IS）</h3><h3 id="意向排他锁（IX）"><a href="#意向排他锁（IX）" class="headerlink" title="意向排他锁（IX）"></a>意向排他锁（IX）</h3><h2 id="InnoDB页面锁"><a href="#InnoDB页面锁" class="headerlink" title="InnoDB页面锁"></a>InnoDB页面锁</h2>]]></content>
    
    <summary type="html">
    
      《高性能mysql》读书笔记
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="DB" scheme="http://yoursite.com/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>spring cloud</title>
    <link href="http://yoursite.com/2018/08/19/springcloud/"/>
    <id>http://yoursite.com/2018/08/19/springcloud/</id>
    <published>2018-08-19T05:12:12.000Z</published>
    <updated>2018-08-19T05:46:13.326Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p><img src="/images/spring-cloud-architecture.png"></p><h2 id="四大神器"><a href="#四大神器" class="headerlink" title="四大神器"></a>四大神器</h2><ul><li>auto-configuration</li><li>starters<br>  <img src="/images/spring-cloud-stater.png"></li><li>cli：Spring Boot Commad Line    </li><li>Autuator监控</li></ul><h1 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h1><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p><img src="/images/aws-eureka.png"></p><p><a href="https://luyiisme.github.io/2017/04/22/spring-cloud-service-discovery-products/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">参考链接</a></p><div class="table-container"><table><thead><tr><th style="text-align:center">Feature</th><th style="text-align:center">Consul</th><th style="text-align:center">zookeeper</th><th style="text-align:center">etcd</th><th style="text-align:center">Eureka</th></tr></thead><tbody><tr><td style="text-align:center">服务健康检查</td><td style="text-align:center">服务状态，内存，硬盘等</td><td style="text-align:center">(弱)长连接，keepalive</td><td style="text-align:center">连接心跳</td><td style="text-align:center">可配支持</td></tr><tr><td style="text-align:center">多数据中心</td><td style="text-align:center">支持</td><td style="text-align:center">—</td><td style="text-align:center">—</td><td style="text-align:center">—</td></tr><tr><td style="text-align:center">kv存储服务</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">—</td></tr><tr><td style="text-align:center">一致性</td><td style="text-align:center">raft</td><td style="text-align:center">paxos</td><td style="text-align:center">raft</td><td style="text-align:center">—</td></tr><tr><td style="text-align:center">cap</td><td style="text-align:center">ca</td><td style="text-align:center">cp</td><td style="text-align:center">cp</td><td style="text-align:center">ap</td></tr><tr><td style="text-align:center">使用接口(多语言能力)</td><td style="text-align:center">支持http和dns</td><td style="text-align:center">客户端</td><td style="text-align:center">http/grpc</td><td style="text-align:center">http（sidecar）</td></tr><tr><td style="text-align:center">watch支持</td><td style="text-align:center">全量/支持long polling    支持</td><td style="text-align:center">支持</td><td style="text-align:center">long polling</td><td style="text-align:center">支持 long polling/大部分增量</td></tr><tr><td style="text-align:center">自身监控</td><td style="text-align:center">metrics</td><td style="text-align:center">—</td><td style="text-align:center">metrics</td><td style="text-align:center">metrics</td></tr><tr><td style="text-align:center">安全</td><td style="text-align:center">acl /https</td><td style="text-align:center">acl    https支持（弱）</td><td style="text-align:center">—</td></tr><tr><td style="text-align:center">spring cloud集成</td><td style="text-align:center">已支持</td><td style="text-align:center">已支持</td><td style="text-align:center">已支持</td><td style="text-align:center">已支持</td></tr></tbody></table></div><h2 id="CAP理论与BASE思想"><a href="#CAP理论与BASE思想" class="headerlink" title="CAP理论与BASE思想"></a>CAP理论与BASE思想</h2><h2 id="服务发现的方式"><a href="#服务发现的方式" class="headerlink" title="服务发现的方式"></a>服务发现的方式</h2><ul><li>客户端发现<br><img src="/images/client-find.png"></li><li>服务器端发现<br><img src="/images/server-find.png"></li></ul><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><h2 id="LB方案"><a href="#LB方案" class="headerlink" title="LB方案"></a>LB方案</h2><p><a href="https://www.cnblogs.com/mindwind/p/5339657.html" target="_blank" rel="noopener">参考链接1</a></p><p><a href="https://www.cnblogs.com/LittleHann/p/3963255.html" target="_blank" rel="noopener">参考链接2</a></p><p><img src="/images/lb-whole.jpg"></p><ul><li>硬负载</li><li>软负载</li><li>DNS负载</li><li>CDN负载</li></ul><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p><strong>核心组件</strong></p><ul><li>ServerList<br>  用于获取地址列表。它既可以是静态的(提供一组固定的地址)，也可以是动态的(从注册中心中定期查询地址列表)    </li><li>ServerListFilter<br>  仅当使用动态ServerList时使用，用于在原始的服务列表中使用一定策略过虑掉一部分地址    </li><li>IRule<br>  选择一个最终的服务地址作为LB结果。选择策略有轮询、根据响应时间加权、断路器(当Hystrix可用时)等    </li></ul><h1 id="rest调用"><a href="#rest调用" class="headerlink" title="rest调用"></a>rest调用</h1><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><h1 id="容错处理"><a href="#容错处理" class="headerlink" title="容错处理"></a>容错处理</h1><p><a href="http://blog.51cto.com/developerycj/1950881" target="_blank" rel="noopener">参考链接1</a><br><a href="https://www.cnblogs.com/leeSmall/p/8847652.html" target="_blank" rel="noopener">参考链接2</a></p><h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><ul><li>限流</li><li>降级</li><li>熔断</li></ul><h2 id="Dashboard-服务监控"><a href="#Dashboard-服务监控" class="headerlink" title="Dashboard 服务监控"></a>Dashboard 服务监控</h2><h2 id="Turbine-聚合监控"><a href="#Turbine-聚合监控" class="headerlink" title="Turbine 聚合监控"></a>Turbine 聚合监控</h2><h1 id="微服务网关"><a href="#微服务网关" class="headerlink" title="微服务网关"></a>微服务网关</h1><h2 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h2><h3 id="过滤器机制"><a href="#过滤器机制" class="headerlink" title="过滤器机制"></a>过滤器机制</h3><p><img src="/images/zuul-filter.png"></p><h3 id="标准过滤器类型"><a href="#标准过滤器类型" class="headerlink" title="标准过滤器类型"></a>标准过滤器类型</h3><ul><li>PRE<ul><li>鉴权</li><li>流量转发</li></ul></li><li>ROUTING</li><li>POST<ul><li>跨域</li><li>统计</li></ul></li><li>ERROR</li></ul><h3 id="request生命周期"><a href="#request生命周期" class="headerlink" title="request生命周期"></a>request生命周期</h3><p><img src="/images/zuul-filter-lifecyle.png"></p><p><a href="http://www.scienjus.com/api-gateway-and-netflix-zuul/#Netflix-Zuul" target="_blank" rel="noopener">参考链接1</a></p><p><a href="https://www.cnblogs.com/lexiaofei/p/7080257.html" target="_blank" rel="noopener">参考链接2</a></p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><ul><li>隔离机制</li><li>重试机制</li></ul><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul><li>验证与安全保障</li><li>审查与监控</li><li>动态路由</li><li>压力测试</li><li>负载分配</li><li>静态响应处理</li><li>多区域弹性</li></ul><h1 id="微服务配置"><a href="#微服务配置" class="headerlink" title="微服务配置"></a>微服务配置</h1><h2 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h2><p><img src="/images/spring-cloud-config.png"></p><h2 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h2><p><img src="/images/configbus2.jpg"></p><p><a href="https://www.cnblogs.com/ityouknow/p/6931958.html" target="_blank" rel="noopener">参考链接</a></p><ul><li>提交代码触发post请求给bus/refresh</li><li>server端接收到请求并发送给Spring Cloud Bus</li><li>Spring Cloud bus接到消息并通知给其它客户端</li><li>其它客户端接收到通知，请求Server端获取最新配置</li><li>全部客户端均获取到最新的配置</li></ul><h1 id="微服务跟踪"><a href="#微服务跟踪" class="headerlink" title="微服务跟踪"></a>微服务跟踪</h1><h2 id="Spring-Cloud-Sleuth"><a href="#Spring-Cloud-Sleuth" class="headerlink" title="Spring Cloud Sleuth"></a>Spring Cloud Sleuth</h2><h2 id="ZipKin"><a href="#ZipKin" class="headerlink" title="ZipKin"></a>ZipKin</h2><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2>]]></content>
    
    <summary type="html">
    
      微服务概念学习
    
    </summary>
    
      <category term="spring" scheme="http://yoursite.com/categories/spring/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="spring cloud" scheme="http://yoursite.com/tags/spring-cloud/"/>
    
      <category term="网关" scheme="http://yoursite.com/tags/%E7%BD%91%E5%85%B3/"/>
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>java-concurrency</title>
    <link href="http://yoursite.com/2018/08/19/java-concurrency/"/>
    <id>http://yoursite.com/2018/08/19/java-concurrency/</id>
    <published>2018-08-19T04:48:15.000Z</published>
    <updated>2018-08-19T05:07:22.078Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="concurrent包"><a href="#concurrent包" class="headerlink" title="concurrent包"></a>concurrent包</h1><p><img src="/images/concurrent-package.png"></p><h2 id="locks-锁"><a href="#locks-锁" class="headerlink" title="locks(锁)"></a>locks(锁)</h2><p><img src="/images/locks.png"></p><h3 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h3><p><a href="http://www.importnew.com/19472.html" target="_blank" rel="noopener">锁分类1</a><br><a href="https://www.cnblogs.com/qifengshi/p/6831055.html" target="_blank" rel="noopener">锁分类2</a></p><ul><li>公平锁/非公平锁</li><li>可重入锁</li><li>可中断锁</li><li>独享锁/共享锁</li><li>互斥锁/读写锁</li><li>乐观锁/悲观锁</li><li>分段锁</li><li>偏向锁/轻量级锁/重量级锁</li><li>自旋锁</li></ul><h3 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h3><p><a href="https://my.oschina.net/hosee/blog/615865" target="_blank" rel="noopener">锁的优化</a></p><ul><li>减少锁持有时间</li><li>减小锁粒度</li><li>锁分离</li><li>锁粗化</li><li>锁消除</li></ul><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>参考链接<br><a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">参考1</a><br><a href="https://segmentfault.com/a/1190000008471362" target="_blank" rel="noopener">参考2</a><br><a href="https://blog.csdn.net/javazejian/article/details/75043422" target="_blank" rel="noopener">AQS、ReetrantLock、Condition实现原理</a></p><p>重要方法:        </p><ul><li>isHeldExclusively()</li><li>tryAcquire(int)</li><li>tryRelease(int)</li><li>tryAcquireShared(int)</li><li>tryReleaseShared(int)</li></ul><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>参考链接<br><a href="https://www.cnblogs.com/aishangJava/p/6555291.html" target="_blank" rel="noopener">参考1</a><br><a href="https://www.cnblogs.com/dolphin0520/p/3923167.html" target="_blank" rel="noopener">参考2</a></p><p>重要方法</p><ul><li>lock()</li><li>lockInterruptibly() throws InterruptedException</li><li>tryLock()</li><li>tryLock(long time, TimeUnit unit) throws InterruptedException</li><li>unlock()</li><li>Condition newCondition()</li></ul><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p><img src="/images/ReentrantLock.gif"></p><p>参考链接<br>    <a href="https://www.cnblogs.com/onlywujun/articles/3531568.html" target="_blank" rel="noopener">参考1</a></p><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p><img src="/images/ReentrantReadWriteLock.jpg"></p><p>参考链接<br><a href="https://www.cnblogs.com/skywang12345/p/3505809.html" target="_blank" rel="noopener">参考1</a><br><a href="https://www.cnblogs.com/grefr/p/6094922.html" target="_blank" rel="noopener">参考2</a></p><h3 id="condition"><a href="#condition" class="headerlink" title="condition"></a>condition</h3><p><a href="https://blog.csdn.net/bohu83/article/details/51098106" target="_blank" rel="noopener">参考链接</a></p><p><a href="https://www.cnblogs.com/Ming8006/p/7243858.html" target="_blank" rel="noopener">生产者、消费者三种实现</a></p><h2 id="atomic-原子变量"><a href="#atomic-原子变量" class="headerlink" title="atomic(原子变量)"></a>atomic(原子变量)</h2><ul><li>AtomicInteger</li><li>AtomicLong</li><li>AtomicBoolean</li><li>AtomicReference</li><li>AtomicIntegerArray/AtomicLongArray/AtomicReferenceArray</li></ul><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h2 id="executor-线程池"><a href="#executor-线程池" class="headerlink" title="executor(线程池)"></a>executor(线程池)</h2><h3 id="框架类图"><a href="#框架类图" class="headerlink" title="框架类图"></a>框架类图</h3><p><img src="/images/Executor.png"></p><ul><li><p><strong>ThreadPoolExecutor</strong></p><p>  <a href="https://blog.csdn.net/qq_25806863/article/details/71126867" target="_blank" rel="noopener">构造方法和规则</a></p><p>  <a href="http://www.cnblogs.com/trust-freedom/p/6681948.html" target="_blank" rel="noopener">执行原理</a></p><p>  <a href="http://www.cnblogs.com/trust-freedom/p/6693601.html" target="_blank" rel="noopener">线程池终止</a></p><p>  关键参数</p><ul><li>workQueue(排队策略)</li><li>threadFactory</li><li><p>RejectedExecutionHandler(饱和策略)</p><p>常用方法</p></li></ul></li><li><p><strong>Executors</strong></p><p>  创建线程池</p><ul><li>newFixedThreadPool</li><li>newCachedThreadPool</li><li>newSingleThreadExecutor</li><li>newScheduledThreadPool</li></ul></li></ul><h2 id="collections-并发容器"><a href="#collections-并发容器" class="headerlink" title="collections(并发容器)"></a>collections(并发容器)</h2><h3 id="List和Set"><a href="#List和Set" class="headerlink" title="List和Set"></a>List和Set</h3><p><img src="/images/list&set.jpg"></p><ul><li><p>CopyOnWriteArrayList    </p><p>  <a href="http://www.cnblogs.com/skywang12345/p/3498483.html" target="_blank" rel="noopener">参考1</a></p></li><li><p>CopyOnWriteArraySet</p><p>  <a href="http://www.cnblogs.com/skywang12345/p/3498497.html" target="_blank" rel="noopener">参考1</a></p></li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><img src="/images/map.jpg"></p><ul><li><p>ConcurrentHashMap</p><p>  <a href="http://www.cnblogs.com/skywang12345/p/3498537.html" target="_blank" rel="noopener">参考</a></p></li><li><p>ConcurrentSkipListMap</p><p>  <a href="http://www.cnblogs.com/skywang12345/p/3498556.html" target="_blank" rel="noopener">参考</a></p></li><li><p>ConcurrentSkipListSet</p></li></ul><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p><img src="/images/queue.jpg"></p><ul><li><p>ArrayBlockingQueue</p>  <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure><p>  notEmpty和notFull是锁的两个Condition条件<br>  <a href="https://blog.csdn.net/javazejian/article/details/77410889" target="_blank" rel="noopener">实现原理</a></p></li><li><p>LinkedBlockingQueue</p></li><li>LinkedBlockingDeque</li><li>ConcurrentLinkedQueue</li><li>ConcurrentLinkedDeque</li></ul><h2 id="tools-同步工具"><a href="#tools-同步工具" class="headerlink" title="tools(同步工具)"></a>tools(同步工具)</h2><ul><li>CountDownLatch</li><li>CyclicBarrier</li><li>Semaphore</li></ul><h1 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h1><p><a href="https://blog.csdn.net/javazejian/article/details/72772461" target="_blank" rel="noopener">java内存模型</a><br><a href="https://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="noopener">synchronized原理</a></p><h2 id="内存模型概述"><a href="#内存模型概述" class="headerlink" title="内存模型概述"></a>内存模型概述</h2><p><img src="/images/jmm-summary.png"></p><ul><li>主内存</li><li>工作内存</li></ul><h2 id="Java内存模型与硬件内存架构的关系"><a href="#Java内存模型与硬件内存架构的关系" class="headerlink" title="Java内存模型与硬件内存架构的关系"></a>Java内存模型与硬件内存架构的关系</h2><p><img src="/images/jmm-hardware.png"></p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>原子性</li><li>可见性</li><li>有序性</li></ul><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><ul><li>指令重排</li><li>编译器重排</li></ul><h2 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h2><h2 id="happens-before-原则"><a href="#happens-before-原则" class="headerlink" title="happens-before 原则"></a>happens-before 原则</h2><ul><li>程序顺序原则</li><li>锁规则</li><li>volatile规则</li><li>线程启动规则</li><li>传递性</li><li>线程终止规则</li><li>线程中断规则</li><li>对象终结规则</li></ul><h2 id="volatile内存语义"><a href="#volatile内存语义" class="headerlink" title="volatile内存语义"></a>volatile内存语义</h2><ul><li>可见性</li><li>禁止重排优化</li></ul><h2 id="内存屏障（Memory-Barrier）"><a href="#内存屏障（Memory-Barrier）" class="headerlink" title="内存屏障（Memory Barrier）"></a>内存屏障（Memory Barrier）</h2><p><a href="http://ifeve.com/jmm-cookbook-mb/" target="_blank" rel="noopener">参考链接</a></p><ul><li>LoadLoad Barriers</li><li>StoreStore  Barriers</li><li>LoadStore Barriers</li><li>StoreLoad Barriers</li></ul>]]></content>
    
    <summary type="html">
    
      Java Concurrency in Practice读书笔记
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch常用搜索</title>
    <link href="http://yoursite.com/2018/08/19/Elasticsearch/"/>
    <id>http://yoursite.com/2018/08/19/Elasticsearch/</id>
    <published>2018-08-19T04:41:41.000Z</published>
    <updated>2018-08-19T04:46:28.128Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="多字段查找"><a href="#多字段查找" class="headerlink" title="多字段查找"></a>多字段查找</h2><p><code>multi_match</code>        </p><p>以下表达式等价于<code>field1 = value1 or field2 = value1</code></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET <span class="built_in">index</span>/<span class="built_in">type</span>/_<span class="built_in">search</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span><span class="symbol">:</span> &#123;</span><br><span class="line">    <span class="string">"multi_match"</span><span class="symbol">:</span> &#123;</span><br><span class="line">      <span class="string">"query"</span><span class="symbol">:</span> <span class="string">"value1"</span>,</span><br><span class="line">      <span class="string">"fields"</span><span class="symbol">:</span> [<span class="string">"field1"</span>,<span class="string">"field2"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  , <span class="string">"_source"</span><span class="symbol">:</span> [<span class="string">"field1"</span>,<span class="string">"field2"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="布尔查询"><a href="#布尔查询" class="headerlink" title="布尔查询"></a>布尔查询</h2><p><code>must</code>等价于<code>and</code>,<code>must_not</code>等价于<code>not</code>,    <code>should</code>等价于<code>or</code>        </p><p>以下表达式等价于<code>( field1 = value1 or field2 = value2 ) and field3 != value3</code></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">GET index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"size"</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"bool"</span>: &#123;</span><br><span class="line">      <span class="string">"must"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"bool"</span>: &#123;</span><br><span class="line">            <span class="string">"should"</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="string">"match"</span>: &#123;</span><br><span class="line">                  <span class="string">"field1"</span>: <span class="string">"value1"</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="string">"match"</span>: &#123;</span><br><span class="line">                  <span class="string">"field2"</span>: <span class="string">"value2"</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">"must_not"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"match"</span>: &#123;</span><br><span class="line">            <span class="string">"field3"</span>: <span class="string">"value3"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"_source"</span>: [</span><br><span class="line">    <span class="string">"field1"</span>,<span class="string">"field2"</span>,<span class="string">"field3"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p><code>fuzziness</code></p><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/languages.html" target="_blank" rel="noopener">参考链接</a></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">GET index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"size"</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"bool"</span>: &#123;</span><br><span class="line">      <span class="string">"must"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"match"</span>: &#123;</span><br><span class="line">            <span class="string">"city"</span>: &#123;</span><br><span class="line">              <span class="string">"query"</span>: <span class="string">"Hoiliste"</span>,</span><br><span class="line">              <span class="string">"fuzziness"</span>: <span class="string">"auto"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"_source"</span>: [</span><br><span class="line">    <span class="string">"city"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通配符查询"><a href="#通配符查询" class="headerlink" title="通配符查询"></a>通配符查询</h2><p><code>*</code>匹配零个或多个字符</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GET index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"size"</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"bool"</span>: &#123;</span><br><span class="line">      <span class="string">"must"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"wildcard"</span>: &#123;</span><br><span class="line">            <span class="string">"field1"</span>: &#123;</span><br><span class="line">              <span class="string">"value"</span>: <span class="string">"wu*"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"_source"</span>: [</span><br><span class="line">    <span class="string">"field1"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正则查询"><a href="#正则查询" class="headerlink" title="正则查询"></a>正则查询</h2><p><code>regexp</code></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET <span class="built_in">index</span>/<span class="built_in">type</span>/_<span class="built_in">search</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"size"</span><span class="symbol">:</span> <span class="number">100</span>,</span><br><span class="line">  <span class="string">"query"</span><span class="symbol">:</span> &#123;</span><br><span class="line">    <span class="string">"regexp"</span><span class="symbol">:</span>&#123;</span><br><span class="line">      <span class="string">"field1"</span><span class="symbol">:</span><span class="string">"[a-zA-Z]+[0-9]*"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"_source"</span><span class="symbol">:</span> [</span><br><span class="line">    <span class="string">"field1"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h2><p><code>range</code></p><figure class="highlight flix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET <span class="keyword">index</span>/<span class="keyword">type</span>/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"size"</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"range"</span>: &#123;</span><br><span class="line">      <span class="string">"field1"</span>: &#123;</span><br><span class="line">        <span class="string">"from"</span>: <span class="string">"2018-04-16 05:22:39"</span>,</span><br><span class="line">        <span class="string">"to"</span>: <span class="string">"2018-06-23 05:22:39"</span>,</span><br><span class="line">        <span class="string">"include_lower"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"include_upper"</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"_source"</span>: [</span><br><span class="line">    <span class="string">"field1"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><code>sort</code></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"size"</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"bool"</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"sort"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"field1"</span>: &#123;</span><br><span class="line">        <span class="string">"order"</span>: <span class="string">"desc"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"_source"</span>: [</span><br><span class="line">    <span class="string">"field1"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多重过滤"><a href="#多重过滤" class="headerlink" title="多重过滤"></a>多重过滤</h2><p><code>filter</code></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">GET index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"size"</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"bool"</span>: &#123;</span><br><span class="line">      <span class="string">"filter"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"bool"</span>: &#123;</span><br><span class="line">            <span class="string">"must"</span>: &#123;</span><br><span class="line">              <span class="string">"term"</span>: &#123;</span><br><span class="line">                <span class="string">"field1"</span>: <span class="string">"value1"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"bool"</span>: &#123;</span><br><span class="line">            <span class="string">"must"</span>: &#123;</span><br><span class="line">              <span class="string">"term"</span>: &#123;</span><br><span class="line">                <span class="string">"field2"</span>: <span class="string">"value1"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">"_source"</span>: [<span class="string">"cityTerm"</span>, <span class="string">"mlsOrgId"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="脚本查询"><a href="#脚本查询" class="headerlink" title="脚本查询"></a>脚本查询</h2><p><a href="https://my.oschina.net/secisland/blog/683518" target="_blank" rel="noopener">参考链接</a></p><p><code>script</code><br>支持Groovy、java等多种语言的脚本</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"bool"</span>: &#123;</span><br><span class="line">            <span class="attr">"filter"</span>: &#123;</span><br><span class="line">              <span class="attr">"script"</span>: &#123;</span><br><span class="line">                <span class="attr">"script"</span>: &#123;</span><br><span class="line">                  <span class="attr">"inline"</span>: <span class="string">"doc['field1'].value - doc['field2'].value &gt; 0"</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Elasticsearch常用搜索
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://yoursite.com/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://yoursite.com/tags/Elasticsearch/"/>
    
      <category term="DSL" scheme="http://yoursite.com/tags/DSL/"/>
    
  </entry>
  
  <entry>
    <title>mysql分库、分区、分表、分片</title>
    <link href="http://yoursite.com/2018/08/19/mysql%E5%88%86%E5%BA%93%E3%80%81%E5%88%86%E5%8C%BA%E3%80%81%E5%88%86%E8%A1%A8%E3%80%81%E5%88%86%E7%89%87/"/>
    <id>http://yoursite.com/2018/08/19/mysql分库、分区、分表、分片/</id>
    <published>2018-08-19T01:20:32.000Z</published>
    <updated>2018-08-19T01:27:49.901Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>mysql的分表是真正的分表，一张表分成很多表后，每一个小表都是完正的一张表，都对应三个文件（MyISAM引擎：一个.MYD数据文件，.MYI索引文件，.frm表结构文件）<br>分表后数据都是存放在分表里，总表只是一个外壳，存取数据发生在一个一个的分表里面</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>一张表的查询速度已经慢到影响使用的时候</li><li>当频繁插入或者联合查询时，速度变慢</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>利用merge存储引擎来实现分表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb_member1`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`sex`</span> tinyint(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM AUTO_INCREMENT=<span class="number">2</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb_member2`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`sex`</span> tinyint(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM AUTO_INCREMENT=<span class="number">2</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb_member`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`sex`</span> tinyint(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MRG_MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 INSERT_METHOD=<span class="keyword">LAST</span> <span class="keyword">UNION</span>=(<span class="string">`tb_member1`</span>,<span class="string">`tb_member2`</span>)</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>分表数据库引擎是MyISAM</li><li>分表与主表的字段定义一致</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/miketwais/articles/mysql_partition.html" target="_blank" rel="noopener">参考链接1</a></p><p><a href="https://www.cnblogs.com/lucky-man/p/6207873.html" target="_blank" rel="noopener">参考链接2</a></p><h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>把存放数据的文件分成了许多小块，分区后的表还是一张表</p><h2 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>一张表的查询速度已经慢到影响使用的时候</li><li>表中的数据是分段的</li><li>对数据的操作往往只涉及一部分数据，而不是所有的数据</li></ul><p>历史数据或不常访问的数据占很大部分，最新或热点数据占的比例不是很大，可以根据有些条件进行表分区。例如，表中有大量的历史记录，而“热数据”却位于表的末尾</p><h2 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h2><div class="table-container"><table><thead><tr><th style="text-align:center">分区类型</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center">RANGE</td><td style="text-align:center">基于属于一个给定连续区间的列值，把多行分配给分区</td></tr><tr><td style="text-align:center">LIST</td><td style="text-align:center">类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择</td></tr><tr><td style="text-align:center">HASH</td><td style="text-align:center">基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式</td></tr><tr><td style="text-align:center">KEY</td><td style="text-align:center">类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值</td></tr></tbody></table></div><h2 id="操作方式"><a href="#操作方式" class="headerlink" title="操作方式"></a>操作方式</h2><p>创建分区</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sales (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT,</span><br><span class="line">    amount <span class="keyword">DOUBLE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    order_day DATETIME <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>, order_day)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">Innodb</span> </span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(<span class="keyword">YEAR</span>(order_day)) (</span><br><span class="line">    <span class="keyword">PARTITION</span> p_2010 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2010</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p_2011 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2011</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p_2012 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2012</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p_catchall <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> MAXVALUE);</span><br></pre></td></tr></table></figure><p>常用操作</p><p><img src="/images/mysql-PARTITION-use.jpg"></p><h2 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/laoyang360/article/details/52886987" target="_blank" rel="noopener">参考链接1</a></p><p><a href="https://www.cnblogs.com/mliudong/p/3625522.html" target="_blank" rel="noopener">参考链接2</a></p><h1 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h1><p><a href="https://www.cnblogs.com/sunny3096/p/8595058.html" target="_blank" rel="noopener">参考链接</a></p><h1 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h1><p><a href="https://www.cnblogs.com/vadim/p/6985430.html" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      《高性能mysql》读书笔记
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>java虚拟机</title>
    <link href="http://yoursite.com/2018/08/19/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://yoursite.com/2018/08/19/java虚拟机/</id>
    <published>2018-08-18T22:07:10.000Z</published>
    <updated>2018-08-23T11:35:28.663Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><p><img src="/images/jvm_ architect.png"></p><h2 id="Java堆（Heap）"><a href="#Java堆（Heap）" class="headerlink" title="Java堆（Heap）"></a>Java堆（Heap）</h2><p>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中<code>最大</code>的一块。Java堆是被所有线程共享的一块内存区域，<code>在虚拟机启动时创建</code>。此内存区域的唯一目的就是存放对象实例，<code>几乎所有的对象实例都在这里分配内存</code>。</p><p>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“<code>GC堆</code>”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。</p><p>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。</p><p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，<code>它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</code>。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p><p>对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“<code>永久代</code>”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。</p><p>Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。</p><p>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><h2 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h2><p>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是<code>当前线程所执行的字节码的行号指示器</code>。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），<code>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</code>。 </p><p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 </p><p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。</p><p><code>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域</code>。</p><h2 id="JVM栈（JVM-Stacks）"><a href="#JVM栈（JVM-Stacks）" class="headerlink" title="JVM栈（JVM Stacks）"></a>JVM栈（JVM Stacks）</h2><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，<code>它的生命周期与线程相同</code>。虚拟机栈描述的是Java方法执行的内存模型：<code>每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息</code>。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 </p><p>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p><p>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p>在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。</p><h2 id="本地方法栈（Native-Method-Stacks）"><a href="#本地方法栈（Native-Method-Stacks）" class="headerlink" title="本地方法栈（Native Method Stacks）"></a>本地方法栈（Native Method Stacks）</h2><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是<code>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务</code>。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><h3 id="句柄方式"><a href="#句柄方式" class="headerlink" title="句柄方式"></a>句柄方式</h3><p>如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息</p><p>优点<br>使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改</p><p><img src="/images/jvm_obj_handle.png"></p><h3 id="直接指针方式"><a href="#直接指针方式" class="headerlink" title="直接指针方式"></a>直接指针方式</h3><p>如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址</p><p>优点<br>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本</p><p><img src="/images/jvm_obj_ cursor.png"></p><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><h2 id="对象存活分析"><a href="#对象存活分析" class="headerlink" title="对象存活分析"></a>对象存活分析</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>原理<br>给对象中每一个对象分配一个引用计数器，每当有地方引用该对象时，引用计数器的值加一，当引用失效时，引用计数器的值减一，不管什么时候，只要引用计数器的值等于0了，说明该对象不可能再被使用了</p><p>优缺点<br>实现原理简单，而且判定效率很高。大部分情况下都是一个不错的算法。但很难解决对象之间相互循环引用的问题</p><h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>原理<br>通过一系列被称为“GC Roots‘’的对象作为起始点，从这些节点向下搜索，搜索所走过的路径叫做引用链，当一个节点到GC Roots没有任何引用链时，证明该对象不可用了</p><p>被作为GC Roots的对象有以下几种:</p><ul><li>虚拟机栈中引用的对象（栈帧中的引用变量表）</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中Native方法（JNI）引用的对象</li></ul><h2 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h2><p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类</p><p>废弃常量回收<br>回收废弃常量与回收Java堆中的对象非常相似。以常量池中字面量的回收为例，若字符串“abc”已经进入常量池中，但当前系统没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用该字面量，若发生内存回收，且必要的话，该“abc”就会被系统清理出常量池。常量池中其他的类（接口）、方法、字段的符号引用与此类似</p><p>无用的类回收</p><ul><li>该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例</li><li>加载该类的ClassLoader已经被回收</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul><p>在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出</p><h2 id="新生代、老年代以及永久代"><a href="#新生代、老年代以及永久代" class="headerlink" title="新生代、老年代以及永久代"></a>新生代、老年代以及永久代</h2><p><img src="/images/java-heap.jpeg"></p><p>堆大小 = 新生代 + 老年代</p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>1个Eden区和2个Survivor区（分别叫from和to）,默认比例为8：1。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。</p><p>因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在<code>年轻代的垃圾回收算法使用的是复制算法</code></p><p>在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”</p><p><img src="/images/java-new-generation.png"></p><h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>老年代与新生代不同，对象存活的时间比较长，比较稳定，因此采用标记（Mark）算法来进行回收</p><h3 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h3><p>在JDK的HotSpot虚拟机中，可以认为方法区就是永久代，但是在其他类型的虚拟机中，没有永久代的概念</p><h2 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h2><ul><li><p>Minor GC<br>  发生在新生代中的垃圾收集动作，所采用的是复制算法</p></li><li><p>FullGC (Major GC)<br>  发生在老年代的垃圾收集动作，所采用的是标记-清除算法</p></li></ul><h2 id="JVM内存管理参数"><a href="#JVM内存管理参数" class="headerlink" title="JVM内存管理参数"></a>JVM内存管理参数</h2><p><a href="https://blog.csdn.net/Thousa_Ho/article/details/77278656" target="_blank" rel="noopener">JVM参数使用总结</a></p><ul><li>-Xms 设置堆的最小空间大小</li><li>-Xmx 设置堆的最大空间大小</li><li>-XX:NewSize 设置新生代最小空间大小</li><li>-XX:MaxNewSize 设置新生代最大空间大小</li><li>-XX:PermSize 设置永久代最小空间大小</li><li>-XX:MaxPermSize 设置永久代最大空间大小</li><li>-Xss 设置每个线程的堆栈大小。</li><li>-XX:NewRatio 设置新生代和老生代的相对大小</li><li>-XX:SurvivorRatio 指定Eden区和Survivor区的大小比例,注意两个幸存区是一样大的</li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><ul><li><p>复制算法(新生代)<br>该算法的核心是将可用内存按容量划分为大小相等的两块, 每次只用其中一块, 当这一块的内存用完, 就将还存活的对象复制到另外一块上面, 然后把已使用过的内存空间一次清理掉</p></li><li><p>标记清除算法(老年代)<br>该算法分为“标记”和“清除”两个阶段: 首先标记出所有需要回收的对象(可达性分析), 在标记完成后统一清理掉所有被标记的对象</p><p>  该算法会有以下两个问题</p><ul><li>效率问题: 标记和清除过程的效率都不高;</li><li>空间问题: 标记清除后会产生大量不连续的内存碎片, 空间碎片太多可能会导致在运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集</li></ul></li><li><p>标记整理算法(老年代)<br>标记清除算法会产生内存碎片问题, 而复制算法需要有额外的内存担保空间, 于是针对老年代的特点, 又有了标记整理算法. 标记整理算法的标记过程与标记清除算法相同, 但后续步骤不再对可回收对象直接清理, 而是让所有存活的对象都向一端移动,然后清理掉端边界以外的内存</p></li></ul><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="/images/GC-collertor2.jpg"></p><p><a href="https://blog.csdn.net/qq_33938256/article/details/52502502" target="_blank" rel="noopener">参考链接1</a><br><a href="http://www.importnew.com/23035.html" target="_blank" rel="noopener">参考链接2</a></p><ul><li>串行收集器 Serial开头的 <ul><li>Serial</li><li>Serial Old(MSC)</li></ul></li><li>并行收集器 Parallel开头的 <ul><li>ParNew</li><li>Parallel Scavenge</li><li>Parallel Old</li></ul></li><li>并发收集器 <ul><li>CMS (Concurrent Mark Sweep)</li></ul></li><li>G1(Garbage First)<br>  图片中的问号位置<br>  JDK 1.7后有G1</li></ul><h2 id="GC日志"><a href="#GC日志" class="headerlink" title="GC日志"></a>GC日志</h2><p>日志格式<br><img src="/images/gc_log.png"></p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">GC（GC类型，当前是Minor</span> GC） (<span class="name">Allocation</span> Failure) [<span class="name">DefNew（GC的区域，当前为新生代）:</span> <span class="number">5688</span>K（垃圾回收前的大小）-&gt;790K（垃圾回收以后的大小）(<span class="name">9216K</span>)（该区域总大小）, <span class="number">0.0060899</span> secs] <span class="number">5688</span>K（堆在垃圾回收前的大小）-&gt;4886K（堆在垃圾回收后的大小）(<span class="name">19456K</span>)（堆的总大小）, <span class="number">0.0061183</span> secs] [<span class="name">Times:</span> user=0.00（用户态消耗CPU时间） sys=0.01（内核态小时CPU时间）, real=0.00 secs（操作的实际时间）]</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/fd1d4f21733a" target="_blank" rel="noopener">参考链接</a></p><ul><li>大对象直接进入老年代</li><li>长期存活的对象进入老年代</li></ul><h1 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h1><p><img src="/images/class.png"></p><p><a href="https://blog.csdn.net/column/details/jvm-principle.html" target="_blank" rel="noopener">参考系列</a></p><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><p><img src="/images/class-load.png"></p><p><a href="https://blog.csdn.net/fgets/article/details/52934178" target="_blank" rel="noopener">参考链接</a><br><a href="https://blog.csdn.net/shakespeare001/article/details/51765353" target="_blank" rel="noopener">参考章节</a></p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><ul><li>通过一个类的全限定名来获取其定义的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口</li></ul><p>除了可以使用系统提供的引导类加载器外，还可以使用用户自定义的类加载器。任意一个类，都需要由加载它的类加载器和这个类本身共同确定其在Java 虚拟机中的唯一性</p><p>类加载器</p><p><img src="/images/classLoader.png"></p><ul><li>启动类加载器：启动类加载器无法被 java 程序直接引用，如需要，直接使用 null 代替即可</li><li>扩展类加载器</li><li>应用程序类加载器：它负责加载用户路径(ClassPath)上所指定的类库，开发者可以使用这个类加载器，如果应用程序没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器</li></ul><p>双亲委派模型<br>如果一个类加载器收到了类加载器的请求，它首先不会自己尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类时），子加载类才会尝试自己去加载</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</p><ul><li>文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理</li><li>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，主要是验证类的继承关系、数据类型是否符合</li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。对类的方法体进行校验分析，以保证被校验类的方法在运行时不会做出危害虚拟机安全的事件</li><li>符号引用验证：发生在虚拟机将符号引用转化为直接引用的时候,对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验</li></ul><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配</p><ul><li>这阶段进行内存分配的仅包括类变量（即被static修饰的变量），不包括实例变量</li><li>这里所说的初始值“通常情况”下是数据类型的零值</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程</p><ul><li>符号引用（Symbolic References）：即用一组符号来描述所引用的目标。它与虚拟机的内存布局无关，引用的目标不一定已经加载到内存中</li><li>直接引用（Direct References）：直接引用可以是指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。它是和虚拟机内存布局相关的，如果有了直接引用，那引用的目标必定已经在内存中存在了</li></ul><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7类符号引用进行</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化是类加载过程的最后一步，此阶段才开始真正执行类中定义的Java程序代码（或者说字节码，也仅限与执行<clinit>()方法）。在准备阶段，我们已经给变量付过一次系统要求的初始值（零值），而在初始化阶段，则会根据程序员的意愿给类变量和其他资源赋值。主要是通过<clinit>()方法来执行的</clinit></clinit></p><h1 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h1><p><a href="https://blog.csdn.net/u013678930/article/details/51980460" target="_blank" rel="noopener">章节参考</a></p><h1 id="Java编译期优化"><a href="#Java编译期优化" class="headerlink" title="Java编译期优化"></a>Java编译期优化</h1><p><img src="/images/jvm_complier.png"></p><h2 id="解析与填充符号表过程"><a href="#解析与填充符号表过程" class="headerlink" title="解析与填充符号表过程"></a>解析与填充符号表过程</h2><p>解析步骤包含了词法分析和语法分析两个过程，首先词法分析是将源代码的字符流转变成为标记集合（token），然后语法分析是根据token序列来构造抽象语法树（一种用来描述程序代码语法结构的树状表示方式）。完成词法分析和语法分析之后，下一步是填充符号表，符号表是由一组符号地址和符号信息构成的表格，符号表中所登记的信息在编译的不同阶段都要用到（比如语义分析中符号表所登记的内容将用于语义检查和产生中间代码，目标代码生成阶段当对符号名进行地址分配时，符号表是地址分配的依据）</p><h2 id="插入式注解处理器的注解处理过程"><a href="#插入式注解处理器的注解处理过程" class="headerlink" title="插入式注解处理器的注解处理过程"></a>插入式注解处理器的注解处理过程</h2><p>插入式注解处理器可以看做是一组编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，那么编译器将回到解析及填充符号表的过程重新处理，直到所有的插入式注解处理器都没有再对语法树进行修改为止</p><h2 id="语义分析与字节码生成过程"><a href="#语义分析与字节码生成过程" class="headerlink" title="语义分析与字节码生成过程"></a>语义分析与字节码生成过程</h2><p>语法分析之后，编译器获得了程序代码的抽象语法树表示，语法树能够表示结构正确的源程序的抽象，但是无法保证源程序是否符合逻辑，而语义分析主要是对结构上正确的源程序进行上下文有关性质的检查</p><h3 id="标注检查"><a href="#标注检查" class="headerlink" title="标注检查"></a>标注检查</h3><p>标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配，等等。还有一个重要的动作称为常量折叠也在此阶段完成</p><h3 id="数据及控制流分析"><a href="#数据及控制流分析" class="headerlink" title="数据及控制流分析"></a>数据及控制流分析</h3><p>数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否有返回值、是否所有的受查异常都被正确处理了等问题</p><h3 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h3><p>语法糖是指在计算机语言中添加某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。java中的泛型，变长参数，自动拆箱与装箱，条件编译等就属于语法糖，它们在编译阶段就被还原成简单的语法结构（比如List<string>和List<integer>在运行期间其实是同一个类）</integer></string></p><h3 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h3><p>此过程是javac编译过程的最后一个阶段，字节码生成阶段将之前各个步骤所生成的信息转化成字节码写到磁盘中，另外还进行少量的代码添加和转换工作</p><h1 id="Java运行期优化"><a href="#Java运行期优化" class="headerlink" title="Java运行期优化"></a>Java运行期优化</h1><p><img src="/images/jvm_jit.png"></p><p>在部分商用虚拟机中，java程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块运行特别频繁，就会把这些代码认定为“热点代码”，为了提高热点代码的执行效率，在运行时，虚拟机就会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器或JIT编译器。</p><p>即时编译器并不是虚拟机必须的部分，但是即时编译器编译性能的好坏、代码优化程度的高低确是衡量一款商用虚拟机优秀与否的最关键的指标之一。</p><p>众多主流的虚拟机都同时包含解释器和JIT编译器，解释器与JIT编译器各有优势：当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行。当程序运行后，随着事件的推移，JIT编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率</p><p>会被即时编译器编译的热点代码有两类</p><ul><li>被多次调用的方法体</li><li>被多次调用的循环体</li></ul><p>即时编译器会以整个方法作为编译对象，将其编译成机器码。这种编译方式因为编译发生在方法执行过程之中，因此被称作栈上替换（OSR）</p><p>判断一段代码是否是热点代码的方式（热点探测）有两种</p><ul><li>基于采样的热点探测：此方法会周期性检查各个线程的栈顶，如果发现某个或某些方法经常出现在栈顶，那么这个方法就是热点方法。此方法的缺点是很难精确地确认一个方法的热度，容易受到诸如线程阻塞等因素影响</li><li>基于计数器的热点探测：此方法会为每个方法甚至是代码块建立计数器，统计方法的执行次数，如果执行次数超过一个阀值就认为它是热点方法</li></ul><p>默认设置下，执行引擎并不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成。当编译工作完成之后，这个方法的调用入口地址就会被系统自动改写成新的地址，下一次调用该方法时就会使用已编译的版本。也就是说，在编译器还未完成之前，执行引擎仍按照解释方式继续执行，而编译动作则在后台的编译线程中进行</p><p>优化技术<br>一般来说即时编译器所产生的本地代码会比javac产生的字节码更优秀。即时编译器采用了一系列的技术来优化代码，比如公共子表达式消除，数组范围内检查消除，方法内联，逃逸分析等</p>]]></content>
    
    <summary type="html">
    
      《深入理解JAVA虚拟机实战》读书笔记
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
</feed>

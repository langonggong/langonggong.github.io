---
title: 词干提取器
description: 词干提取器
date: 2019-09-21 18:07:16
keywords: Elasticsearch
categories : [Elasticsearch]
tags : [Elasticsearch, 分析器]
comments: true
---

#前言
大多数语言的单词都可以 词形变化 ，意味着 下列单词可以改变它们的形态用来表达不同的意思：

- 单复数变化 ： fox 、foxes
- 时态变化 ： pay 、 paid 、 paying
- 性别变化 ： waiter 、 waitress
- 动词人称变化 ： hear 、 hears
- 代词变化 ： I 、 me 、 my
- 不规则变化 ： ate 、 eaten
- 情景变化 ： so be it 、 were it so

#提取程度

词干提取是一种遭受两种困扰的模糊的技术：词干弱提取和词干过度提取。

- 词干弱提取 
	就是无法将同样意思的单词缩减为同一个词根。例如， jumped和jumps可能被提取为 jump ， 但是 jumping 可能被提取为 jumpi 。弱词干提取会导致搜索时无法返回相关文档。
- 词干过度提取 
	就是无法将不同含义的单词分开。例如，general和generate可能都被提取为 gener 。 词干过度提取会降低精准度：不相干的文档会在不需要他们返回的时候返回。

#提取方式

##基于算法
Elasticsearch 中的大部分 stemmers （词干提取器）是基于算法的，它们提供了一系列规则用于将一个词提取为它的词根形式，例如剥离复数词末尾的 s 或 es 。提取单词词干时并不需要知道该词的任何信息。

- 优点
	可以作为插件使用，速度快，占用内存少，有规律的单词处理效果好
- 缺点
	没规律的单词例如 be 、 are 、和 am ，或 mice 和 mouse 效果不好
	

##基于字典
字典词干提取器在工作机制上与算法化词干提取器完全不同。 不同于应用一系列标准规则到每个词上，字典词干提取器只是简单地在字典里查找词。理论上可以给出比算法化词干提取器更好的结果。一个字典词干提取器应当可以：

- 返回不规则形式如feet和mice的正确词干
- 区分出词形相似但词义不同的情形，比如organ and organization

##对比
实践中一个好的算法化词干提取器一般优于一个字典词干提取器。应该有以下两大原因：

- 字典质量
	字典需要保持最新，这是一项很耗时的任务。通常等到一个字典变得好用后，其中的部分内容已经过时。字典词干提取器对于字典中不存在的词无能为力。而一个基于算法的词干提取器，则会继续应用之前的相同规则，结果可能正确或错误。
- 大小与性能
	字典词干提取器需要加载所有词汇、 所有前缀，以及所有后缀到内存中。这会显著地消耗内存。找到一个词的正确词干，一般比算法化词干提取器的相同过程更加复杂。依赖于不同的字典质量，去除前后缀的过程可能会更加高效或低效。低效的情形可能会明显地拖慢整个词干提取过程。

#提取器种类

- Porter Stem Token Filter
	porter_stem语汇单元过滤器（token filter）。
	最早的一个基于算法 的英文词干提取器，提取程度较为激进。
- KStem Token Filter
	kstem语汇单元过滤器（token filter）。
	是一款合并了词干提取算法和内置词典的英语分词过滤器。为了避免模糊词不正确提取，这个词典包含一系列根词单词和特例单词。 kstem分词过滤器相较于Porter词干提取器而言不那么激进。
- Hunspell 词干提取器
	基于词典提取词干的hunspell语汇单元过滤器（token filter）. Hunspell hunspell.github.io 是一个 Open Office、LibreOffice、Chrome、Firefox、Thunderbird 等众多其它开源项目都在使用的拼写检查器。Hunspell词典会占用几兆的内存，它不仅能移除前缀还能移除后缀。
	一个 Hunspell 词典由两个文件组成 — 具有相同的文件名和两个不同的后缀 — 如 en_US—和下面的两个后缀的其中一个：
	- .dic
		包含所有词根，采用字母顺序，再加上一个代表所有可能前缀和后缀的代码表 【集体称之为词缀( affixes 】
	- .aff
		包含实际 .dic 文件每一行代码表对应的前缀和后缀转换
- 其他
	Lovins 提取器、Porter 提取器、Porter2 提取器等

#如何选择
推荐的词干提取器也许不适用所有场景。 关于哪个是最好的词干提取器，不存在一个唯一的正确答案 — 它要看你具体的需求。 这里有3个方面的因素需要考虑在内： 性能、质量、程度。

##提取性能
算法提取器一般来说比Hunspell提取器快4到5倍。Hunspell 提取器需要加载所有的词典、前缀和后缀表到内存，可能需要消耗几兆的内存。而算法提取器，由一点点代码组成，只需要使用很少内存。

##提取质量
最日常用语使用的词往往不规则。一个基于词典的提取器往往取决于词典的好坏。如果 Hunspell 碰到的这个词不在词典里，那它什么也不能做。 Hunspell 需要一个广泛的、高质量的、最新的词典以产生好的结果；这样级别的词典可谓少之又少。 另一方面，一个算法提取器，将愉快的处理新词而不用为新词重新设计算法。
如果一个好的算法词干提取器可用于你的语言，那明智的使用它而不是 Hunspell。它会更快并且消耗更少内存，并且会产生和通常一样好或者比 Hunspell 等价的结果.
如果精度和可定制性对你很重要，那么你需要（和有精力）来维护一个自定义的词典，那么 Hunspell 会给你比算法提取器更大的灵活性

##提取程度
是否想要积极提取还是轻量提取取决于你的场景。如果你的搜索结果是要用于聚类算法，你可能会希望匹配的更广泛一点（因此，提取力度要更大一点）。 如果你的搜索结果是面向最终用户，轻量的提取一般会产生更好的结果。对搜索来说，将名称和形容词提干比动词提干更重要，当然这也取决于语言。

另外一个要考虑的因素就是你的文档集的大小。 一个只有 10,000 个产品的小集合，你可能要更激进的提干来确保至少匹配到一些文档。 如果你的文档集很大，使用轻量的弱提取可能会得到更好的匹配结果。

# 参考链接

>[将单词还原为词根](https://www.elastic.co/guide/cn/elasticsearch/guide/current/stemming.html)
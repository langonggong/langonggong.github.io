[{"title":"DNS解析","date":"2018-09-06T08:46:42.000Z","path":"2018/09/06/DNS解析/","text":"nslookup 第一行Server是：DNS服务器的主机名—10.4.1.14第二行Address是：它的IP地址—10.4.1.14#53 百度有一个cname = www.a.shifen.com的别名 下面的Name是：解析的URL—www.a.shifen.comAddress是：解析出来的IP—220.181.112.244和220.181.111.188 dig www.baidu.com +trace Dig工具会在本地计算机做迭代，然后记录查询的过程 第一步，向我这台机器的ISPDNS获取到根域服务区的13个IP和主机名[b-j].root-servers.net. 第二步，向其中的一台根域服务器（m.root-servers.net）发送www.baidu.com的查询请求，他返回了com.顶级域的服务器名称 第三步，向com.域的一台服务器i.gtld-servers.net请求,www.baidu.com，他返回了baidu.com域的服务器IP（未显示）和名称，百度有5台顶级域的服务器 第四步，向百度的顶级域服务器（202.108.22.220）请求www.baidu.com，他发现这个www有个别名，而不是一台主机，别名是www.a.shifen.com 按照一般的逻辑，当dns请求到别名的时候，查询不会终止，而是重新发起查询别名的请求，所以此处应该返回的是www.a.shifen.com，然后继续请求 使用dig www.a.shifen.com +trace查看 会发现第三步时shifen.com这个顶级域的域名服务器和baidu.com这个域的域名服务器是同一台主机（即：dns.baidu.com），shifen.com域发现请求的www.a.shifen.com是属于a.shifen.com这个域的，于是从ns X.a.shifen.com中一台拿到了一条A记录，最终的最终也便是www.baidu.com的IP地址了","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"},{"name":"DNS","slug":"DNS","permalink":"http://yoursite.com/tags/DNS/"}]},{"title":"基数排序","date":"2018-09-05T15:41:05.000Z","path":"2018/09/05/基数排序/","text":"","tags":[]},{"title":"计数排序","date":"2018-09-05T15:37:25.000Z","path":"2018/09/05/计数排序/","text":"根据数组最大最小值构建数组，记录每个数字出现次数 123456789101112131415161718192021222324public class CountingSort &#123; public int[] countingSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return arr; &#125; int min = arr[0], max = arr[0]; for(int i=0;i&lt;arr.length;i++) &#123; min = Math.min(min, arr[i]); max = Math.max(max, arr[i]); &#125; int[] store = new int[max - min + 1]; for(int j=0;j&lt;arr.length;j++) &#123; store[arr[j] - min]++; &#125; int index = 0; for(int k=0;k&lt;store.length;k++) &#123; while (store[k]-- &gt; 0) &#123; arr[index++] = k + min; &#125; &#125; return arr; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"希尔排序","date":"2018-09-05T15:00:26.000Z","path":"2018/09/05/希尔排序/","text":"令k=21、将数组分成k等分，构建length/2个间隔为k的数组，对每个数组进行插入排序2、k=k*2,重复步骤1 插入排序:假设前面的数组已经有序，则找到改点合适的位置插入(该点下沉到合适的位置) 123456789101112131415161718192021222324252627282930public class ShellSort &#123; public int[] shellSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return arr; &#125; int length = arr.length ; //将数组2等分，4等分...直到一等分 for (int gap = length &gt;&gt; 1; gap &gt; 0; gap &gt;&gt;= 1) &#123; //对生成的多个数组进行插入排序 for (int start = gap; start &lt; arr.length; start++) &#123; //对单个数组进行插入排序 for (int index = start; index &gt;= gap; index -= gap) &#123; if (arr[index - gap] &gt; arr[index]) &#123; swap(arr, index - gap, index); &#125; &#125; &#125; &#125; return arr; &#125; public static void swap(int[] arr, int index1, int index2) &#123; if (index1 == index2) &#123; return; &#125; int tmp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = tmp; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"堆排序","date":"2018-09-04T16:28:14.000Z","path":"2018/09/05/堆排序/","text":"1、构建大根堆，满足父大于子，堆顶为最大值2、将堆顶与最后一位进行替换，将前n-1位调整为大根堆3、对前n-1位大根堆重复过程2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class HeapSort &#123; public int[] heapSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return arr; &#125; //构建大根堆，使整棵树满足:父&gt;子 for (int i = arr.length / 2; i &gt;= 0; i--) &#123; //每次调整，都要保证将后面所有的都调整一遍 headAdjust(arr, i, arr.length); &#125; //将堆顶（最大值）替换到第j个点，然后将前面j-1个点调整为大根堆， //对前j-1个点重复此过程 for(int j=arr.length-1;j&gt;=0;j--) &#123; swap(arr, 0, j); headAdjust(arr, 0, j); &#125; return arr; &#125; //保证[index,length)单条支线上的点满足:父节点大于子节点 private void headAdjust(int[] arr, int index,int length) &#123; while (index &lt; length) &#123; int left = 2 * index + 1; int right = 2 * index + 2; int max = index; if (left &lt; length &amp;&amp; arr[left] &gt; arr[index]) &#123; max = left; &#125; if (right &lt; length &amp;&amp; arr[right] &gt; arr[max]) &#123; max = right; &#125; if (index == max) &#123; break; &#125; swap(arr, index, max); index = max; &#125; &#125; public static void swap(int[] arr, int index1, int index2) &#123; if (index1 == index2) &#123; return; &#125; int tmp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = tmp; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"快速排序","date":"2018-09-03T15:56:00.000Z","path":"2018/09/03/快速排序/","text":"选择任意一点，将元素划分为小于该值和大于该值的左右两部分，递归次过程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class QuickSort &#123; public int[] quickSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return arr; &#125; process(arr, 0, arr.length - 1); return arr; &#125; public static void process(int[] arr, int left, int right) &#123; if (left &gt;= right) &#123; return; &#125; int random = left + (int) Math.random() * (right - left + 1); swap(arr, random, right); int partition = partition(arr, left, right); process(arr, left, partition - 1); process(arr, partition + 1, right); &#125; /** * 将小于或等于right的元素替换到左边，大于right的元素保持不动 * partition加一递增，指向最近一个被替换到左边的位置 * 当数组遍历完，right处的元素被替换到partition所指的位置 * partition左边的值全部小于或等于该值，右边的值全部大于该值 **/ public static int partition(int[] arr, int left, int right) &#123; int partition = left - 1; int index = left; while (index &lt;= right) &#123; if (arr[index] &lt;= arr[right]) &#123; swap(arr, ++partition, index); &#125; index++; &#125; return partition; &#125; public static void swap(int[] arr, int index1, int index2) &#123; if (index1 == index2) &#123; return; &#125; int tmp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = tmp; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"归并排序","date":"2018-09-03T13:24:32.000Z","path":"2018/09/03/归并排序/","text":"二分后递归调用自身，然后对这两部分处理后的结果进行排序 12345678910111213141516171819202122232425262728293031323334353637383940public class MergeSort &#123; public int[] mergeSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return arr; &#125; divide(arr, 0, arr.length - 1); return arr; &#125; private void divide(int[] arr, int left, int right) &#123; if (left &gt;= right) &#123; return; &#125; int mid = (left + right) / 2; divide(arr, left, mid); divide(arr, mid + 1, right); merge(arr, left, mid, right); &#125; private void merge(int[] arr, int left, int mid, int right) &#123; int[] result = new int[right - left + 1]; int i = left, j = mid + 1, index = 0; while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; if (arr[i] &lt; arr[j]) &#123; result[index++] = arr[i++]; &#125; else &#123; result[index++] = arr[j++]; &#125; &#125; while (i &lt;= mid) &#123; result[index++] = arr[i++]; &#125; while (j &lt;= right) &#123; result[index++] = arr[j++]; &#125; for(int k=0;k&lt;result.length;k++) &#123; arr[left + k] = result[k]; &#125; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"插入排序","date":"2018-09-02T15:10:00.000Z","path":"2018/09/02/插入排序/","text":"假设前面的数组已经有序，则找到改点合适的位置插入(该点下沉到合适的位置) 1234567891011121314151617181920212223242526272829public class InsertionSort &#123; public int[] insertionSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return arr; &#125; for (int i=1;i&lt;arr.length;i++) &#123; int j = i; while (j &gt; 0) &#123; if (arr[j - 1] &gt; arr[j]) &#123; swap(arr, j, j - 1); j--; &#125; else &#123; break; &#125; &#125; &#125; return arr; &#125; private void swap(int[] arr, int i, int j) &#123; if (i == j) &#123; return; &#125; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"选择排序","date":"2018-09-02T14:58:40.000Z","path":"2018/09/02/选择排序/","text":"选择最小值与第一个数字交换 1234567891011121314151617181920212223242526public class SelectSort &#123; public int[] selectionSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return arr; &#125; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int mini = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; mini = arr[j] &lt; arr[mini] ? j : mini; &#125; swap(arr, i, mini); &#125; return arr; &#125; private void swap(int[] arr, int i, int j) &#123; if (i == j) &#123; return; &#125; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"冒泡排序","date":"2018-09-02T14:49:03.000Z","path":"2018/09/02/冒泡排序/","text":"最大值上浮 12345678910111213141516171819202122public class BubbleSort &#123; public int[] bubbleSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return arr; &#125; for (int i=arr.length-1;i&gt;0;i--) &#123; for (int j=0;j&lt;i;j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; swap(arr, j, j + 1); &#125; &#125; &#125; return arr; &#125; private void swap(int[] arr, int i, int j) &#123; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"AQS","date":"2018-09-01T06:14:14.000Z","path":"2018/09/01/AQS/","text":"引言在JDK1.5之前，一般是靠synchronized关键字来实现线程对共享变量的互斥访问。synchronized是在字节码上加指令，依赖于底层操作系统的Mutex Lock实现。AQS定义了一套多线程访问共享资源的同步器框架，是整个java.util.concurrent包的基石，Lock、ReadWriteLock、CountDowndLatch、CyclicBarrier、Semaphore、ThreadPoolExecutor等都是在AQS的基础上实现的。 同步队列(CLH)AQS维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列） AQS的内部队列是CLH同步锁的一种变形。其主要从两方面进行了改造，节点的结构与节点等待机制 在结构上引入了头结点和尾节点，分别指向队列的头和尾，尝试获取锁、入队列、释放锁等实现都与头尾节点相关 为了可以处理timeout和cancel操作，每个node维护一个指向前驱的指针。如果一个node的前驱被cancel，这个node可以前向移动使用前驱的状态字段 在每个node里面使用一个状态字段来控制阻塞/唤醒，而不是自旋 head结点使用的是傀儡结点 12345678910111213public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer&#123;//指向同步队列队头private transient volatile Node head;//指向同步的队尾private transient volatile Node tail;//同步状态，在不同的子类有不同的含义private volatile int state;//省略其他代码......&#125; Node节点Node结点是对每一个访问同步代码的线程的封装，从图中的Node的数据结构也可看出，其包含了需要同步的线程本身以及线程的状态，如是否被阻塞，是否等待唤醒，是否已经被取消等。每个Node结点内部关联其前继结点prev和后继结点next，这样可以方便线程释放锁后快速唤醒下一个在等待的线程，Node是AQS的内部类，其数据结构如下 12345678910111213141516171819202122232425262728293031323334353637383940414243static final class Node &#123; //共享模式 static final Node SHARED = new Node(); //独占模式 static final Node EXCLUSIVE = null; //标识线程已处于结束状态 static final int CANCELLED = 1; //等待被唤醒状态 static final int SIGNAL = -1; //条件状态 static final int CONDITION = -2; //在共享模式中使用表示获得的同步状态会被传播 static final int PROPAGATE = -3; //等待状态,存在CANCELLED、SIGNAL、CONDITION、PROPAGATE 4种 volatile int waitStatus; //同步队列中前驱结点 volatile Node prev; //同步队列中后继结点 volatile Node next; //请求锁的线程 volatile Thread thread; //等待队列中的后继结点，这个与Condition有关 Node nextWaiter; //判断是否为共享模式 final boolean isShared() &#123; return nextWaiter == SHARED; &#125; //获取前驱结点 final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; //.....&#125; 其中SHARED和EXCLUSIVE常量分别代表共享模式和独占模式，所谓共享模式是一个锁允许多条线程同时操作，如信号量Semaphore采用的就是基于AQS的共享模式实现的，而独占模式则是同一个时间段只能有一个线程对共享资源进行操作，多余的请求线程需要排队等待，如ReentranLock。变量waitStatus则表示当前被封装成Node结点的等待状态，共有4种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE CANCELLED：值为1，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node的结点，其结点的waitStatus为CANCELLED，即结束状态，进入该状态后的结点将不会再变化。 SIGNAL：值为-1，被标识为该等待唤醒状态的后继结点，当其前继结点的线程释放了同步锁或被取消，将会通知该后继结点的线程执行。说白了，就是处于唤醒状态，只要前继结点释放锁，就会通知标识为SIGNAL状态的后继结点的线程执行。 CONDITION：值为-2，与Condition相关，该标识的结点处于等待队列中，结点的线程等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。 PROPAGATE：值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态。 0状态：值为0，代表初始化状态。 AQS lock()操作 Sync与State实现state机制volatile 变量 state; 用于同步线程之间的共享状态。通过 CAS 和 volatile 保证其原子性和可见性。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。 12345678// 同步状态 private volatile int state; //CAS protected final boolean compareAndSetState(int expect, int update) &#123; // See below for intrinsics setup to support this return unsafe.compareAndSwapInt(this, stateOffset, expect, update); &#125; 不同实现类的Sync与State基于AQS构建的Synchronizer包括ReentrantLock,Semaphore,CountDownLatch, ReetrantRead WriteLock,FutureTask等，这些Synchronizer实际上最基本的东西就是原子状态的获取和释放，只是条件不一样而已 ReentrantLock需要记录当前线程获取原子状态的次数，如果次数为零，那么就说明这个线程放弃了锁（也有可能其他线程占据着锁从而需要等待），如果次数大于1，也就是获得了重进入的效果，而其他线程只能被park住，直到这个线程重进入锁次数变成0而释放原子状态。以下为ReetranLock的FairSync的tryAcquire实现代码解析 123456789101112131415161718192021222324//公平获取锁protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); //如果当前重进入数为0,说明有机会取得锁 if (c == 0) &#123; //如果是第一个等待者，并且设置重进入数成功，那么当前线程获得锁 if (isFirst(current) &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; //如果当前线程本身就持有锁，那么叠加重进入数，并且继续获得锁 else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; &#125; //以上条件都不满足，那么线程进入等待队列。 return false;&#125; Semaphore信号量维护了一个许可集，我们在初始化Semaphore时需要为这个许可集传入一个数量值，该数量值代表同一时间能访问共享资源的线程数量。以下为Semaphore的FairSync实现 123456789101112131415protected int tryAcquireShared(int acquires) &#123; Thread current = Thread.currentThread(); for (;;) &#123; Thread first = getFirstQueuedThread(); //如果当前等待队列的第一个线程不是当前线程，那么就返回-1表示当前线程需要等待 if (first != null &amp;&amp; first != current) return -1; //如果当前队列没有等待者，或者当前线程就是等待队列第一个等待者，那么先取得semaphore还有几个许可证，并且减去当前线程需要的许可证得到剩下的值 int available = getState(); int remaining = available - acquires; //如果remining&lt;0，那么反馈给AQS当前线程需要等待，如果remaining&gt;0，并且设置availble成功设置成剩余数，那么返回剩余值(&gt;0)，也就告知AQS当前线程拿到许可，可以继续执行。 if (remaining &lt; 0 ||compareAndSetState(available, remaining)) return remaining; &#125;&#125; CountDownLatch闭锁则要保持其状态，在这个状态到达终止态之前，所有线程都会被park住，闭锁可以设定初始值，这个值的含义就是这个闭锁需要被countDown()几次，因为每次CountDown是sync.releaseShared(1),而一开始初始值为10的话，那么这个闭锁需要被countDown()十次，才能够将这个初始值减到0，从而释放原子状态，让等待的所有线程通过 12345678910111213141516//await时候执行，只查看当前需要countDown数量减为0了，如果为0，说明可以继续执行，否则需要park住，等待countDown次数足够，并且unpark所有等待线程public int tryAcquireShared(int acquires) &#123; return getState() == 0? 1 : -1;&#125; //countDown 时候执行，如果当前countDown数量为0，说明没有线程await，直接返回false而不需要唤醒park住线程，如果不为0，得到剩下需要 countDown的数量并且compareAndSet,最终返回剩下的countDown数量是否为0,供AQS判定是否释放所有await线程。public boolean tryReleaseShared(int releases) &#123; for (;;) &#123; int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; &#125;&#125; FutureTask需要记录任务的执行状态，当调用其实例的get方法时,内部类Sync会去调用AQS的acquireSharedInterruptibly()方法，而这个方法会反向调用Sync实现的tryAcquireShared()方法，即让具体实现类决定是否让当前线程继续还是park,而FutureTask的tryAcquireShared方法所做的唯一事情就是检查状态，如果是RUNNING状态那么让当前线程park。而跑任务的线程会在任务结束时调用FutureTask 实例的set方法（与等待线程持相同的实例），设定执行结果，并且通过unpark唤醒正在等待的线程，返回结果 123456789101112131415161718192021222324252627282930313233343536373839404142//get时待用，只检查当前任务是否完成或者被Cancel，如果未完成并且没有被cancel，那么告诉AQS当前线程需要进入等待队列并且park住protected int tryAcquireShared(int ignore) &#123; return innerIsDone()? 1 : -1;&#125; //判定任务是否完成或者被Cancelboolean innerIsDone() &#123; return ranOrCancelled(getState()) &amp;&amp; runner == null;&#125; //get时调用，对于CANCEL与其他异常进行抛错V innerGet(long nanosTimeout) throws InterruptedException, ExecutionException, TimeoutException &#123; if (!tryAcquireSharedNanos(0,nanosTimeout)) throw new TimeoutException(); if (getState() == CANCELLED) throw new CancellationException(); if (exception != null) throw new ExecutionException(exception); return result;&#125; //任务的执行线程执行完毕调用（set(V v)）void innerSet(V v) &#123; for (;;) &#123; int s = getState(); //如果线程任务已经执行完毕，那么直接返回（多线程执行任务？） if (s == RAN) return; //如果被CANCEL了，那么释放等待线程，并且会抛错 if (s == CANCELLED) &#123; releaseShared(0); return; &#125; //如果成功设定任务状态为已完成，那么设定结果，unpark等待线程(调用get()方法而阻塞的线程),以及后续清理工作（一般由FutrueTask的子类实现） if (compareAndSetState(s, RAN)) &#123; result = v; releaseShared(0); done(); return; &#125; &#125;&#125; MutexMutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码 123456789101112131415161718192021222324// 判断是否锁定状态protected boolean isHeldExclusively() &#123; return getState() == 1;&#125;// 尝试获取资源，立即返回。成功则返回true，否则false。public boolean tryAcquire(int acquires) &#123; assert acquires == 1; // 这里限定只能为1个量 if (compareAndSetState(0, 1)) &#123;//state为0才设置为1，不可重入！ setExclusiveOwnerThread(Thread.currentThread());//设置为当前线程独占资源 return true; &#125; return false;&#125;// 尝试释放资源，立即返回。成功则为true，否则false。protected boolean tryRelease(int releases) &#123; assert releases == 1; // 限定为1个量 if (getState() == 0)//既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！ throw new IllegalMonitorStateException(); setExclusiveOwnerThread(null); setState(0);//释放资源，放弃占有状态 return true;&#125; 参考链接 深入剖析基于并发AQS的(独占锁)重入锁(ReetrantLock)及其Condition实现原理剖析基于并发AQS的共享锁的实现(基于信号量Semaphore)Java多线程（七）之同步器基础：AQS框架深入分析非阻塞算法简介","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"}]},{"title":"KMP","date":"2018-08-29T16:44:12.000Z","path":"2018/08/30/KMP/","text":"求next数组字符串组成为 p_0...p_k...p_i...p_{i+k}...p_j...p_{j+k}...p_m...p_{m+k}...假设\\(next_{[i+k]}==next_{[m+k]}\\)，表示\\(p_0…p_{i+k}=p_j…p_{m+k}\\) 如果\\(p_{i+k+1}=p_{m+k+1}\\)，则\\(next_{[m+k+1]}==next_{[m+k]}+1\\) 如果\\(p_{i+k+1}!=p_{m+k+1}\\)，有\\(next_{[i+k]}=k\\)，表示\\(p_0…p_{k}=p_i…p_{i+k}=p_m…p_{m+k}\\)， 如果\\(p_{m+k+1}=p_{k+1}\\)，则\\(next_{[m+k+1]}=next_{[k]}+1\\) 如果\\(p_{m+k+1}!=p_{k+1}\\)，则有\\(next_{[k]}=l\\)，继续上面的过程 总结下来，若\\(next_{[i]}==next_{[j]}\\) if \\(p_{i+1}=p_{j+1}\\), then \\(next_{[j+1]}==next_{[j]+1}\\) else \\(i==next_{[i]}\\),继续上一步 实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class KMP &#123; private int[] getNextArr(char[] pattern) &#123; if (pattern == null || pattern.length == 1) &#123; return new int[]&#123;-1&#125;; &#125; int[] next = new int[pattern.length]; next[0] = -1; next[1] = 0; int currentNext=0; int pos = 2; while (pos &lt; pattern.length) &#123; if (pattern[pos - 1] == pattern[currentNext]) &#123; next[pos++] = ++currentNext; &#125; else if (currentNext &gt; 0) &#123; currentNext = next[currentNext]; &#125; else &#123; next[pos++] = 0; &#125; &#125; return next; &#125; public int getIndexOf(String ori, String pattern) &#123; if (ori.length() &lt; pattern.length()) &#123; return -1; &#125; char[] oriArr = ori.toCharArray(); char[] patternArr = pattern.toCharArray(); int indexOfOri = 0; int indexOfPattern = 0; int[] next = getNextArr(patternArr); while (indexOfOri &lt; oriArr.length &amp;&amp; indexOfPattern &lt; patternArr.length) &#123; if (oriArr[indexOfOri] == patternArr[indexOfPattern]) &#123; indexOfOri++; indexOfPattern++; &#125; else if (next[indexOfPattern] &gt;= 0) &#123; indexOfPattern = next[indexOfPattern]; &#125; else &#123; indexOfOri++; &#125; &#125; return indexOfPattern == patternArr.length ? indexOfOri - indexOfPattern : -1; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"字符串匹配","slug":"字符串匹配","permalink":"http://yoursite.com/tags/字符串匹配/"}]},{"title":"内存屏障","date":"2018-08-23T15:15:18.000Z","path":"2018/08/23/内存屏障/","text":"内存屏障的目的每个CPU都会有自己的缓存（有的甚至L1,L2,L3），缓存的目的就是为了提高性能，避免每次都要向内存取。但是这样的弊端也很明显：不能实时的和内存发生信息交换，分在不同CPU执行的不同线程对同一个变量的缓存值不同 内存屏障的作用硬件层的内存屏障分为两种：Load Barrier 和 Store Barrier即读屏障和写屏障 对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据 对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见 内存屏障有两个作用 阻止屏障两侧的指令重排序 强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效 java内存屏障内存屏障可以被分为以下几种类型: LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。 StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。 LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。 StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能 volatile语义中的内存屏障volatile的内存屏障策略非常严格、悲观 在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障 在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障 volatile重排序规则： volatile写与之前的读写不能重排序 volatile读与之后的读写不能重排序 相邻的volatile之间不能重排序 volatile内存屏障规则： volatile写之前，所有的读写都必须已经完成 volatile读结束后，所有的读写才能开始 相邻的volatile必须有序实行 final语义中的内存屏障 新建对象过程中，构造体中对final域的初始化写入和这个对象赋值给其他引用变量，这两个操作不能重排序 123x.finalField = v; ... ;构建方法边界sharedRef = x;v.afield = 1; x.finalField = v; ... ; 构建方法边界sharedRef = x;这两条语句中，构建方法边界前后的指令都不能重排序。 初次读包含final域的对象引用和读取这个final域，这两个操作不能重排序 1x = sharedRef; ... ; i = x.finalField; 为了保证final字段的特殊语义，也会在下面的语句加入内存屏障 1x.finalField = v; StoreStore; sharedRef = x; 参考链接 内存屏障 JVM内存模型、指令重排、内存屏障概念解析 java内存模型 内存屏障","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"},{"name":"java内存模型","slug":"java内存模型","permalink":"http://yoursite.com/tags/java内存模型/"}]},{"title":"volatile","date":"2018-08-23T12:54:28.000Z","path":"2018/08/23/volatile/","text":"内存可见性volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值 线程写volatile变量的过程 改变线程工作内存中volatile变量副本的值 将改变后的副本的值从工作内存刷新到主内存 线程读volatile变量的过程 从主内存中读取volatile变量的最新值到线程的工作内存中 从工作内存中读取volatile变量的副本 禁止指令重排序多线程版本(错误的)123456789101112class Foo &#123; private Helper helper = null; public Helper getHelper() &#123; if (helper == null) synchronized(this) &#123; if (helper == null) helper = new Helper(); &#125; return helper; &#125; // other functions and members... &#125; volatile关键字修改版123456789101112class Foo &#123; private volatile Helper helper = null; public Helper getHelper() &#123; if (helper == null) &#123; synchronized (this) &#123; if (helper == null) helper = new Helper(); &#125; &#125; return helper; &#125;&#125; 在给helper对象初始化的过程中，jvm做了下面3件事: 给helper对象分配内存 调用构造函数 将helper对象指向分配的内存空间 由于jvm的”优化”,指令2和指令3的执行顺序是不一定的，当执行完指定3后，此时的helper对象就已经不在是null的了,但此时指令2不一定已经被执行。 假设线程1和线程2同时调用getHelper()方法，此时线程1执行完指令1和指令3，线程2抢到了执行权，此时helper对象是非空的 volatile关键字可以保证jvm执行的一定的“有序性”，在指令1和指令2执行完之前，指定3一定不会被执行 volatile变量被修改后立刻刷新会驻内存中 不保证复合操作的原子性1234567891011121314151617181920212223public class Test &#123; public volatile int inc = 0; public void increase() &#123; inc++; &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 线程A读取最新的值并在工作内存修改后，还未更新到主存就耗尽cpu时间片，等再次获取时间片后主存的变量值已被线程B修改，但线程A并未感知，继续将值更新到主存，导致B的修改无效","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"}]},{"title":"hexo高级特性","date":"2018-08-19T08:35:51.000Z","path":"2018/08/19/cool/","text":"网易云通过外链添加在网易云音乐的网页版生成歌单外链 1&lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=450 src=\"//music.163.com/outchain/player?type=0&amp;id=2343741251&amp;auto=1&amp;height=430\"&gt;&lt;/iframe&gt; 通过aplayer插件MeingJS 支持id为网页上url后面的id值1&#123;% meting \"468513829\" \"netease\" \"song\" \"autoplay\" \"mutex: true\" \"listmaxheight:340px\" \"preload:none\" \"theme:#ad7a86\"%&#125; 1&#123;% meting \"384485381\" \"netease\" \"playlist\" \"autoplay\" \"mutex: true\" \"listmaxheight:340px\" \"preload:none\" \"theme:#ad7a86\"%&#125; 行间公式 f(n)=\\begin{cases} n/2, & \\text{如果$ x2 $} \\end{cases}行内公式比如 \\(x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}\\)","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"新特性","slug":"新特性","permalink":"http://yoursite.com/tags/新特性/"}]},{"title":"mysql","date":"2018-08-19T05:47:35.000Z","path":"2018/08/19/mysql/","text":"基本概念mysql体系结构 参考链接 存储引擎 特点 MyISAM BDB Memory InnoDB Archive 存储限制 没有 没有 有 64TB 没有 事务安全 支持 支持 锁机制 表锁 页锁 表锁 行锁 行锁 B数索引 支持 支持 支持 支持 哈希索引 支持 支持 全文索引 支持 集群索引 支持 数据缓存 支持 支持 索引缓存 支持 支持 支持 数据可压缩 支持 支持 空间使用 低 低 N/A 高 非常低 内存使用 低 低 中等 高 低 批量插入的速度 高 高 高 低 非常高 支持外键 支持 InnoDB与MyISAM原理比较 InnoDB与MyISAM索引比较 索引索引的类型B-Tree索引参考链接B树中关键字集合分布在整棵树中，叶节点中不包含任何关键字信息，而B+树关键字集合分布在叶子结点中，非叶节点只是叶子结点中关键字的索引 Hash索引B Tree索引和哈希索引的区别 缺点不支持范围查询和排序、最左匹配规则 空间(R-Tree)索引 参考链接 全文(Full-text)索引类似es搜索的Lucene分词策略 参考链接 索引策略前缀索引高性能mysql章节 概念使用该列开始的部分长度字符串作 注意选择足够长的前缀以保证较高的选择性，同时又不能太长以便节约空间 缺点mysql无法使用其前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描 多列索引mysql多列索引的生效规则 聚簇索引(Clustered Indexes)及二级索引(辅助索引)高性能mysql章节 InnoDB与MyISAM的主键索引和二级索引的区别 聚集索引表数据按照索引的顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序一致。对于聚集索引，叶子结点即存储了真实的数据行，不再有另外单独的数据页。 在一张表上最多只能创建一个聚集索引，因为真实数据的物理顺序只能有一种 非聚集索引表数据存储顺序与索引顺序无关。对于非聚集索引，叶结点包含索引字段值及指向数据页数据行的逻辑指针，其行数量与数据表行数据量一致 覆盖索引(Covering Indexes)建立索引的字段正好是覆盖查询语句[select子句]与查询条件[Where子句]中所涉及的字段,数据列只用从索引中就能够取得，不必从数据表中读取参考&lt;&lt;高性能mysql&gt;&gt; 参考链接参考链接 其他压缩(前缀压缩)索引参考链接 重复索引相同列上按照相同的顺序创建的相同类型的索引 冗余索引若存在索引(a,b),则(a)是冗余,因为a是前缀,(a,b)可以当成(a)使用;（b,a）和(b)不是冗余索引 分形树(fractal treeindex)索引块级别元数据 Infobright高性能数据仓库 查询优化explain关键字参考链接 查询路径 参考链接 joinjoin原理 JOIN算法 Nested-Loop Join Simple Nested-Loop Join Index Nested-Loop Join Block Nested-Loop Join 哈希关联 合并连接 mysql高级特性分库、分区、分表、分片参考链接 视图内部存储代码存储过程函数触发器事件其他游标绑定变量XA查询缓存主从复制mvcc与锁MVCC原理 快照读当前读隔离级别Read UncommitedRead Committed (RC)Repeatable Read (RR)SerializableInnoDB两种类型的行锁共享锁（S）—读锁排他锁（X）—写锁行锁的三种情形Record lockGap lockNext-key LockInnoDB表锁意向共享锁（IS）意向排他锁（IX）InnoDB页面锁","tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"DB","slug":"DB","permalink":"http://yoursite.com/tags/DB/"}]},{"title":"spring cloud","date":"2018-08-19T05:12:12.000Z","path":"2018/08/19/springcloud/","text":"基础知识 四大神器 auto-configuration starters cli：Spring Boot Commad Line Autuator监控 服务注册与发现Eureka 参考链接 Feature Consul zookeeper etcd Eureka 服务健康检查 服务状态，内存，硬盘等 (弱)长连接，keepalive 连接心跳 可配支持 多数据中心 支持 — — — kv存储服务 支持 支持 支持 — 一致性 raft paxos raft — cap ca cp cp ap 使用接口(多语言能力) 支持http和dns 客户端 http/grpc http（sidecar） watch支持 全量/支持long polling 支持 支持 long polling 支持 long polling/大部分增量 自身监控 metrics — metrics metrics 安全 acl /https acl https支持（弱） — spring cloud集成 已支持 已支持 已支持 已支持 CAP理论与BASE思想服务发现的方式 客户端发现 服务器端发现 负载均衡LB方案参考链接1 参考链接2 硬负载 软负载 DNS负载 CDN负载 Ribbon核心组件 ServerList 用于获取地址列表。它既可以是静态的(提供一组固定的地址)，也可以是动态的(从注册中心中定期查询地址列表) ServerListFilter 仅当使用动态ServerList时使用，用于在原始的服务列表中使用一定策略过虑掉一部分地址 IRule 选择一个最终的服务地址作为LB结果。选择策略有轮询、根据响应时间加权、断路器(当Hystrix可用时)等 rest调用Feign容错处理参考链接1参考链接2 Hystrix 限流 降级 熔断 Dashboard 服务监控Turbine 聚合监控微服务网关Zuul过滤器机制 标准过滤器类型 PRE 鉴权 流量转发 ROUTING POST 跨域 统计 ERROR request生命周期 参考链接1 参考链接2 稳定性 隔离机制 重试机制 主要功能 验证与安全保障 审查与监控 动态路由 压力测试 负载分配 静态响应处理 多区域弹性 微服务配置Spring Cloud Config Spring Cloud Bus 参考链接 提交代码触发post请求给bus/refresh server端接收到请求并发送给Spring Cloud Bus Spring Cloud bus接到消息并通知给其它客户端 其它客户端接收到通知，请求Server端获取最新配置 全部客户端均获取到最新的配置 微服务跟踪Spring Cloud SleuthZipKinDocker入门Docker Compose","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"spring cloud","slug":"spring-cloud","permalink":"http://yoursite.com/tags/spring-cloud/"},{"name":"网关","slug":"网关","permalink":"http://yoursite.com/tags/网关/"},{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"java-concurrency","date":"2018-08-19T04:48:15.000Z","path":"2018/08/19/java-concurrency/","text":"concurrent包 locks(锁) 锁的种类锁分类1锁分类2 公平锁/非公平锁 可重入锁 可中断锁 独享锁/共享锁 互斥锁/读写锁 乐观锁/悲观锁 分段锁 偏向锁/轻量级锁/重量级锁 自旋锁 锁的优化锁的优化 减少锁持有时间 减小锁粒度 锁分离 锁粗化 锁消除 AQS参考链接参考1参考2AQS、ReetrantLock、Condition实现原理 重要方法: isHeldExclusively() tryAcquire(int) tryRelease(int) tryAcquireShared(int) tryReleaseShared(int) Lock参考链接参考1参考2 重要方法 lock() lockInterruptibly() throws InterruptedException tryLock() tryLock(long time, TimeUnit unit) throws InterruptedException unlock() Condition newCondition() ReentrantLock 参考链接 参考1 ReentrantReadWriteLock 参考链接参考1参考2 condition参考链接 生产者、消费者三种实现 atomic(原子变量) AtomicInteger AtomicLong AtomicBoolean AtomicReference AtomicIntegerArray/AtomicLongArray/AtomicReferenceArray CASexecutor(线程池)框架类图 ThreadPoolExecutor 构造方法和规则 执行原理 线程池终止 关键参数 workQueue(排队策略) threadFactory RejectedExecutionHandler(饱和策略) 常用方法 Executors 创建线程池 newFixedThreadPool newCachedThreadPool newSingleThreadExecutor newScheduledThreadPool collections(并发容器)List和Set CopyOnWriteArrayList 参考1 CopyOnWriteArraySet 参考1 Map ConcurrentHashMap 参考 ConcurrentSkipListMap 参考 ConcurrentSkipListSet Queue ArrayBlockingQueue 123final ReentrantLock lock;private final Condition notEmpty;private final Condition notFull; notEmpty和notFull是锁的两个Condition条件 实现原理 LinkedBlockingQueue LinkedBlockingDeque ConcurrentLinkedQueue ConcurrentLinkedDeque tools(同步工具) CountDownLatch CyclicBarrier Semaphore java内存模型java内存模型synchronized原理 内存模型概述 主内存 工作内存 Java内存模型与硬件内存架构的关系 特性 原子性 可见性 有序性 重排序 指令重排 编译器重排 as-if-serialhappens-before 原则 程序顺序原则 锁规则 volatile规则 线程启动规则 传递性 线程终止规则 线程中断规则 对象终结规则 volatile内存语义 可见性 禁止重排优化 内存屏障（Memory Barrier）参考链接 LoadLoad Barriers StoreStore Barriers LoadStore Barriers StoreLoad Barriers","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"},{"name":"jvm","slug":"jvm","permalink":"http://yoursite.com/tags/jvm/"}]},{"title":"Elasticsearch常用搜索","date":"2018-08-19T04:41:41.000Z","path":"2018/08/19/Elasticsearch/","text":"多字段查找multi_match 以下表达式等价于field1 = value1 or field2 = value1 12345678910GET index/type/_search&#123; \"query\": &#123; \"multi_match\": &#123; \"query\": \"value1\", \"fields\": [\"field1\",\"field2\"] &#125; &#125; , \"_source\": [\"field1\",\"field2\"]&#125; 布尔查询must等价于and,must_not等价于not, should等价于or 以下表达式等价于( field1 = value1 or field2 = value2 ) and field3 != value3 123456789101112131415161718192021222324252627282930313233343536GET index/type/_search&#123; \"size\": 100, \"query\": &#123; \"bool\": &#123; \"must\": [ &#123; \"bool\": &#123; \"should\": [ &#123; \"match\": &#123; \"field1\": \"value1\" &#125; &#125;, &#123; \"match\": &#123; \"field2\": \"value2\" &#125; &#125; ] &#125; &#125; ], \"must_not\": [ &#123; \"match\": &#123; \"field3\": \"value3\" &#125; &#125; ] &#125; &#125;, \"_source\": [ \"field1\",\"field2\",\"field3\" ]&#125; 模糊查询fuzziness 参考链接 123456789101112131415161718192021GET index/type/_search&#123; \"size\": 100, \"query\": &#123; \"bool\": &#123; \"must\": [ &#123; \"match\": &#123; \"city\": &#123; \"query\": \"Hoiliste\", \"fuzziness\": \"auto\" &#125; &#125; &#125; ] &#125; &#125;, \"_source\": [ \"city\" ]&#125; 通配符查询*匹配零个或多个字符 1234567891011121314151617181920GET index/type/_search&#123; \"size\": 100, \"query\": &#123; \"bool\": &#123; \"must\": [ &#123; \"wildcard\": &#123; \"field1\": &#123; \"value\": \"wu*\" &#125; &#125; &#125; ] &#125; &#125;, \"_source\": [ \"field1\" ]&#125; 正则查询regexp 123456789101112GET index/type/_search&#123; \"size\": 100, \"query\": &#123; \"regexp\":&#123; \"field1\":\"[a-zA-Z]+[0-9]*\" &#125; &#125;, \"_source\": [ \"field1\" ]&#125; 范围查询range 1234567891011121314151617GET index/type/_search&#123; \"size\": 100, \"query\": &#123; \"range\": &#123; \"field1\": &#123; \"from\": \"2018-04-16 05:22:39\", \"to\": \"2018-06-23 05:22:39\", \"include_lower\": true, \"include_upper\": true &#125; &#125; &#125;, \"_source\": [ \"field1\" ]&#125; 排序sort 1234567891011121314151617GET index/type/_search&#123; \"size\": 100, \"query\": &#123; \"bool\": &#123;&#125; &#125;, \"sort\": [ &#123; \"field1\": &#123; \"order\": \"desc\" &#125; &#125; ], \"_source\": [ \"field1\" ]&#125; 多重过滤filter 12345678910111213141516171819202122232425262728GET index/type/_search&#123; \"size\": 100, \"query\": &#123; \"bool\": &#123; \"filter\": [ &#123; \"bool\": &#123; \"must\": &#123; \"term\": &#123; \"field1\": \"value1\" &#125; &#125; &#125; &#125;, &#123; \"bool\": &#123; \"must\": &#123; \"term\": &#123; \"field2\": \"value1\" &#125; &#125; &#125; &#125; ] &#125; &#125;, \"_source\": [\"cityTerm\", \"mlsOrgId\"]&#125; 脚本查询参考链接 script支持Groovy、java等多种语言的脚本 12345678910111213141516171819&#123; \"query\": &#123; \"bool\": &#123; \"filter\": [ &#123; \"bool\": &#123; \"filter\": &#123; \"script\": &#123; \"script\": &#123; \"inline\": \"doc['field1'].value - doc['field2'].value &gt; 0\" &#125; &#125; &#125; &#125; &#125; ] &#125; &#125;&#125;","tags":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://yoursite.com/tags/Elasticsearch/"},{"name":"DSL","slug":"DSL","permalink":"http://yoursite.com/tags/DSL/"}]},{"title":"mysql分库、分区、分表、分片","date":"2018-08-19T01:20:32.000Z","path":"2018/08/19/mysql分库、分区、分表、分片/","text":"分表概念mysql的分表是真正的分表，一张表分成很多表后，每一个小表都是完正的一张表，都对应三个文件（MyISAM引擎：一个.MYD数据文件，.MYI索引文件，.frm表结构文件）分表后数据都是存放在分表里，总表只是一个外壳，存取数据发生在一个一个的分表里面 适用场景 一张表的查询速度已经慢到影响使用的时候 当频繁插入或者联合查询时，速度变慢 实现利用merge存储引擎来实现分表 1234567891011121314151617181920CREATE TABLE `tb_member1` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(20) DEFAULT NULL, `sex` tinyint(4) NOT NULL DEFAULT '0', PRIMARY KEY (`id`)) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8CREATE TABLE `tb_member2` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(20) DEFAULT NULL, `sex` tinyint(4) NOT NULL DEFAULT '0', PRIMARY KEY (`id`)) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8CREATE TABLE `tb_member` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(20) DEFAULT NULL, `sex` tinyint(4) NOT NULL DEFAULT '0', PRIMARY KEY (`id`)) ENGINE=MRG_MyISAM DEFAULT CHARSET=utf8 INSERT_METHOD=LAST UNION=(`tb_member1`,`tb_member2`) 说明 分表数据库引擎是MyISAM 分表与主表的字段定义一致 参考链接参考链接1 参考链接2 分区概念把存放数据的文件分成了许多小块，分区后的表还是一张表 适用场景 一张表的查询速度已经慢到影响使用的时候 表中的数据是分段的 对数据的操作往往只涉及一部分数据，而不是所有的数据 历史数据或不常访问的数据占很大部分，最新或热点数据占的比例不是很大，可以根据有些条件进行表分区。例如，表中有大量的历史记录，而“热数据”却位于表的末尾 分区类型 分区类型 特点 RANGE 基于属于一个给定连续区间的列值，把多行分配给分区 LIST 类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择 HASH 基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式 KEY 类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值 操作方式创建分区 1234567891011CREATE TABLE sales ( id INT AUTO_INCREMENT, amount DOUBLE NOT NULL, order_day DATETIME NOT NULL, PRIMARY KEY(id, order_day)) ENGINE=Innodb PARTITION BY RANGE(YEAR(order_day)) ( PARTITION p_2010 VALUES LESS THAN (2010), PARTITION p_2011 VALUES LESS THAN (2011), PARTITION p_2012 VALUES LESS THAN (2012),PARTITION p_catchall VALUES LESS THAN MAXVALUE); 常用操作 参考链接参考链接1 参考链接2 分库参考链接 分片参考链接","tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"java虚拟机","date":"2018-08-18T22:07:10.000Z","path":"2018/08/19/java虚拟机/","text":"运行时数据区 Java堆（Heap）对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。 根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 方法区（Method Area）方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。 对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。 Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。 根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 程序计数器（Program Counter Register）程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。 此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 JVM栈（JVM Stacks）与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。 其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。 本地方法栈（Native Method Stacks）本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 对象的访问定位句柄方式如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息 优点使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改 直接指针方式如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址 优点使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本 GC对象存活分析引用计数法原理给对象中每一个对象分配一个引用计数器，每当有地方引用该对象时，引用计数器的值加一，当引用失效时，引用计数器的值减一，不管什么时候，只要引用计数器的值等于0了，说明该对象不可能再被使用了 优缺点实现原理简单，而且判定效率很高。大部分情况下都是一个不错的算法。但很难解决对象之间相互循环引用的问题 可达性分析原理通过一系列被称为“GC Roots‘’的对象作为起始点，从这些节点向下搜索，搜索所走过的路径叫做引用链，当一个节点到GC Roots没有任何引用链时，证明该对象不可用了 被作为GC Roots的对象有以下几种: 虚拟机栈中引用的对象（栈帧中的引用变量表） 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中Native方法（JNI）引用的对象 方法区的垃圾回收永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类 废弃常量回收回收废弃常量与回收Java堆中的对象非常相似。以常量池中字面量的回收为例，若字符串“abc”已经进入常量池中，但当前系统没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用该字面量，若发生内存回收，且必要的话，该“abc”就会被系统清理出常量池。常量池中其他的类（接口）、方法、字段的符号引用与此类似 无用的类回收 该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例 加载该类的ClassLoader已经被回收 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法 在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出 新生代、老年代以及永久代 堆大小 = 新生代 + 老年代 新生代1个Eden区和2个Survivor区（分别叫from和to）,默认比例为8：1。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。 因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法 在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To” 老年代老年代与新生代不同，对象存活的时间比较长，比较稳定，因此采用标记（Mark）算法来进行回收 永久代在JDK的HotSpot虚拟机中，可以认为方法区就是永久代，但是在其他类型的虚拟机中，没有永久代的概念 GC分类 Minor GC 发生在新生代中的垃圾收集动作，所采用的是复制算法 FullGC (Major GC) 发生在老年代的垃圾收集动作，所采用的是标记-清除算法 JVM内存管理参数JVM参数使用总结 -Xms 设置堆的最小空间大小 -Xmx 设置堆的最大空间大小 -XX:NewSize 设置新生代最小空间大小 -XX:MaxNewSize 设置新生代最大空间大小 -XX:PermSize 设置永久代最小空间大小 -XX:MaxPermSize 设置永久代最大空间大小 -Xss 设置每个线程的堆栈大小。 -XX:NewRatio 设置新生代和老生代的相对大小 -XX:SurvivorRatio 指定Eden区和Survivor区的大小比例,注意两个幸存区是一样大的 垃圾收集算法 复制算法(新生代)该算法的核心是将可用内存按容量划分为大小相等的两块, 每次只用其中一块, 当这一块的内存用完, 就将还存活的对象复制到另外一块上面, 然后把已使用过的内存空间一次清理掉 标记清除算法(老年代)该算法分为“标记”和“清除”两个阶段: 首先标记出所有需要回收的对象(可达性分析), 在标记完成后统一清理掉所有被标记的对象 该算法会有以下两个问题 效率问题: 标记和清除过程的效率都不高; 空间问题: 标记清除后会产生大量不连续的内存碎片, 空间碎片太多可能会导致在运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集 标记整理算法(老年代)标记清除算法会产生内存碎片问题, 而复制算法需要有额外的内存担保空间, 于是针对老年代的特点, 又有了标记整理算法. 标记整理算法的标记过程与标记清除算法相同, 但后续步骤不再对可回收对象直接清理, 而是让所有存活的对象都向一端移动,然后清理掉端边界以外的内存 垃圾收集器 参考链接1参考链接2 串行收集器 Serial开头的 Serial Serial Old(MSC) 并行收集器 Parallel开头的 ParNew Parallel Scavenge Parallel Old 并发收集器 CMS (Concurrent Mark Sweep) G1(Garbage First) 图片中的问号位置 JDK 1.7后有G1 GC日志日志格式 1[GC（GC类型，当前是Minor GC） (Allocation Failure) [DefNew（GC的区域，当前为新生代）: 5688K（垃圾回收前的大小）-&gt;790K（垃圾回收以后的大小）(9216K)（该区域总大小）, 0.0060899 secs] 5688K（堆在垃圾回收前的大小）-&gt;4886K（堆在垃圾回收后的大小）(19456K)（堆的总大小）, 0.0061183 secs] [Times: user=0.00（用户态消耗CPU时间） sys=0.01（内核态小时CPU时间）, real=0.00 secs（操作的实际时间）] 参考链接 大对象直接进入老年代 长期存活的对象进入老年代 Class文件结构 参考系列 类加载机制 参考链接参考章节 加载 通过一个类的全限定名来获取其定义的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口 除了可以使用系统提供的引导类加载器外，还可以使用用户自定义的类加载器。任意一个类，都需要由加载它的类加载器和这个类本身共同确定其在Java 虚拟机中的唯一性 类加载器 启动类加载器：启动类加载器无法被 java 程序直接引用，如需要，直接使用 null 代替即可 扩展类加载器 应用程序类加载器：它负责加载用户路径(ClassPath)上所指定的类库，开发者可以使用这个类加载器，如果应用程序没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器 双亲委派模型如果一个类加载器收到了类加载器的请求，它首先不会自己尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类时），子加载类才会尝试自己去加载 验证验证阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全 文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，主要是验证类的继承关系、数据类型是否符合 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。对类的方法体进行校验分析，以保证被校验类的方法在运行时不会做出危害虚拟机安全的事件 符号引用验证：发生在虚拟机将符号引用转化为直接引用的时候,对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配 这阶段进行内存分配的仅包括类变量（即被static修饰的变量），不包括实例变量 这里所说的初始值“通常情况”下是数据类型的零值 解析解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程 符号引用（Symbolic References）：即用一组符号来描述所引用的目标。它与虚拟机的内存布局无关，引用的目标不一定已经加载到内存中 直接引用（Direct References）：直接引用可以是指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。它是和虚拟机内存布局相关的，如果有了直接引用，那引用的目标必定已经在内存中存在了 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7类符号引用进行 初始化初始化是类加载过程的最后一步，此阶段才开始真正执行类中定义的Java程序代码（或者说字节码，也仅限与执行()方法）。在准备阶段，我们已经给变量付过一次系统要求的初始值（零值），而在初始化阶段，则会根据程序员的意愿给类变量和其他资源赋值。主要是通过()方法来执行的 虚拟机字节码执行引擎章节参考 Java编译期优化 解析与填充符号表过程解析步骤包含了词法分析和语法分析两个过程，首先词法分析是将源代码的字符流转变成为标记集合（token），然后语法分析是根据token序列来构造抽象语法树（一种用来描述程序代码语法结构的树状表示方式）。完成词法分析和语法分析之后，下一步是填充符号表，符号表是由一组符号地址和符号信息构成的表格，符号表中所登记的信息在编译的不同阶段都要用到（比如语义分析中符号表所登记的内容将用于语义检查和产生中间代码，目标代码生成阶段当对符号名进行地址分配时，符号表是地址分配的依据） 插入式注解处理器的注解处理过程插入式注解处理器可以看做是一组编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，那么编译器将回到解析及填充符号表的过程重新处理，直到所有的插入式注解处理器都没有再对语法树进行修改为止 语义分析与字节码生成过程语法分析之后，编译器获得了程序代码的抽象语法树表示，语法树能够表示结构正确的源程序的抽象，但是无法保证源程序是否符合逻辑，而语义分析主要是对结构上正确的源程序进行上下文有关性质的检查 标注检查标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配，等等。还有一个重要的动作称为常量折叠也在此阶段完成 数据及控制流分析数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否有返回值、是否所有的受查异常都被正确处理了等问题 解语法糖语法糖是指在计算机语言中添加某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。java中的泛型，变长参数，自动拆箱与装箱，条件编译等就属于语法糖，它们在编译阶段就被还原成简单的语法结构（比如List和List在运行期间其实是同一个类） 字节码生成此过程是javac编译过程的最后一个阶段，字节码生成阶段将之前各个步骤所生成的信息转化成字节码写到磁盘中，另外还进行少量的代码添加和转换工作 Java运行期优化 在部分商用虚拟机中，java程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块运行特别频繁，就会把这些代码认定为“热点代码”，为了提高热点代码的执行效率，在运行时，虚拟机就会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器或JIT编译器。 即时编译器并不是虚拟机必须的部分，但是即时编译器编译性能的好坏、代码优化程度的高低确是衡量一款商用虚拟机优秀与否的最关键的指标之一。 众多主流的虚拟机都同时包含解释器和JIT编译器，解释器与JIT编译器各有优势：当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行。当程序运行后，随着事件的推移，JIT编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率 会被即时编译器编译的热点代码有两类 被多次调用的方法体 被多次调用的循环体 即时编译器会以整个方法作为编译对象，将其编译成机器码。这种编译方式因为编译发生在方法执行过程之中，因此被称作栈上替换（OSR） 判断一段代码是否是热点代码的方式（热点探测）有两种 基于采样的热点探测：此方法会周期性检查各个线程的栈顶，如果发现某个或某些方法经常出现在栈顶，那么这个方法就是热点方法。此方法的缺点是很难精确地确认一个方法的热度，容易受到诸如线程阻塞等因素影响 基于计数器的热点探测：此方法会为每个方法甚至是代码块建立计数器，统计方法的执行次数，如果执行次数超过一个阀值就认为它是热点方法 默认设置下，执行引擎并不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成。当编译工作完成之后，这个方法的调用入口地址就会被系统自动改写成新的地址，下一次调用该方法时就会使用已编译的版本。也就是说，在编译器还未完成之前，执行引擎仍按照解释方式继续执行，而编译动作则在后台的编译线程中进行 优化技术一般来说即时编译器所产生的本地代码会比javac产生的字节码更优秀。即时编译器采用了一系列的技术来优化代码，比如公共子表达式消除，数组范围内检查消除，方法内联，逃逸分析等","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://yoursite.com/tags/jvm/"}]}]
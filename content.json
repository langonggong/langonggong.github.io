[{"title":"http","date":"2018-10-14T07:33:17.000Z","path":"2018/10/14/http/","text":"长连接短连接轮询WebSocket","tags":[{"name":"http","slug":"http","permalink":"http://langonggong.com/tags/http/"}]},{"title":"tomcat","date":"2018-10-13T07:11:17.000Z","path":"2018/10/13/tomcat/","text":"tomcat架构Tomcat系统架构 Tomcat系统架构 Tomcat系统架构 ConnectorConnector 分析 Tomcat中的设计模式设计模式 责任链模式","tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://langonggong.com/tags/tomcat/"}]},{"title":"代理","date":"2018-10-09T15:45:25.000Z","path":"2018/10/09/代理/","text":"正向代理正向代理（Forward Proxy）方式下，使用者需要配置网络访问的代理服务器为Cache设备的地址，内网对互联网的所有访问都是通过代理服务器完成 正向代理多用于与小企业网络环境，Cache设备作为企业网的出口网关提供代理服务（例如翻墙访问谷歌）、内容缓存、Internet访问控制、安全认证等功能 反向代理透明代理","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://langonggong.com/tags/计算机网络/"}]},{"title":"CND加速","date":"2018-10-05T14:01:53.000Z","path":"2018/10/05/CND加速/","text":"网页加速CDN服务商通过将网页内容缓存到各个CND节点上，并将用户请求调度到最优节点上来获取所需的内容，从而加速页面相应速度、减轻源站点的访问负担 流媒体加速将流媒体内容推送到离用户最近的POP点，使得用户能够从网络边缘获取内容，从而提高视频传输质量，缩短访问时间，节省骨干网络流量，避免单一中心的服务器瓶颈问题 文件传输加速使用CND分布式POP点提供下载服务，网站可以将大量文件下载的性能压力和带宽压力交给CND来分担，提高用户的下载速度 应用协议加速不针对特定内容类型进行加速，而是通过对TCP/IP等传输协议优化，或对SSL协议加速 广域网应用加速目的是“让广域网像局域网一样” 将分布式的IT基础设施如文件服务器、邮件服务器、网络附加存储（NAS）和远程办公室备份系统集中起来，整合到统一的数据中心 SSL应用加速由CDN的专用SSL加速硬件来完成加密解密运算工作，通过认证之后方可建立起数据传输通道。用户的源站点只需信任有限的CDN cache，而无需面对海量用户，从而减轻了繁重的运算和认证压力 网页压缩可以在服务器端对网页数据进行压缩，将压缩后的文件提供给用户，在浏览器端解压显示。CDN为网站提供网页内容的压缩传输，从而加快内容传输速度","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://langonggong.com/tags/计算机网络/"},{"name":"CDN","slug":"CDN","permalink":"http://langonggong.com/tags/CDN/"}]},{"title":"负载均衡","date":"2018-10-05T13:52:21.000Z","path":"2018/10/05/负载均衡/","text":"全局负载均衡（GSLB）DNS解析本地负载均衡（SLB）4层调度7层调度链路负载调度","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://langonggong.com/tags/计算机网络/"}]},{"title":"CDN","date":"2018-10-05T13:49:15.000Z","path":"2018/10/05/CDN/","text":"","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://langonggong.com/tags/计算机网络/"},{"name":"CDN","slug":"CDN","permalink":"http://langonggong.com/tags/CDN/"}]},{"title":"uml","date":"2018-10-03T02:43:16.000Z","path":"2018/10/03/uml/","text":"类图","tags":[{"name":"软件工程","slug":"软件工程","permalink":"http://langonggong.com/tags/软件工程/"},{"name":"uml","slug":"uml","permalink":"http://langonggong.com/tags/uml/"}]},{"title":"linux IO模型","date":"2018-09-27T11:49:04.000Z","path":"2018/09/27/IO模型/","text":"简介在linux系统下面，根据IO操作的是否被阻塞以及同步异步问题进行分类，可以得到下面五种IO模型 阻塞I/O（blocking I/O） 非阻塞I/O （nonblocking I/O） I/O复用(select 和poll) （I/O multiplexing） 信号驱动I/O （signal driven I/O (SIGIO)） 异步I/O （asynchronous I/O (the POSIX aio_functions)） 对于一个network IO (以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段： 等待数据准备 (Waiting for the data to be ready) 将数据从内核拷贝到进程中(Copying the data from the kernel to the process) 这些IO模型的区别就是在两个阶段上各有不同的情况 阻塞IO（blocking IO） 调用blocking IO会一直block住对应的进程直到操作完成 非阻塞IO（non-blocking IO） 在kernel还在准备数据的情况下会立刻返回。在执行recvfrom这个系统调用的时候，如果kernel的数据没有准备好，这时候不会block进程。但是当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内进程是被block的 同步IO（synchronous IO） 做IO 操作的时候会将进程阻塞。按照这个定义，blocking IO，non-blocking IO，IO multiplexing都属于同步IO 异步IO（asynchronous IO） 当进程发起IO操作之后，就直接返回，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block 详解阻塞IO（blocking IO） 当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。 所以，blocking IO的特点就是在IO执行的两个阶段（等待数据和拷贝数据两个阶段）都被block了。 可能同时出现的上千甚至上万次的客户端请求，“线程池”或“连接池”或许可以缓解部分压力，但是不能解决所有问题。总之，多线程模型可以方便高效的解决小规模的服务请求，但面对大规模的服务请求，多线程模型也会遇到瓶颈，可以用非阻塞接口来尝试解决这个问题 非阻塞IO（non-blocking IO）Linux下，可以通过设置socket使其变为non-blocking 从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。 所以，在非阻塞式IO中，用户进程其实是需要不断的主动询问kernel数据准备好了没有。 循环调用recv()将大幅度推高CPU 占用率；此外，在这个方案中recv()更多的是起到检测“操作是否完成”的作用，实际操作系统提供了更为高效的检测“操作是否完成“作用的接口，例如select()多路复用模式，可以一次检测多个连接是否活跃 多路复用IO（IO multiplexing）有些地方也称这种IO方式为事件驱动IO(event driven IO)。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程 当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。 这个图和blocking IO的图其实并没有太大的不同，事实上还更差一些。因为这里需要使用两个系统调用(select和recvfrom)，而blocking IO只调用了一个系统调用(recvfrom)。但是，用select的优势在于它可以同时处理多个connection 在多路复用模型中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。因此select()与非阻塞IO类似 select()接口并不是实现“事件驱动”的最好选择。因为当需要探测的句柄值较大时，select()接口本身需要消耗大量时间去轮询各个句柄 信号驱动I/O（signal driven I/O） 两次调用，两次返回允许套接口进行信号驱动I/O,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据 异步I/O （asynchronous I/O） 用户进程发起read操作之后，立刻就可以开始去做其它的事。从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了 对比非阻塞IO ，IO请求时加上O_NONBLOCK一类的标志位，立刻返回，IO没有就绪会返回错误，需要请求进程主动轮询不断发IO请求直到返回正确。 IO复用同非阻塞IO本质一样，不过利用了新的select系统调用，由内核来负责本来是请求进程该做的轮询操作。看似比非阻塞IO还多了一个系统调用开销，不过因为可以支持多路IO，才算提高了效率。 信号驱动IO，调用sigaltion系统调用，当内核中IO数据就绪时以SIGIO信号通知请求进程，请求进程再把数据从内核读入到用户空间，这一步是阻塞的。 异步IO，如定义所说，不会因为IO操作阻塞，IO操作全部完成才通知请求进程 左边四种方式，第一阶段不同，第二阶段相同（调用recvFrom发生阻塞） 参考链接 socket阻塞与非阻塞，同步与异步、I/O模型网络IO模型","tags":[{"name":"linux","slug":"linux","permalink":"http://langonggong.com/tags/linux/"},{"name":"IO","slug":"IO","permalink":"http://langonggong.com/tags/IO/"}]},{"title":"BlockingQueue","date":"2018-09-25T07:53:14.000Z","path":"2018/09/25/BlockingQueue/","text":"阻塞队列与我们平常接触的普通队列(LinkedList或ArrayList等)的最大不同点，在于阻塞队列支出阻塞添加和阻塞删除方法 Java中的阻塞队列接口BlockingQueue继承自Queue接口123456789101112131415161718192021222324public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; &#123; //将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量） //在成功时返回 true，如果此队列已满，则抛IllegalStateException。 boolean add(E e); //将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量） // 将指定的元素插入此队列的尾部，如果该队列已满， //则在到达指定的等待时间之前等待可用的空间,该方法可中断 boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException; //将指定的元素插入此队列的尾部，如果该队列已满，则一直等到（阻塞）。 void put(E e) throws InterruptedException; //获取并移除此队列的头部，如果没有元素则等待（阻塞）， //直到有元素将唤醒等待线程执行该操作 E take() throws InterruptedException; //获取并移除此队列的头部，在指定的等待时间前一直等到获取元素， //超过时间方法将结束 E poll(long timeout, TimeUnit unit) throws InterruptedException; //从此队列中移除指定元素的单个实例（如果存在）。 boolean remove(Object o); &#125; 插入方法：add(E e) : 添加成功返回true，失败抛IllegalStateException异常offer(E e) : 成功返回 true，如果此队列已满，则返回 false。put(E e) :将元素插入此队列的尾部，如果该队列已满，则一直阻塞 删除方法:remove(Object o) :移除指定元素,成功返回true，失败返回falsepoll() : 获取并移除此队列的头元素，若队列为空，则返回 nulltake()：获取并移除此队列头元素，若没有元素则一直阻塞。 检查方法element() ：获取但不移除此队列的头元素，没有元素则抛异常peek() :获取但不移除此队列的头；若队列为空，则返回 null。 ArrayBlockingQueue原理ArrayBlockingQueue的内部是通过一个可重入锁ReentrantLock和两个Condition条件对象来实现阻塞123456789101112131415161718192021222324252627282930public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable &#123; /** 存储数据的数组 */ final Object[] items; /**获取数据的索引，主要用于take，poll，peek，remove方法 */ int takeIndex; /**添加数据的索引，主要用于 put, offer, or add 方法*/ int putIndex; /** 队列元素的个数 */ int count; /** 控制并非访问的锁 */ final ReentrantLock lock; /**notEmpty条件对象，用于通知take方法队列已有元素，可执行获取操作 */ private final Condition notEmpty; /**notFull条件对象，用于通知put方法队列未满，可执行添加操作 */ private final Condition notFull; /** 迭代器 */ transient Itrs itrs = null;&#125; put方法put方法，它是一个阻塞添加的方法123456789101112131415//put方法，阻塞时可中断 public void put(E e) throws InterruptedException &#123; checkNotNull(e); final ReentrantLock lock = this.lock; lock.lockInterruptibly();//该方法可中断 try &#123; //当队列元素个数与数组长度相等时，无法添加元素 while (count == items.length) //将当前调用线程挂起，添加到notFull条件队列中等待唤醒 notFull.await(); enqueue(e);//如果队列没有满直接添加。。 &#125; finally &#123; lock.unlock(); &#125; &#125; take方法take()方法，是一个阻塞方法，直接获取队列头元素并删除1234567891011121314//从队列头部删除，队列没有元素就阻塞，可中断 public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly();//中断 try &#123; //如果队列没有元素 while (count == 0) //执行阻塞操作 notEmpty.await(); return dequeue();//如果队列有元素执行删除操作 &#125; finally &#123; lock.unlock(); &#125; &#125; LinkedBlockingQueueLinkedBlockingQueue是一个由链表实现的有界队列阻塞队列，但大小默认值为Integer.MAX_VALUE，所以在使用LinkedBlockingQueue时建议手动传值，为其提供我们所需的大小，避免队列过大造成机器负载或者内存爆满等情况 在正常情况下，链接队列的吞吐量要高于基于数组的队列（ArrayBlockingQueue），因为其内部实现添加和删除操作使用的两个ReenterLock来控制并发执行，而ArrayBlockingQueue内部只是使用一个ReenterLock控制并发，因此LinkedBlockingQueue的吞吐量要高于ArrayBlockingQueue12345678910111213141516171819202122232425262728293031323334353637383940414243public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable &#123; /** * 节点类，用于存储数据 */ static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node(E x) &#123; item = x; &#125; &#125; /** 阻塞队列的大小，默认为Integer.MAX_VALUE */ private final int capacity; /** 当前阻塞队列中的元素个数 */ private final AtomicInteger count = new AtomicInteger(); /** * 阻塞队列的头结点 */ transient Node&lt;E&gt; head; /** * 阻塞队列的尾节点 */ private transient Node&lt;E&gt; last; /** 获取并移除元素时使用的锁，如take, poll, etc */ private final ReentrantLock takeLock = new ReentrantLock(); /** notEmpty条件对象，当队列没有数据时用于挂起执行删除的线程 */ private final Condition notEmpty = takeLock.newCondition(); /** 添加元素时使用的锁如 put, offer, etc */ private final ReentrantLock putLock = new ReentrantLock(); /** notFull条件对象，当队列数据已满时用于挂起执行添加的线程 */ private final Condition notFull = putLock.newCondition();&#125; take方法 如果队列没有数据就挂起当前线程到 notEmpty条件对象的等待队列中一直等待，如果有数据就删除节点并返回数据项，同时唤醒后续消费线程(如果不为空) 尝试唤醒条件对象notFull上等待队列中的添加线程 123456789101112131415161718192021public E take() throws InterruptedException &#123; E x; int c = -1; final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; takeLock.lockInterruptibly(); try &#123; while (count.get() == 0) &#123; notEmpty.await(); &#125; x = dequeue(); c = count.getAndDecrement(); if (c &gt; 1) notEmpty.signal(); &#125; finally &#123; takeLock.unlock(); &#125; if (c == capacity) signalNotFull(); return x;&#125; 123456789private void signalNotFull() &#123; final ReentrantLock putLock = this.putLock; putLock.lock(); try &#123; notFull.signal(); &#125; finally &#123; putLock.unlock(); &#125;&#125; put方法 如果队列已满就挂起当前线程到notFull条件对象的等待队列中一直等待，如果有空余节点就添加当前节点，同时唤醒后续生产线程(如果队列未满) 尝试唤醒条件对象notEmpty上等待队列中的添加线程 123456789101112131415161718192021public void put(E e) throws InterruptedException &#123; if (e == null) throw new NullPointerException(); int c = -1; Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; putLock.lockInterruptibly(); try &#123; while (count.get() == capacity) &#123; notFull.await(); &#125; enqueue(node); c = count.getAndIncrement(); if (c + 1 &lt; capacity) notFull.signal(); &#125; finally &#123; putLock.unlock(); &#125; if (c == 0) signalNotEmpty();&#125; 123456789private void signalNotEmpty() &#123; final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try &#123; notEmpty.signal(); &#125; finally &#123; takeLock.unlock(); &#125;&#125; 区别 队列大小有所不同，ArrayBlockingQueue是有界的初始化必须指定大小，而LinkedBlockingQueue可以是有界的也可以是无界的(Integer.MAX_VALUE)，对于后者而言，当添加速度大于移除速度时，在无界的情况下，可能会造成内存溢出等问题。 数据存储容器不同，ArrayBlockingQueue采用的是数组作为数据存储容器，而LinkedBlockingQueue采用的则是以Node节点作为连接对象的链表。 由于ArrayBlockingQueue采用的是数组的存储容器，因此在插入或删除元素时不会产生或销毁任何额外的对象实例，而LinkedBlockingQueue则会生成一个额外的Node对象。这可能在长时间内需要高效并发地处理大批量数据的时，对于GC可能存在较大影响。 两者的实现队列添加或移除的锁不一样，ArrayBlockingQueue实现的队列中的锁是没有分离的，即添加操作和移除操作采用的同一个ReenterLock锁，而LinkedBlockingQueue实现的队列中的锁是分离的，其添加采用的是putLock，移除采用的则是takeLock，这样能大大提高队列的吞吐量，也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。","tags":[{"name":"java","slug":"java","permalink":"http://langonggong.com/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://langonggong.com/tags/多线程/"}]},{"title":"synchronized","date":"2018-09-23T07:59:04.000Z","path":"2018/09/23/synchronized/","text":"对象的内存布局 对象头标记字（32位虚拟机4B，64位虚拟机8B） + 类型指针（32位虚拟机4B，64位虚拟机8B）+ [数组长（对于数组对象才需要此部分信息）]。用于存储对象的元数据信息 Mark Word：数据的长度在32位和64位虚拟机（未开启压缩指针）中分别为32bit和64bit，存储对象自身的运行时数据如哈希值等。Mark Word一般被设计为非固定的数据结构，以便存储更多的数据信息和复用自己的存储空间。 类型指针：指向它的类元数据的指针，用于判断对象属于哪个类的实例 实例数据存储的是真正有效数据，如各种字段内容，各字段的分配策略为longs/doubles、ints、shorts/chars、bytes/boolean、oops(ordinary object pointers)，相同宽度的字段总是被分配到一起，便于之后取数据。父类定义的变量会出现在子类定义的变量的前面 对齐填充对于64位虚拟机来说，对象大小必须是8B的整数倍，不够的话需要占位填充。仅仅起到占位符的作用，并非必须 Java对象头对象头信息是与对象自身定义的数据无关的额外存储成本，但是考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据，它会根据对象的状态复用自己的存储空间，也就是说，Mark Word会随着程序的运行发生变化，变化状态如下（32位虚拟机） 锁状态 25 bit 4 bit 1 bit 2 bit 23 bit 2 bit 是否是偏向锁 锁标志位 无锁状态 对象HashCode 对象分代年龄 0 01 轻量级锁 指向栈中锁记录的指针 00 偏向锁 线程ID Epoch 对象分代年龄 1 01 重量级锁 指向互斥量（重量级锁）的指针 10 GC标记 空 11 monitor重量级锁也就是通常说synchronized的对象锁，锁标识位为10，其中指针指向的是monitor对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的） 123456789101112131415161718ObjectMonitor() &#123; _header = NULL; _count = 0; //记录个数 _waiters = 0, _recursions = 0; _object = NULL; _owner = NULL; _WaitSet = NULL; //处于wait状态的线程，会被加入到_WaitSet _WaitSetLock = 0 ; _Responsible = NULL ; _succ = NULL ; _cxq = NULL ; FreeNext = NULL ; _EntryList = NULL ; //处于等待锁block状态的线程，会被加入到该列表 _SpinFreq = 0 ; _SpinClock = 0 ; OwnerIsThread = 0 ; &#125; ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表( 每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSe t集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示 锁的类型锁可以升级但不能降级，目的是为了提高获得锁和释放锁的效率1无锁 --&gt; 偏向锁 --&gt; 轻量级 --&gt; 重量级 偏向锁引入背景：大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁，减少不必要的CAS操作。 加锁：当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程（此时会引发竞争，偏向锁会升级为轻量级锁）。 膨胀过程：当前线程执行CAS获取偏向锁失败（这一步是偏向锁的关键），表示在该锁对象上存在竞争并且这个时候另外一个线程获得偏向锁所有权。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，并从偏向锁所有者的私有Monitor Record列表中获取一个空闲的记录，并将Object设置LightWeight Lock状态并且Mark Word中的LockRecord指向刚才持有偏向锁线程的Monitor record，最后被阻塞在安全点的线程被释放，进入到轻量级锁的执行路径中，同时被撤销偏向锁的线程继续往下执行同步代码。 轻量级锁引入背景：这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态（即单线程执行环境），在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒 加锁：（1）当对象处于无锁状态时（RecordWord值为HashCode，状态位为001），线程首先从自己的可用moniter record列表中取得一个空闲的moniter record，初始Nest和Owner值分别被预先设置为1和该线程自己的标识，一旦monitor record准备好然后我们通过CAS原子指令安装该monitor record的起始地址到对象头的LockWord字段，如果存在其他线程竞争锁的情况而调用CAS失败，则只需要简单的回到monitorenter重新开始获取锁的过程即可。 （2）对象已经被膨胀同时Owner中保存的线程标识为获取锁的线程自己，这就是重入（reentrant）锁的情况，只需要简单的将Nest加1即可。不需要任何原子操作，效率非常高。 （3）对象已膨胀但Owner的值为NULL，当一个锁上存在阻塞或等待的线程同时锁的前一个拥有者刚释放锁时会出现这种状态，此时多个线程通过CAS原子指令在多线程竞争状态下试图将Owner设置为自己的标识来获得锁，竞争失败的线程在则会进入到第四种情况（4）的执行路径。 （4）对象处于膨胀状态同时Owner不为NULL(被锁住)，在调用操作系统的重量级的互斥锁之前先自旋一定的次数，当达到一定的次数时如果仍然没有成功获得锁，则开始准备进入阻塞状态，首先将rfThis的值原子性的加1，由于在加1的过程中可能会被其他线程破坏Object和monitor record之间的关联，所以在原子性加1后需要再进行一次比较以确保LockWord的值没有被改变，当发现被改变后则要重新monitorenter过程。同时再一次观察Owner是否为NULL，如果是则调用CAS参与竞争锁，锁竞争失败则进入到阻塞状态。 不同锁的比较 锁 优点 缺点 适用场景 偏向锁 加锁和解锁不需要额外的消耗，和执行非同步方法仅存在纳秒级差别 如果线程间存在竞争，会带来额外的锁撤销的消耗 适用于只有一个线程访问同步块的场景 轻量级锁 竞争的线程不会阻塞，提高响应速度 始终得不到锁的竞争线程自旋消耗CPU 追求响应时间，同步代码块执行较快 重量级锁 线程竞争不使用自旋，不消耗CPU 线程阻塞，响应时间慢 追求吞吐量，同步块执行比较慢 参考链接 深入理解Java并发之synchronized实现原理Java中synchronized的实现原理与应用","tags":[{"name":"java","slug":"java","permalink":"http://langonggong.com/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://langonggong.com/tags/多线程/"}]},{"title":"condition","date":"2018-09-22T01:14:04.000Z","path":"2018/09/22/condition/","text":"引言在java中，对于任意一个java对象，它都拥有一组定义在java.lang.Object上监视器方法，包括wait()，wait(long timeout)，notify()，notifyAll()，这些方法配合synchronized关键字一起使用可以实现等待/通知模式。 同样，Condition接口也提供了类似Object监视器的方法，通过与Lock配合来实现等待/通知模式 对比项 Object监视器 Condition 前置条件 获取对象的锁 调用Lock.lock获取锁，调用Lock.newCondition获取Condition对象 调用方式 直接调用，比如object.notify() 直接调用，比如condition.await() 等待队列的个数 一个 多个 当前线程释放锁进入等待状态 支持 支持 当前线程释放锁进入等待状态，在等待状态中不断响中断 不支持 支持 当前线程释放锁并进入超时等待状态 支持 支持 当前线程释放锁并进入等待状态直到将来的某个时间 不支持 支持 唤醒等待队列中的一个线程 支持 支持 唤醒等待队列中的全部线程 支持 支持 示例实现一个简单的有界队列，队列为空时，队列的删除操作将会阻塞直到队列中有新的元素，队列已满时，队列的插入操作将会阻塞直到队列出现空位 主要方法1234567891011121314151617181920212223242526272829303132public interface Condition &#123; /** * 使当前线程进入等待状态直到被通知(signal)或中断 * 当其他线程调用singal()或singalAll()方法时，该线程将被唤醒 * 当其他线程调用interrupt()方法中断当前线程 * await()相当于synchronized等待唤醒机制中的wait()方法 */ void await() throws InterruptedException; //当前线程进入等待状态，直到被唤醒，该方法不响应中断要求 void awaitUninterruptibly(); //调用该方法，当前线程进入等待状态，直到被唤醒或被中断或超时 //其中nanosTimeout指的等待超时时间，单位纳秒 long awaitNanos(long nanosTimeout) throws InterruptedException; //同awaitNanos，但可以指明时间单位 boolean await(long time, TimeUnit unit) throws InterruptedException; //调用该方法当前线程进入等待状态，直到被唤醒、中断或到达某个时 //间期限(deadline),如果没到指定时间就被唤醒，返回true，其他情况返回false boolean awaitUntil(Date deadline) throws InterruptedException; //唤醒一个等待在Condition上的线程，该线程从等待方法返回前必须 //获取与Condition相关联的锁，功能与notify()相同 void signal(); //唤醒所有等待在Condition上的线程，该线程从等待方法返回前必须 //获取与Condition相关联的锁，功能与notifyAll()相同 void signalAll();&#125; 实现原理Condition的具体实现类是AQS的内部类ConditionObject。AQS中存在两种队列，一种是同步队列，一种是等待队列，而等待队列就相对于Condition而言的。注意在使用Condition前必须获得锁，同时在Condition的等待队列上的结点与前面同步队列的结点是同一个类即Node，其结点的waitStatus的值为CONDITION。在实现类ConditionObject中有两个结点分别是firstWaiter和lastWaiter，firstWaiter代表等待队列第一个等待结点，lastWaiter代表等待队列最后一个等待结点，如下 1234567public class ConditionObject implements Condition, java.io.Serializable &#123; //等待队列第一个等待结点 private transient Node firstWaiter; //等待队列最后一个等待结点 private transient Node lastWaiter; //省略其他代码.......&#125; 每个Condition都对应着一个等待队列，也就是说如果一个锁上创建了多个Condition对象，那么也就存在多个等待队列。等待队列是一个FIFO的队列，在队列中每一个节点都包含了一个线程的引用，而该线程就是Condition对象上等待的线程。当一个线程调用了await()相关的方法，那么该线程将会释放锁，并构建一个Node节点封装当前线程的相关信息加入到等待队列中进行等待，直到被唤醒、中断、超时才从队列中移出 await()实现123456789101112131415161718192021222324252627public final void await() throws InterruptedException &#123; //判断线程是否被中断 if (Thread.interrupted()) throw new InterruptedException(); //创建新结点加入等待队列并返回 Node node = addConditionWaiter(); //释放当前线程锁即释放同步状态 int savedState = fullyRelease(node); int interruptMode = 0; //判断结点是否同步队列(SyncQueue)中,即是否被唤醒 while (!isOnSyncQueue(node)) &#123; //挂起线程 LockSupport.park(this); //判断是否被中断唤醒，如果是退出循环。 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; &#125; //被唤醒后执行自旋操作争取获得锁，同时判断线程是否被中断 if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; // clean up if cancelled if (node.nextWaiter != null) //清理等待队列中不为CONDITION状态的结点 unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode);&#125; 12345678910111213141516171819//添加到等待队列private Node addConditionWaiter() &#123; Node t = lastWaiter; // 判断是否为结束状态的结点并移除 if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123; unlinkCancelledWaiters(); t = lastWaiter; &#125; //创建新结点状态为CONDITION Node node = new Node(Thread.currentThread(), Node.CONDITION); //加入等待队列 if (t == null) &#123; firstWaiter = node; &#125; else &#123; t.nextWaiter = node; &#125; lastWaiter = node; return node;&#125; 调用addConditionWaiter()方法将当前线程封装成node结点加入等待队列 调用fullyRelease(node)方法释放同步状态并唤醒同步队列后继结点的线程 调用isOnSyncQueue(node)方法判断结点是否在同步队列中，注意是个while循环，如果同步队列中没有该结点就直接挂起该线程，如果线程被唤醒后就调用acquireQueued(node, savedState)执行自旋操作争取锁，即当前线程结点从等待队列转移到同步队列并开始努力获取锁 signal()实现1234567891011public final void signal() &#123; //判断是否持有独占锁，如果不是抛出异常 //只有独占模式采用等待队列，而共享模式下是没有等待队列的，也就没法使用Condition if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; //唤醒等待队列第一个结点的线程 if (first != null) &#123; doSignal(first); &#125;&#125; 1234567891011private void doSignal(Node first) &#123; do &#123; //移除条件等待队列中的第一个结点 //然后重新维护条件等待队列的firstWaiter和lastWaiter的指向 if ((firstWaiter = first.nextWaiter) == null) &#123; lastWaiter = null; &#125; first.nextWaiter = null; //如果被通知节点没有进入到同步队列并且条件等待队列还有不为空的节点，则继续循环通知后续结点 &#125; while (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != null);&#125; 1234567891011121314151617181920final boolean transferForSignal(Node node) &#123; //尝试设置唤醒结点的waitStatus为0，即初始化状态 //如果设置失败，说明当前结点node的waitStatus已不为 //CONDITION状态，那么只能是结束状态了，因此返回false //返回doSignal()方法中继续唤醒其他结点的线程，注意这里并 //不涉及并发问题，所以CAS操作失败只可能是预期值不为CONDITION， //而不是多线程设置导致预期值变化，毕竟操作该方法的线程是持有锁的。 if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false; //加入同步队列并返回前驱结点p Node p = enq(node); int ws = p.waitStatus; //判断前驱结点是否为结束结点(CANCELLED=1)或者在设置 //前驱节点状态为Node.SIGNAL状态失败时，唤醒被通知节点代表的线程 if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) //唤醒node结点的线程 LockSupport.unpark(node.thread); return true;&#125; 被唤醒后的线程，将从前面的await()方法中的while循环中退出，因为此时该线程的结点已在同步队列中，那么while (!isOnSyncQueue(node))将不在符合循环条件，进而调用AQS的acquireQueued()方法加入获取同步状态的竞争中，这就是等待唤醒机制的整个流程实现原理 参考链接 深入剖析基于并发AQS的(独占锁)重入锁(ReetrantLock)及其Condition实现原理java并发编程之Condition","tags":[{"name":"java","slug":"java","permalink":"http://langonggong.com/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://langonggong.com/tags/多线程/"}]},{"title":"滑动窗口算法","date":"2018-09-19T14:56:15.000Z","path":"2018/09/19/滑动窗口算法/","text":"题目描述 有一个整型数组 arr 和一个大小为 w 的窗口从数组的最左边滑到最右边,窗口每次向右边滑一个位置。 返回一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值。 以数组为[4,3,5,4,3,3,6,7]，w=3为例。因为第一个窗口[4,3,5]的最大值为5，第二个窗口[3,5,4]的最大值为5，第三个窗口[5,4,3]的最大值为5。第四个窗口[4,3,3]的最大值为4。第五个窗口[3,3,6]的最大值为6。第六个窗口[3,6,7]的最大值为7。所以最终返回[5,5,5,4,6,7]。 给定整形数组arr及它的大小n，同时给定w，请返回res数组。保证w小于等于n，同时保证数组大小小于等于500。 解题思路 使用一个长度为w的双端队列，存储数组的索引。每次有新元素加入，将小于或等于改元素的值的原有元素对应的索引删掉，将不在该窗口范围的索引删掉。队列的索引对应的元素值倒序排序。则队列的第一个元素始终为该窗口内最大值的索引 参考代码12345678910111213141516171819202122232425public class SlideWindow &#123; public int[] slide(int[] arr, int n, int w) &#123; if (arr == null || arr.length == 0 || arr.length &lt; w) &#123; return new int[0]; &#125; LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); int[] result = new int[arr.length - w + 1]; int index = 0; for (int i = 0; i &lt; arr.length; i++) &#123; //把较小的值挤掉，按照从大到小排序 while (!list.isEmpty() &amp;&amp; arr[list.peekLast()] &lt;= arr[i]) &#123; list.pollLast(); &#125; list.addLast(i); //不在窗口里面的元素删掉 if (i - list.peekFirst() == w) &#123; list.pollFirst(); &#125; if (i + 1 &gt;= w) &#123; result[index++] = arr[list.peekFirst()]; &#125; &#125; return result; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://langonggong.com/tags/算法/"},{"name":"队列","slug":"队列","permalink":"http://langonggong.com/tags/队列/"}]},{"title":"小范围排序","date":"2018-09-06T17:04:14.000Z","path":"2018/09/07/小范围排序/","text":"题目描述 已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序 解题思路 使用变种的堆排序：维护一个长度为k的最小根堆，将数组的元素不断的加入堆中，调整后将堆顶弹出赋给数组，将排序的范围始终限制在长度为k、近乎排序的堆中 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class ScaleSort &#123; public int[] sortElement(int[] arr, int k) &#123; if (arr == null || arr.length &lt; 2) &#123; return arr; &#125; //构建长度为k的小根堆，此过程也可以在heap数组中进行 for (int i = k / 2; i &gt;= 0; i--) &#123; headAdjust(arr, i, k); &#125; //将调整好的最小根堆赋值给heap数组 int[] heap = new int[k]; for (int i = 0; i &lt; k; i++) &#123; heap[i] = arr[i]; &#125; //每从最小跟堆中弹出堆顶给数组，就从数组中弹出一个元素给堆，再次调整为最小跟堆 for (int i = k; i &lt; arr.length; i++) &#123; arr[i - k] = heap[0]; heap[0] = arr[i]; headAdjust(heap, 0, k); &#125; //最小根堆不能保证左右节点之间的大小顺序，所以不能直接将heap完整复制给arr for (int i = arr.length - k; i &lt; arr.length; i++) &#123; arr[i] = heap[0]; //由于堆中没有新的元素加入，只能每次将堆顶放到后面，对前面一部分进行堆调整 swap(heap, 0, arr.length - i - 1); headAdjust(heap, 0, arr.length - i - 1); &#125; return arr; &#125; //堆调整，保证[index,length)这条支线满足最小根堆 private void headAdjust(int[] arr, int index, int length) &#123; int minIndex, left, right; while (index &lt; length) &#123; minIndex = index; left = 2 * index + 1; right = 2 * index + 2; if (left &lt; length &amp;&amp; arr[left] &lt; arr[minIndex]) &#123; minIndex = left; &#125; if (right &lt; length &amp;&amp; arr[right] &lt; arr[minIndex]) &#123; minIndex = right; &#125; //临界条件，表示无需再调整 if (index == minIndex) &#123; break; &#125; swap(arr, index, minIndex); index = minIndex; &#125; &#125; public static void swap(int[] arr, int index1, int index2) &#123; if (index1 == index2) &#123; return; &#125; int tmp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = tmp; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://langonggong.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://langonggong.com/tags/排序/"}]},{"title":"DNS解析","date":"2018-09-06T08:46:42.000Z","path":"2018/09/06/DNS解析/","text":"nslookup 第一行Server是：DNS服务器的主机名—10.4.1.14第二行Address是：它的IP地址—10.4.1.14#53 百度有一个cname = www.a.shifen.com的别名 下面的Name是：解析的URL—www.a.shifen.comAddress是：解析出来的IP—220.181.112.244和220.181.111.188 dig www.baidu.com +trace Dig工具会在本地计算机做迭代，然后记录查询的过程 第一步，向我这台机器的ISPDNS获取到根域服务区的13个IP和主机名[b-j].root-servers.net. 第二步，向其中的一台根域服务器（m.root-servers.net）发送www.baidu.com的查询请求，他返回了com.顶级域的服务器名称 第三步，向com.域的一台服务器i.gtld-servers.net请求,www.baidu.com，他返回了baidu.com域的服务器IP（未显示）和名称，百度有5台顶级域的服务器 第四步，向百度的顶级域服务器（202.108.22.220）请求www.baidu.com，他发现这个www有个别名，而不是一台主机，别名是www.a.shifen.com 当dns请求到别名的时候，查询不会终止，而是重新发起查询别名的请求，此处返回的是www.a.shifen.com，然后继续请求 使用dig www.a.shifen.com +trace查看 再一次去请求com域，重复上面的步骤，最终从ns X.a.shifen.com中一台拿到了一条A记录，便是www.baidu.com的IP地址了","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://langonggong.com/tags/计算机网络/"},{"name":"DNS","slug":"DNS","permalink":"http://langonggong.com/tags/DNS/"}]},{"title":"基数排序","date":"2018-09-05T15:41:05.000Z","path":"2018/09/05/基数排序/","text":"1、构造从0到9的10个桶，将数组的每个元素按照个位数的大小放入对应的桶中2、构造新的10个桶，将原桶中的数字依次弹出，按照十位数的大小依次放入对应的新桶中3、对百位、千位等按照上述步骤处理 需考虑负数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class RadixSort &#123; public int[] radixSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return arr; &#125; int posNum = 0; for (int i : arr) &#123; if (i &gt;= 0) &#123; posNum++; &#125; &#125; int[] posArr = new int[posNum]; int[] negArr = new int[arr.length - posNum]; int posIndex = 0, negIndex = 0, posMax = 0, negMax = 0; for (int i : arr) &#123; if (i &gt;= 0) &#123; posArr[posIndex++] = i; posMax = Math.max(posMax, i); &#125; else &#123; int j = -i; negArr[negIndex++] = j; negMax = Math.max(j, negMax); &#125; &#125; radixSortForPositive(posArr, posMax); radixSortForPositive(negArr, negMax); int index = 0; for(int i=negArr.length-1;i&gt;=0;i--) &#123; arr[index++] = -negArr[i]; &#125; for(int i=0;i&lt;posArr.length;i++) &#123; arr[index++] = posArr[i]; &#125; return arr; &#125; //针对正数的基数排序 private static void radixSortForPositive(int[] arr, int max) &#123; List&lt;LinkedList&lt;Integer&gt;&gt; temp1 = new ArrayList&lt;&gt;(); List&lt;LinkedList&lt;Integer&gt;&gt; temp2 = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; temp1.add(new LinkedList&lt;&gt;()); temp2.add(new LinkedList&lt;&gt;()); &#125; //按照个位数的大小将元素放入桶中 for (int i : arr) &#123; temp1.get(i % 10).add(i); &#125; for (int base = 10; base &lt;= max; base *= 10) &#123; for (LinkedList&lt;Integer&gt; integers : temp1) &#123; while (!integers.isEmpty()) &#123; Integer integer = integers.pop(); temp2.get((integer / base) % 10).add(integer); &#125; &#125; List&lt;LinkedList&lt;Integer&gt;&gt; temp; temp = temp1; temp1 = temp2; temp2 = temp; &#125; int index = 0; for (LinkedList&lt;Integer&gt; integers : temp1) &#123; for (Integer integer : integers) &#123; arr[index++] = integer; &#125; &#125; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://langonggong.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://langonggong.com/tags/排序/"}]},{"title":"计数排序","date":"2018-09-05T15:37:25.000Z","path":"2018/09/05/计数排序/","text":"根据数组最大最小值构建数组，记录每个数字出现次数 123456789101112131415161718192021222324public class CountingSort &#123; public int[] countingSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return arr; &#125; int min = arr[0], max = arr[0]; for(int i=0;i&lt;arr.length;i++) &#123; min = Math.min(min, arr[i]); max = Math.max(max, arr[i]); &#125; int[] store = new int[max - min + 1]; for(int j=0;j&lt;arr.length;j++) &#123; store[arr[j] - min]++; &#125; int index = 0; for(int k=0;k&lt;store.length;k++) &#123; while (store[k]-- &gt; 0) &#123; arr[index++] = k + min; &#125; &#125; return arr; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://langonggong.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://langonggong.com/tags/排序/"}]},{"title":"希尔排序","date":"2018-09-05T15:00:26.000Z","path":"2018/09/05/希尔排序/","text":"令k=21、将数组分成k等分，构建length/2个间隔为k的数组，对每个数组进行插入排序2、k=k*2,重复步骤1 插入排序:假设前面的数组已经有序，则找到改点合适的位置插入(该点下沉到合适的位置) 123456789101112131415161718192021222324252627282930public class ShellSort &#123; public int[] shellSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return arr; &#125; int length = arr.length ; //将数组2等分，4等分...直到一等分 for (int gap = length &gt;&gt; 1; gap &gt; 0; gap &gt;&gt;= 1) &#123; //对生成的多个数组进行插入排序 for (int start = gap; start &lt; arr.length; start++) &#123; //对单个数组进行插入排序 for (int index = start; index &gt;= gap; index -= gap) &#123; if (arr[index - gap] &gt; arr[index]) &#123; swap(arr, index - gap, index); &#125; &#125; &#125; &#125; return arr; &#125; public static void swap(int[] arr, int index1, int index2) &#123; if (index1 == index2) &#123; return; &#125; int tmp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = tmp; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://langonggong.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://langonggong.com/tags/排序/"}]},{"title":"堆排序","date":"2018-09-04T16:28:14.000Z","path":"2018/09/05/堆排序/","text":"1、构建大根堆，满足父大于子，堆顶为最大值2、将堆顶与最后一位进行替换，将前n-1位调整为大根堆3、对前n-1位大根堆重复过程2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class HeapSort &#123; public int[] heapSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return arr; &#125; //构建大根堆，使整棵树满足:父&gt;子 for (int i = arr.length / 2; i &gt;= 0; i--) &#123; //每次调整，都要保证将后面所有的都调整一遍 headAdjust(arr, i, arr.length); &#125; //将堆顶（最大值）替换到第j个点，然后将前面j-1个点调整为大根堆， //对前j-1个点重复此过程 for(int j=arr.length-1;j&gt;=0;j--) &#123; swap(arr, 0, j); headAdjust(arr, 0, j); &#125; return arr; &#125; //保证[index,length)单条支线上的点满足:父节点大于子节点 private void headAdjust(int[] arr, int index,int length) &#123; while (index &lt; length) &#123; int left = 2 * index + 1; int right = 2 * index + 2; int max = index; if (left &lt; length &amp;&amp; arr[left] &gt; arr[index]) &#123; max = left; &#125; if (right &lt; length &amp;&amp; arr[right] &gt; arr[max]) &#123; max = right; &#125; if (index == max) &#123; break; &#125; swap(arr, index, max); index = max; &#125; &#125; public static void swap(int[] arr, int index1, int index2) &#123; if (index1 == index2) &#123; return; &#125; int tmp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = tmp; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://langonggong.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://langonggong.com/tags/排序/"}]},{"title":"快速排序","date":"2018-09-03T15:56:00.000Z","path":"2018/09/03/快速排序/","text":"选择任意一点，将元素划分为小于该值和大于该值的左右两部分，递归次过程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class QuickSort &#123; public int[] quickSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return arr; &#125; process(arr, 0, arr.length - 1); return arr; &#125; public static void process(int[] arr, int left, int right) &#123; if (left &gt;= right) &#123; return; &#125; int random = left + (int) Math.random() * (right - left + 1); swap(arr, random, right); int partition = partition(arr, left, right); process(arr, left, partition - 1); process(arr, partition + 1, right); &#125; /** * 将小于或等于right的元素替换到左边，大于right的元素保持不动 * partition加一递增，指向最近一个被替换到左边的位置 * 当数组遍历完，right处的元素被替换到partition所指的位置 * partition左边的值全部小于或等于该值，右边的值全部大于该值 **/ public static int partition(int[] arr, int left, int right) &#123; int partition = left - 1; int index = left; while (index &lt;= right) &#123; if (arr[index] &lt;= arr[right]) &#123; swap(arr, ++partition, index); &#125; index++; &#125; return partition; &#125; public static void swap(int[] arr, int index1, int index2) &#123; if (index1 == index2) &#123; return; &#125; int tmp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = tmp; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://langonggong.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://langonggong.com/tags/排序/"}]},{"title":"归并排序","date":"2018-09-03T13:24:32.000Z","path":"2018/09/03/归并排序/","text":"二分后递归调用自身，然后对这两部分处理后的结果进行排序 12345678910111213141516171819202122232425262728293031323334353637383940public class MergeSort &#123; public int[] mergeSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return arr; &#125; divide(arr, 0, arr.length - 1); return arr; &#125; private void divide(int[] arr, int left, int right) &#123; if (left &gt;= right) &#123; return; &#125; int mid = (left + right) / 2; divide(arr, left, mid); divide(arr, mid + 1, right); merge(arr, left, mid, right); &#125; private void merge(int[] arr, int left, int mid, int right) &#123; int[] result = new int[right - left + 1]; int i = left, j = mid + 1, index = 0; while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; if (arr[i] &lt; arr[j]) &#123; result[index++] = arr[i++]; &#125; else &#123; result[index++] = arr[j++]; &#125; &#125; while (i &lt;= mid) &#123; result[index++] = arr[i++]; &#125; while (j &lt;= right) &#123; result[index++] = arr[j++]; &#125; for(int k=0;k&lt;result.length;k++) &#123; arr[left + k] = result[k]; &#125; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://langonggong.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://langonggong.com/tags/排序/"}]},{"title":"插入排序","date":"2018-09-02T15:10:00.000Z","path":"2018/09/02/插入排序/","text":"假设前面的数组已经有序，则找到改点合适的位置插入(该点下沉到合适的位置) 1234567891011121314151617181920212223242526272829public class InsertionSort &#123; public int[] insertionSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return arr; &#125; for (int i=1;i&lt;arr.length;i++) &#123; int j = i; while (j &gt; 0) &#123; if (arr[j - 1] &gt; arr[j]) &#123; swap(arr, j, j - 1); j--; &#125; else &#123; break; &#125; &#125; &#125; return arr; &#125; private void swap(int[] arr, int i, int j) &#123; if (i == j) &#123; return; &#125; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://langonggong.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://langonggong.com/tags/排序/"}]},{"title":"选择排序","date":"2018-09-02T14:58:40.000Z","path":"2018/09/02/选择排序/","text":"选择最小值与第一个数字交换 1234567891011121314151617181920212223242526public class SelectSort &#123; public int[] selectionSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return arr; &#125; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int mini = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; mini = arr[j] &lt; arr[mini] ? j : mini; &#125; swap(arr, i, mini); &#125; return arr; &#125; private void swap(int[] arr, int i, int j) &#123; if (i == j) &#123; return; &#125; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://langonggong.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://langonggong.com/tags/排序/"}]},{"title":"冒泡排序","date":"2018-09-02T14:49:03.000Z","path":"2018/09/02/冒泡排序/","text":"最大值上浮 12345678910111213141516171819202122public class BubbleSort &#123; public int[] bubbleSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return arr; &#125; for (int i=arr.length-1;i&gt;0;i--) &#123; for (int j=0;j&lt;i;j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; swap(arr, j, j + 1); &#125; &#125; &#125; return arr; &#125; private void swap(int[] arr, int i, int j) &#123; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://langonggong.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://langonggong.com/tags/排序/"}]},{"title":"AQS","date":"2018-09-01T06:14:14.000Z","path":"2018/09/01/AQS/","text":"引言在JDK1.5之前，一般是靠synchronized关键字来实现线程对共享变量的互斥访问。synchronized是在字节码上加指令，依赖于底层操作系统的Mutex Lock实现。AQS定义了一套多线程访问共享资源的同步器框架，是整个java.util.concurrent包的基石，Lock、ReadWriteLock、CountDowndLatch、CyclicBarrier、Semaphore、ThreadPoolExecutor等都是在AQS的基础上实现的。 同步队列(CLH)AQS维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列） AQS的内部队列是CLH同步锁的一种变形。其主要从两方面进行了改造，节点的结构与节点等待机制 在结构上引入了头结点和尾节点，分别指向队列的头和尾，尝试获取锁、入队列、释放锁等实现都与头尾节点相关 为了可以处理timeout和cancel操作，每个node维护一个指向前驱的指针。如果一个node的前驱被cancel，这个node可以前向移动使用前驱的状态字段 在每个node里面使用一个状态字段来控制阻塞/唤醒，而不是自旋 head结点使用的是傀儡结点 12345678910111213public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer&#123;//指向同步队列队头private transient volatile Node head;//指向同步的队尾private transient volatile Node tail;//同步状态，在不同的子类有不同的含义private volatile int state;//省略其他代码......&#125; Node节点Node结点是对每一个访问同步代码的线程的封装，从图中的Node的数据结构也可看出，其包含了需要同步的线程本身以及线程的状态，如是否被阻塞，是否等待唤醒，是否已经被取消等。每个Node结点内部关联其前继结点prev和后继结点next，这样可以方便线程释放锁后快速唤醒下一个在等待的线程，Node是AQS的内部类，其数据结构如下 12345678910111213141516171819202122232425262728293031323334353637383940414243static final class Node &#123; //共享模式 static final Node SHARED = new Node(); //独占模式 static final Node EXCLUSIVE = null; //标识线程已处于结束状态 static final int CANCELLED = 1; //等待被唤醒状态 static final int SIGNAL = -1; //条件状态 static final int CONDITION = -2; //在共享模式中使用表示获得的同步状态会被传播 static final int PROPAGATE = -3; //等待状态,存在CANCELLED、SIGNAL、CONDITION、PROPAGATE 4种 volatile int waitStatus; //同步队列中前驱结点 volatile Node prev; //同步队列中后继结点 volatile Node next; //请求锁的线程 volatile Thread thread; //等待队列中的后继结点，这个与Condition有关 Node nextWaiter; //判断是否为共享模式 final boolean isShared() &#123; return nextWaiter == SHARED; &#125; //获取前驱结点 final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; //.....&#125; 其中SHARED和EXCLUSIVE常量分别代表共享模式和独占模式，所谓共享模式是一个锁允许多条线程同时操作，如信号量Semaphore采用的就是基于AQS的共享模式实现的，而独占模式则是同一个时间段只能有一个线程对共享资源进行操作，多余的请求线程需要排队等待，如ReentranLock。变量waitStatus则表示当前被封装成Node结点的等待状态，共有4种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE CANCELLED：值为1，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node的结点，其结点的waitStatus为CANCELLED，即结束状态，进入该状态后的结点将不会再变化。 SIGNAL：值为-1，被标识为该等待唤醒状态的后继结点，当其前继结点的线程释放了同步锁或被取消，将会通知该后继结点的线程执行。说白了，就是处于唤醒状态，只要前继结点释放锁，就会通知标识为SIGNAL状态的后继结点的线程执行。 CONDITION：值为-2，与Condition相关，该标识的结点处于等待队列中，结点的线程等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。 PROPAGATE：值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态。 0状态：值为0，代表初始化状态。 AQS lock()操作 Sync与State实现state机制volatile 变量 state; 用于同步线程之间的共享状态。通过 CAS 和 volatile 保证其原子性和可见性。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。 12345678// 同步状态 private volatile int state; //CAS protected final boolean compareAndSetState(int expect, int update) &#123; // See below for intrinsics setup to support this return unsafe.compareAndSwapInt(this, stateOffset, expect, update); &#125; 不同实现类的Sync与State基于AQS构建的Synchronizer包括ReentrantLock,Semaphore,CountDownLatch, ReetrantRead WriteLock,FutureTask等，这些Synchronizer实际上最基本的东西就是原子状态的获取和释放，只是条件不一样而已 ReentrantLock需要记录当前线程获取原子状态的次数，如果次数为零，那么就说明这个线程放弃了锁（也有可能其他线程占据着锁从而需要等待），如果次数大于1，也就是获得了重进入的效果，而其他线程只能被park住，直到这个线程重进入锁次数变成0而释放原子状态。以下为ReetranLock的FairSync的tryAcquire实现代码解析 123456789101112131415161718192021222324//公平获取锁protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); //如果当前重进入数为0,说明有机会取得锁 if (c == 0) &#123; //如果是第一个等待者，并且设置重进入数成功，那么当前线程获得锁 if (isFirst(current) &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; //如果当前线程本身就持有锁，那么叠加重进入数，并且继续获得锁 else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; &#125; //以上条件都不满足，那么线程进入等待队列。 return false;&#125; Semaphore信号量维护了一个许可集，我们在初始化Semaphore时需要为这个许可集传入一个数量值，该数量值代表同一时间能访问共享资源的线程数量。以下为Semaphore的FairSync实现 123456789101112131415protected int tryAcquireShared(int acquires) &#123; Thread current = Thread.currentThread(); for (;;) &#123; Thread first = getFirstQueuedThread(); //如果当前等待队列的第一个线程不是当前线程，那么就返回-1表示当前线程需要等待 if (first != null &amp;&amp; first != current) return -1; //如果当前队列没有等待者，或者当前线程就是等待队列第一个等待者，那么先取得semaphore还有几个许可证，并且减去当前线程需要的许可证得到剩下的值 int available = getState(); int remaining = available - acquires; //如果remining&lt;0，那么反馈给AQS当前线程需要等待，如果remaining&gt;0，并且设置availble成功设置成剩余数，那么返回剩余值(&gt;0)，也就告知AQS当前线程拿到许可，可以继续执行。 if (remaining &lt; 0 ||compareAndSetState(available, remaining)) return remaining; &#125;&#125; CountDownLatch闭锁则要保持其状态，在这个状态到达终止态之前，所有线程都会被park住，闭锁可以设定初始值，这个值的含义就是这个闭锁需要被countDown()几次，因为每次CountDown是sync.releaseShared(1),而一开始初始值为10的话，那么这个闭锁需要被countDown()十次，才能够将这个初始值减到0，从而释放原子状态，让等待的所有线程通过 12345678910111213141516//await时候执行，只查看当前需要countDown数量减为0了，如果为0，说明可以继续执行，否则需要park住，等待countDown次数足够，并且unpark所有等待线程public int tryAcquireShared(int acquires) &#123; return getState() == 0? 1 : -1;&#125; //countDown 时候执行，如果当前countDown数量为0，说明没有线程await，直接返回false而不需要唤醒park住线程，如果不为0，得到剩下需要 countDown的数量并且compareAndSet,最终返回剩下的countDown数量是否为0,供AQS判定是否释放所有await线程。public boolean tryReleaseShared(int releases) &#123; for (;;) &#123; int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; &#125;&#125; FutureTask需要记录任务的执行状态，当调用其实例的get方法时,内部类Sync会去调用AQS的acquireSharedInterruptibly()方法，而这个方法会反向调用Sync实现的tryAcquireShared()方法，即让具体实现类决定是否让当前线程继续还是park,而FutureTask的tryAcquireShared方法所做的唯一事情就是检查状态，如果是RUNNING状态那么让当前线程park。而跑任务的线程会在任务结束时调用FutureTask 实例的set方法（与等待线程持相同的实例），设定执行结果，并且通过unpark唤醒正在等待的线程，返回结果 123456789101112131415161718192021222324252627282930313233343536373839404142//get时待用，只检查当前任务是否完成或者被Cancel，如果未完成并且没有被cancel，那么告诉AQS当前线程需要进入等待队列并且park住protected int tryAcquireShared(int ignore) &#123; return innerIsDone()? 1 : -1;&#125; //判定任务是否完成或者被Cancelboolean innerIsDone() &#123; return ranOrCancelled(getState()) &amp;&amp; runner == null;&#125; //get时调用，对于CANCEL与其他异常进行抛错V innerGet(long nanosTimeout) throws InterruptedException, ExecutionException, TimeoutException &#123; if (!tryAcquireSharedNanos(0,nanosTimeout)) throw new TimeoutException(); if (getState() == CANCELLED) throw new CancellationException(); if (exception != null) throw new ExecutionException(exception); return result;&#125; //任务的执行线程执行完毕调用（set(V v)）void innerSet(V v) &#123; for (;;) &#123; int s = getState(); //如果线程任务已经执行完毕，那么直接返回（多线程执行任务？） if (s == RAN) return; //如果被CANCEL了，那么释放等待线程，并且会抛错 if (s == CANCELLED) &#123; releaseShared(0); return; &#125; //如果成功设定任务状态为已完成，那么设定结果，unpark等待线程(调用get()方法而阻塞的线程),以及后续清理工作（一般由FutrueTask的子类实现） if (compareAndSetState(s, RAN)) &#123; result = v; releaseShared(0); done(); return; &#125; &#125;&#125; MutexMutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码 123456789101112131415161718192021222324// 判断是否锁定状态protected boolean isHeldExclusively() &#123; return getState() == 1;&#125;// 尝试获取资源，立即返回。成功则返回true，否则false。public boolean tryAcquire(int acquires) &#123; assert acquires == 1; // 这里限定只能为1个量 if (compareAndSetState(0, 1)) &#123;//state为0才设置为1，不可重入！ setExclusiveOwnerThread(Thread.currentThread());//设置为当前线程独占资源 return true; &#125; return false;&#125;// 尝试释放资源，立即返回。成功则为true，否则false。protected boolean tryRelease(int releases) &#123; assert releases == 1; // 限定为1个量 if (getState() == 0)//既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！ throw new IllegalMonitorStateException(); setExclusiveOwnerThread(null); setState(0);//释放资源，放弃占有状态 return true;&#125; 参考链接 深入剖析基于并发AQS的(独占锁)重入锁(ReetrantLock)及其Condition实现原理剖析基于并发AQS的共享锁的实现(基于信号量Semaphore)Java多线程（七）之同步器基础：AQS框架深入分析非阻塞算法简介","tags":[{"name":"java","slug":"java","permalink":"http://langonggong.com/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://langonggong.com/tags/多线程/"}]},{"title":"KMP","date":"2018-08-29T16:44:12.000Z","path":"2018/08/30/KMP/","text":"求next数组字符串组成为 p_0...p_k...p_i...p_{i+k}...p_j...p_{j+k}...p_m...p_{m+k}...假设\\(next_{[i+k]}==next_{[m+k]}\\)，表示\\(p_0…p_{i+k}=p_j…p_{m+k}\\) 如果\\(p_{i+k+1}=p_{m+k+1}\\)，则\\(next_{[m+k+1]}==next_{[m+k]}+1\\) 如果\\(p_{i+k+1}!=p_{m+k+1}\\)，有\\(next_{[i+k]}=k\\)，表示\\(p_0…p_{k}=p_i…p_{i+k}=p_m…p_{m+k}\\)， 如果\\(p_{m+k+1}=p_{k+1}\\)，则\\(next_{[m+k+1]}=next_{[k]}+1\\) 如果\\(p_{m+k+1}!=p_{k+1}\\)，则有\\(next_{[k]}=l\\)，继续上面的过程 总结下来，若\\(next_{[i]}==next_{[j]}\\) if \\(p_{i+1}=p_{j+1}\\), then \\(next_{[j+1]}==next_{[j]+1}\\) else \\(i==next_{[i]}\\),继续上一步 实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class KMP &#123; private int[] getNextArr(char[] pattern) &#123; if (pattern == null || pattern.length == 1) &#123; return new int[]&#123;-1&#125;; &#125; int[] next = new int[pattern.length]; next[0] = -1; next[1] = 0; int currentNext=0; int pos = 2; while (pos &lt; pattern.length) &#123; if (pattern[pos - 1] == pattern[currentNext]) &#123; next[pos++] = ++currentNext; &#125; else if (currentNext &gt; 0) &#123; currentNext = next[currentNext]; &#125; else &#123; next[pos++] = 0; &#125; &#125; return next; &#125; public int getIndexOf(String ori, String pattern) &#123; if (ori.length() &lt; pattern.length()) &#123; return -1; &#125; char[] oriArr = ori.toCharArray(); char[] patternArr = pattern.toCharArray(); int indexOfOri = 0; int indexOfPattern = 0; int[] next = getNextArr(patternArr); while (indexOfOri &lt; oriArr.length &amp;&amp; indexOfPattern &lt; patternArr.length) &#123; if (oriArr[indexOfOri] == patternArr[indexOfPattern]) &#123; indexOfOri++; indexOfPattern++; &#125; else if (next[indexOfPattern] &gt;= 0) &#123; indexOfPattern = next[indexOfPattern]; &#125; else &#123; indexOfOri++; &#125; &#125; return indexOfPattern == patternArr.length ? indexOfOri - indexOfPattern : -1; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://langonggong.com/tags/算法/"},{"name":"字符串匹配","slug":"字符串匹配","permalink":"http://langonggong.com/tags/字符串匹配/"}]},{"title":"内存屏障","date":"2018-08-23T15:15:18.000Z","path":"2018/08/23/内存屏障/","text":"内存屏障的目的每个CPU都会有自己的缓存（有的甚至L1,L2,L3），缓存的目的就是为了提高性能，避免每次都要向内存取。但是这样的弊端也很明显：不能实时的和内存发生信息交换，分在不同CPU执行的不同线程对同一个变量的缓存值不同 内存屏障的作用硬件层的内存屏障分为两种：Load Barrier 和 Store Barrier即读屏障和写屏障 对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据 对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见 内存屏障有两个作用 阻止屏障两侧的指令重排序 强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效 java内存屏障内存屏障可以被分为以下几种类型: LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。 StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。 LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。 StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能 volatile语义中的内存屏障volatile的内存屏障策略非常严格、悲观 在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障 在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障 volatile重排序规则： volatile写与之前的读写不能重排序 volatile读与之后的读写不能重排序 相邻的volatile之间不能重排序 volatile内存屏障规则： volatile写之前，所有的读写都必须已经完成 volatile读结束后，所有的读写才能开始 相邻的volatile必须有序实行 final语义中的内存屏障 新建对象过程中，构造体中对final域的初始化写入和这个对象赋值给其他引用变量，这两个操作不能重排序 123x.finalField = v; ... ;构建方法边界sharedRef = x;v.afield = 1; x.finalField = v; ... ; 构建方法边界sharedRef = x;这两条语句中，构建方法边界前后的指令都不能重排序。 初次读包含final域的对象引用和读取这个final域，这两个操作不能重排序 1x = sharedRef; ... ; i = x.finalField; 为了保证final字段的特殊语义，也会在下面的语句加入内存屏障 1x.finalField = v; StoreStore; sharedRef = x; 参考链接 内存屏障 JVM内存模型、指令重排、内存屏障概念解析 java内存模型 内存屏障","tags":[{"name":"java","slug":"java","permalink":"http://langonggong.com/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://langonggong.com/tags/多线程/"},{"name":"java内存模型","slug":"java内存模型","permalink":"http://langonggong.com/tags/java内存模型/"}]},{"title":"volatile","date":"2018-08-23T12:54:28.000Z","path":"2018/08/23/volatile/","text":"内存可见性volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值 线程写volatile变量的过程 改变线程工作内存中volatile变量副本的值 将改变后的副本的值从工作内存刷新到主内存 线程读volatile变量的过程 从主内存中读取volatile变量的最新值到线程的工作内存中 从工作内存中读取volatile变量的副本 禁止指令重排序多线程版本(错误的)123456789101112class Foo &#123; private Helper helper = null; public Helper getHelper() &#123; if (helper == null) synchronized(this) &#123; if (helper == null) helper = new Helper(); &#125; return helper; &#125; // other functions and members... &#125; volatile关键字修改版123456789101112class Foo &#123; private volatile Helper helper = null; public Helper getHelper() &#123; if (helper == null) &#123; synchronized (this) &#123; if (helper == null) helper = new Helper(); &#125; &#125; return helper; &#125;&#125; 在给helper对象初始化的过程中，jvm做了下面3件事: 给helper对象分配内存 调用构造函数 将helper对象指向分配的内存空间 由于jvm的”优化”,指令2和指令3的执行顺序是不一定的，当执行完指定3后，此时的helper对象就已经不在是null的了,但此时指令2不一定已经被执行。 假设线程1和线程2同时调用getHelper()方法，此时线程1执行完指令1和指令3，线程2抢到了执行权，此时helper对象是非空的 volatile关键字可以保证jvm执行的一定的“有序性”，在指令1和指令2执行完之前，指定3一定不会被执行 volatile变量被修改后立刻刷新会驻内存中 不保证复合操作的原子性1234567891011121314151617181920212223public class Test &#123; public volatile int inc = 0; public void increase() &#123; inc++; &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 线程A读取最新的值并在工作内存修改后，还未更新到主存就耗尽cpu时间片，等再次获取时间片后主存的变量值已被线程B修改，但线程A并未感知，继续将值更新到主存，导致B的修改无效","tags":[{"name":"java","slug":"java","permalink":"http://langonggong.com/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://langonggong.com/tags/多线程/"}]},{"title":"hexo高级特性","date":"2018-08-19T08:35:51.000Z","path":"2018/08/19/cool/","text":"网易云通过外链添加在网易云音乐的网页版生成歌单外链 1&lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=450 src=\"//music.163.com/outchain/player?type=0&amp;id=2343741251&amp;auto=1&amp;height=430\"&gt;&lt;/iframe&gt; 通过aplayer插件MeingJS 支持id为网页上url后面的id值1&#123;% meting \"468513829\" \"netease\" \"song\" \"autoplay\" \"mutex: true\" \"listmaxheight:340px\" \"preload:none\" \"theme:#ad7a86\"%&#125; 1&#123;% meting \"384485381\" \"netease\" \"playlist\" \"autoplay\" \"mutex: true\" \"listmaxheight:340px\" \"preload:none\" \"theme:#ad7a86\"%&#125; 行间公式 f(n)=\\begin{cases} n/2, & \\text{如果$ x2 $} \\end{cases}行内公式比如 \\(x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}\\)","tags":[{"name":"hexo","slug":"hexo","permalink":"http://langonggong.com/tags/hexo/"},{"name":"新特性","slug":"新特性","permalink":"http://langonggong.com/tags/新特性/"}]},{"title":"mysql","date":"2018-08-19T05:47:35.000Z","path":"2018/08/19/mysql/","text":"基本概念mysql体系结构 参考链接 存储引擎 特点 MyISAM BDB Memory InnoDB Archive 存储限制 没有 没有 有 64TB 没有 事务安全 支持 支持 锁机制 表锁 页锁 表锁 行锁 行锁 B数索引 支持 支持 支持 支持 哈希索引 支持 支持 全文索引 支持 集群索引 支持 数据缓存 支持 支持 索引缓存 支持 支持 支持 数据可压缩 支持 支持 空间使用 低 低 N/A 高 非常低 内存使用 低 低 中等 高 低 批量插入的速度 高 高 高 低 非常高 支持外键 支持 InnoDB与MyISAM原理比较 InnoDB与MyISAM索引比较 索引索引的类型B-Tree索引参考链接B树中关键字集合分布在整棵树中，叶节点中不包含任何关键字信息，而B+树关键字集合分布在叶子结点中，非叶节点只是叶子结点中关键字的索引 Hash索引B Tree索引和哈希索引的区别 缺点不支持范围查询和排序、最左匹配规则 空间(R-Tree)索引 参考链接 全文(Full-text)索引类似es搜索的Lucene分词策略 参考链接 索引策略前缀索引高性能mysql章节 概念使用该列开始的部分长度字符串作 注意选择足够长的前缀以保证较高的选择性，同时又不能太长以便节约空间 缺点mysql无法使用其前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描 多列索引mysql多列索引的生效规则 聚簇索引(Clustered Indexes)及二级索引(辅助索引)高性能mysql章节 InnoDB与MyISAM的主键索引和二级索引的区别 聚集索引表数据按照索引的顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序一致。对于聚集索引，叶子结点即存储了真实的数据行，不再有另外单独的数据页。 在一张表上最多只能创建一个聚集索引，因为真实数据的物理顺序只能有一种 非聚集索引表数据存储顺序与索引顺序无关。对于非聚集索引，叶结点包含索引字段值及指向数据页数据行的逻辑指针，其行数量与数据表行数据量一致 覆盖索引(Covering Indexes)建立索引的字段正好是覆盖查询语句[select子句]与查询条件[Where子句]中所涉及的字段,数据列只用从索引中就能够取得，不必从数据表中读取参考&lt;&lt;高性能mysql&gt;&gt; 参考链接参考链接 其他压缩(前缀压缩)索引参考链接 重复索引相同列上按照相同的顺序创建的相同类型的索引 冗余索引若存在索引(a,b),则(a)是冗余,因为a是前缀,(a,b)可以当成(a)使用;（b,a）和(b)不是冗余索引 分形树(fractal treeindex)索引块级别元数据 Infobright高性能数据仓库 查询优化explain关键字参考链接 查询路径 参考链接 joinjoin原理 JOIN算法 Nested-Loop Join Simple Nested-Loop Join Index Nested-Loop Join Block Nested-Loop Join 哈希关联 合并连接 mysql高级特性分库、分区、分表、分片参考链接 视图内部存储代码存储过程函数触发器事件其他游标绑定变量XA查询缓存主从复制mvcc与锁MVCC原理 快照读当前读隔离级别Read UncommitedRead Committed (RC)Repeatable Read (RR)SerializableInnoDB两种类型的行锁共享锁（S）—读锁排他锁（X）—写锁行锁的三种情形Record lockGap lockNext-key LockInnoDB表锁意向共享锁（IS）意向排他锁（IX）InnoDB页面锁","tags":[{"name":"mysql","slug":"mysql","permalink":"http://langonggong.com/tags/mysql/"},{"name":"DB","slug":"DB","permalink":"http://langonggong.com/tags/DB/"}]},{"title":"spring cloud","date":"2018-08-19T05:12:12.000Z","path":"2018/08/19/springcloud/","text":"基础知识 四大神器 auto-configuration starters cli：Spring Boot Commad Line Autuator监控 服务注册与发现Eureka 参考链接 Feature Consul zookeeper etcd Eureka 服务健康检查 服务状态，内存，硬盘等 (弱)长连接，keepalive 连接心跳 可配支持 多数据中心 支持 — — — kv存储服务 支持 支持 支持 — 一致性 raft paxos raft — cap ca cp cp ap 使用接口(多语言能力) 支持http和dns 客户端 http/grpc http（sidecar） watch支持 全量/支持long polling 支持 支持 long polling 支持 long polling/大部分增量 自身监控 metrics — metrics metrics 安全 acl /https acl https支持（弱） — spring cloud集成 已支持 已支持 已支持 已支持 CAP理论与BASE思想服务发现的方式 客户端发现 服务器端发现 负载均衡LB方案参考链接1 参考链接2 硬负载 软负载 DNS负载 CDN负载 Ribbon核心组件 ServerList 用于获取地址列表。它既可以是静态的(提供一组固定的地址)，也可以是动态的(从注册中心中定期查询地址列表) ServerListFilter 仅当使用动态ServerList时使用，用于在原始的服务列表中使用一定策略过虑掉一部分地址 IRule 选择一个最终的服务地址作为LB结果。选择策略有轮询、根据响应时间加权、断路器(当Hystrix可用时)等 rest调用Feign容错处理参考链接1参考链接2 Hystrix 限流 降级 熔断 Dashboard 服务监控Turbine 聚合监控微服务网关Zuul过滤器机制 标准过滤器类型 PRE 鉴权 流量转发 ROUTING POST 跨域 统计 ERROR request生命周期 参考链接1 参考链接2 稳定性 隔离机制 重试机制 主要功能 验证与安全保障 审查与监控 动态路由 压力测试 负载分配 静态响应处理 多区域弹性 微服务配置Spring Cloud Config Spring Cloud Bus 参考链接 提交代码触发post请求给bus/refresh server端接收到请求并发送给Spring Cloud Bus Spring Cloud bus接到消息并通知给其它客户端 其它客户端接收到通知，请求Server端获取最新配置 全部客户端均获取到最新的配置 微服务跟踪Spring Cloud SleuthZipKinDocker入门Docker Compose","tags":[{"name":"java","slug":"java","permalink":"http://langonggong.com/tags/java/"},{"name":"spring cloud","slug":"spring-cloud","permalink":"http://langonggong.com/tags/spring-cloud/"},{"name":"网关","slug":"网关","permalink":"http://langonggong.com/tags/网关/"},{"name":"docker","slug":"docker","permalink":"http://langonggong.com/tags/docker/"}]},{"title":"java-concurrency","date":"2018-08-19T04:48:15.000Z","path":"2018/08/19/java-concurrency/","text":"concurrent包 locks(锁) 锁的种类锁分类1锁分类2 公平锁/非公平锁 可重入锁 可中断锁 独享锁/共享锁 互斥锁/读写锁 乐观锁/悲观锁 分段锁 偏向锁/轻量级锁/重量级锁 自旋锁 锁的优化锁的优化 减少锁持有时间 减小锁粒度 锁分离 锁粗化 锁消除 AQS参考链接参考1参考2AQS、ReetrantLock、Condition实现原理 重要方法: isHeldExclusively() tryAcquire(int) tryRelease(int) tryAcquireShared(int) tryReleaseShared(int) Lock参考链接参考1参考2 重要方法 lock() lockInterruptibly() throws InterruptedException tryLock() tryLock(long time, TimeUnit unit) throws InterruptedException unlock() Condition newCondition() ReentrantLock 参考链接 参考1 ReentrantReadWriteLock 参考链接参考1参考2 condition参考链接 生产者、消费者三种实现 atomic(原子变量) AtomicInteger AtomicLong AtomicBoolean AtomicReference AtomicIntegerArray/AtomicLongArray/AtomicReferenceArray CASUnsafe类ABA问题 executor(线程池)框架类图 ThreadPoolExecutor 构造方法和规则 执行原理 线程池终止 关键参数 workQueue(排队策略) threadFactory RejectedExecutionHandler(饱和策略) 常用方法 Executors 创建线程池 newFixedThreadPool newCachedThreadPool newSingleThreadExecutor newScheduledThreadPool collections(并发容器)List和Set CopyOnWriteArrayList 参考1 CopyOnWriteArraySet 参考1 Map ConcurrentHashMap 参考 ConcurrentSkipListMap 参考 ConcurrentSkipListSet Queue ArrayBlockingQueue 123final ReentrantLock lock;private final Condition notEmpty;private final Condition notFull; notEmpty和notFull是锁的两个Condition条件 实现原理 LinkedBlockingQueue LinkedBlockingDeque ConcurrentLinkedQueue ConcurrentLinkedDeque tools(同步工具) CountDownLatch CyclicBarrier Semaphore java内存模型java内存模型synchronized原理 内存模型概述 主内存 工作内存 Java内存模型与硬件内存架构的关系 特性 原子性 可见性 有序性 重排序 指令重排 编译器重排 as-if-serialhappens-before 原则 程序顺序原则 锁规则 volatile规则 线程启动规则 传递性 线程终止规则 线程中断规则 对象终结规则 volatile内存语义 可见性 禁止重排优化 内存屏障（Memory Barrier）参考链接 LoadLoad Barriers StoreStore Barriers LoadStore Barriers StoreLoad Barriers","tags":[{"name":"java","slug":"java","permalink":"http://langonggong.com/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://langonggong.com/tags/多线程/"},{"name":"jvm","slug":"jvm","permalink":"http://langonggong.com/tags/jvm/"}]},{"title":"Elasticsearch常用搜索","date":"2018-08-19T04:41:41.000Z","path":"2018/08/19/Elasticsearch/","text":"多字段查找multi_match 以下表达式等价于field1 = value1 or field2 = value1 12345678910GET index/type/_search&#123; \"query\": &#123; \"multi_match\": &#123; \"query\": \"value1\", \"fields\": [\"field1\",\"field2\"] &#125; &#125; , \"_source\": [\"field1\",\"field2\"]&#125; 布尔查询must等价于and,must_not等价于not, should等价于or 以下表达式等价于( field1 = value1 or field2 = value2 ) and field3 != value3 123456789101112131415161718192021222324252627282930313233343536GET index/type/_search&#123; \"size\": 100, \"query\": &#123; \"bool\": &#123; \"must\": [ &#123; \"bool\": &#123; \"should\": [ &#123; \"match\": &#123; \"field1\": \"value1\" &#125; &#125;, &#123; \"match\": &#123; \"field2\": \"value2\" &#125; &#125; ] &#125; &#125; ], \"must_not\": [ &#123; \"match\": &#123; \"field3\": \"value3\" &#125; &#125; ] &#125; &#125;, \"_source\": [ \"field1\",\"field2\",\"field3\" ]&#125; 模糊查询fuzziness 参考链接 123456789101112131415161718192021GET index/type/_search&#123; \"size\": 100, \"query\": &#123; \"bool\": &#123; \"must\": [ &#123; \"match\": &#123; \"city\": &#123; \"query\": \"Hoiliste\", \"fuzziness\": \"auto\" &#125; &#125; &#125; ] &#125; &#125;, \"_source\": [ \"city\" ]&#125; 通配符查询*匹配零个或多个字符 1234567891011121314151617181920GET index/type/_search&#123; \"size\": 100, \"query\": &#123; \"bool\": &#123; \"must\": [ &#123; \"wildcard\": &#123; \"field1\": &#123; \"value\": \"wu*\" &#125; &#125; &#125; ] &#125; &#125;, \"_source\": [ \"field1\" ]&#125; 正则查询regexp 123456789101112GET index/type/_search&#123; \"size\": 100, \"query\": &#123; \"regexp\":&#123; \"field1\":\"[a-zA-Z]+[0-9]*\" &#125; &#125;, \"_source\": [ \"field1\" ]&#125; 范围查询range 1234567891011121314151617GET index/type/_search&#123; \"size\": 100, \"query\": &#123; \"range\": &#123; \"field1\": &#123; \"from\": \"2018-04-16 05:22:39\", \"to\": \"2018-06-23 05:22:39\", \"include_lower\": true, \"include_upper\": true &#125; &#125; &#125;, \"_source\": [ \"field1\" ]&#125; 排序sort 1234567891011121314151617GET index/type/_search&#123; \"size\": 100, \"query\": &#123; \"bool\": &#123;&#125; &#125;, \"sort\": [ &#123; \"field1\": &#123; \"order\": \"desc\" &#125; &#125; ], \"_source\": [ \"field1\" ]&#125; 多重过滤filter 12345678910111213141516171819202122232425262728GET index/type/_search&#123; \"size\": 100, \"query\": &#123; \"bool\": &#123; \"filter\": [ &#123; \"bool\": &#123; \"must\": &#123; \"term\": &#123; \"field1\": \"value1\" &#125; &#125; &#125; &#125;, &#123; \"bool\": &#123; \"must\": &#123; \"term\": &#123; \"field2\": \"value1\" &#125; &#125; &#125; &#125; ] &#125; &#125;, \"_source\": [\"cityTerm\", \"mlsOrgId\"]&#125; 脚本查询参考链接 script支持Groovy、java等多种语言的脚本 12345678910111213141516171819&#123; \"query\": &#123; \"bool\": &#123; \"filter\": [ &#123; \"bool\": &#123; \"filter\": &#123; \"script\": &#123; \"script\": &#123; \"inline\": \"doc['field1'].value - doc['field2'].value &gt; 0\" &#125; &#125; &#125; &#125; &#125; ] &#125; &#125;&#125;","tags":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://langonggong.com/tags/Elasticsearch/"},{"name":"DSL","slug":"DSL","permalink":"http://langonggong.com/tags/DSL/"}]},{"title":"mysql分库、分区、分表、分片","date":"2018-08-19T01:20:32.000Z","path":"2018/08/19/mysql分库、分区、分表、分片/","text":"分表概念mysql的分表是真正的分表，一张表分成很多表后，每一个小表都是完正的一张表，都对应三个文件（MyISAM引擎：一个.MYD数据文件，.MYI索引文件，.frm表结构文件）分表后数据都是存放在分表里，总表只是一个外壳，存取数据发生在一个一个的分表里面 适用场景 一张表的查询速度已经慢到影响使用的时候 当频繁插入或者联合查询时，速度变慢 实现利用merge存储引擎来实现分表 1234567891011121314151617181920CREATE TABLE `tb_member1` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(20) DEFAULT NULL, `sex` tinyint(4) NOT NULL DEFAULT '0', PRIMARY KEY (`id`)) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8CREATE TABLE `tb_member2` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(20) DEFAULT NULL, `sex` tinyint(4) NOT NULL DEFAULT '0', PRIMARY KEY (`id`)) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8CREATE TABLE `tb_member` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(20) DEFAULT NULL, `sex` tinyint(4) NOT NULL DEFAULT '0', PRIMARY KEY (`id`)) ENGINE=MRG_MyISAM DEFAULT CHARSET=utf8 INSERT_METHOD=LAST UNION=(`tb_member1`,`tb_member2`) 说明 分表数据库引擎是MyISAM 分表与主表的字段定义一致 参考链接参考链接1 参考链接2 分区概念把存放数据的文件分成了许多小块，分区后的表还是一张表 适用场景 一张表的查询速度已经慢到影响使用的时候 表中的数据是分段的 对数据的操作往往只涉及一部分数据，而不是所有的数据 历史数据或不常访问的数据占很大部分，最新或热点数据占的比例不是很大，可以根据有些条件进行表分区。例如，表中有大量的历史记录，而“热数据”却位于表的末尾 分区类型 分区类型 特点 RANGE 基于属于一个给定连续区间的列值，把多行分配给分区 LIST 类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择 HASH 基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式 KEY 类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值 操作方式创建分区 1234567891011CREATE TABLE sales ( id INT AUTO_INCREMENT, amount DOUBLE NOT NULL, order_day DATETIME NOT NULL, PRIMARY KEY(id, order_day)) ENGINE=Innodb PARTITION BY RANGE(YEAR(order_day)) ( PARTITION p_2010 VALUES LESS THAN (2010), PARTITION p_2011 VALUES LESS THAN (2011), PARTITION p_2012 VALUES LESS THAN (2012),PARTITION p_catchall VALUES LESS THAN MAXVALUE); 常用操作 参考链接参考链接1 参考链接2 分库参考链接 分片参考链接","tags":[{"name":"mysql","slug":"mysql","permalink":"http://langonggong.com/tags/mysql/"}]},{"title":"java虚拟机","date":"2018-08-18T22:07:10.000Z","path":"2018/08/19/java虚拟机/","text":"运行时数据区 Java堆（Heap）对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。 根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 方法区（Method Area）方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。 对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。 Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。 根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 程序计数器（Program Counter Register）程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。 此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 JVM栈（JVM Stacks）与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。 其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。 本地方法栈（Native Method Stacks）本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 对象的访问定位句柄方式如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息 优点使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改 直接指针方式如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址 优点使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本 GC对象存活分析引用计数法原理给对象中每一个对象分配一个引用计数器，每当有地方引用该对象时，引用计数器的值加一，当引用失效时，引用计数器的值减一，不管什么时候，只要引用计数器的值等于0了，说明该对象不可能再被使用了 优缺点实现原理简单，而且判定效率很高。大部分情况下都是一个不错的算法。但很难解决对象之间相互循环引用的问题 可达性分析原理通过一系列被称为“GC Roots‘’的对象作为起始点，从这些节点向下搜索，搜索所走过的路径叫做引用链，当一个节点到GC Roots没有任何引用链时，证明该对象不可用了 被作为GC Roots的对象有以下几种: 虚拟机栈中引用的对象（栈帧中的引用变量表） 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中Native方法（JNI）引用的对象 方法区的垃圾回收永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类 废弃常量回收回收废弃常量与回收Java堆中的对象非常相似。以常量池中字面量的回收为例，若字符串“abc”已经进入常量池中，但当前系统没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用该字面量，若发生内存回收，且必要的话，该“abc”就会被系统清理出常量池。常量池中其他的类（接口）、方法、字段的符号引用与此类似 无用的类回收 该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例 加载该类的ClassLoader已经被回收 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法 在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出 新生代、老年代以及永久代 堆大小 = 新生代 + 老年代 新生代1个Eden区和2个Survivor区（分别叫from和to）,默认比例为8：1。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。 因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法 在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To” 老年代老年代与新生代不同，对象存活的时间比较长，比较稳定，因此采用标记（Mark）算法来进行回收 永久代在JDK的HotSpot虚拟机中，可以认为方法区就是永久代，但是在其他类型的虚拟机中，没有永久代的概念 GC分类 Minor GC 发生在新生代中的垃圾收集动作，所采用的是复制算法 FullGC (Major GC) 发生在老年代的垃圾收集动作，所采用的是标记-清除算法 JVM内存管理参数JVM参数使用总结 -Xms 设置堆的最小空间大小 -Xmx 设置堆的最大空间大小 -XX:NewSize 设置新生代最小空间大小 -XX:MaxNewSize 设置新生代最大空间大小 -XX:PermSize 设置永久代最小空间大小 -XX:MaxPermSize 设置永久代最大空间大小 -Xss 设置每个线程的堆栈大小。 -XX:NewRatio 设置新生代和老生代的相对大小 -XX:SurvivorRatio 指定Eden区和Survivor区的大小比例,注意两个幸存区是一样大的 垃圾收集算法 复制算法(新生代)该算法的核心是将可用内存按容量划分为大小相等的两块, 每次只用其中一块, 当这一块的内存用完, 就将还存活的对象复制到另外一块上面, 然后把已使用过的内存空间一次清理掉 标记清除算法(老年代)该算法分为“标记”和“清除”两个阶段: 首先标记出所有需要回收的对象(可达性分析), 在标记完成后统一清理掉所有被标记的对象 该算法会有以下两个问题 效率问题: 标记和清除过程的效率都不高; 空间问题: 标记清除后会产生大量不连续的内存碎片, 空间碎片太多可能会导致在运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集 标记整理算法(老年代)标记清除算法会产生内存碎片问题, 而复制算法需要有额外的内存担保空间, 于是针对老年代的特点, 又有了标记整理算法. 标记整理算法的标记过程与标记清除算法相同, 但后续步骤不再对可回收对象直接清理, 而是让所有存活的对象都向一端移动,然后清理掉端边界以外的内存 垃圾收集器 参考链接1参考链接2 串行收集器 Serial开头的 Serial Serial Old(MSC) 并行收集器 Parallel开头的 ParNew Parallel Scavenge Parallel Old 并发收集器 CMS (Concurrent Mark Sweep) G1(Garbage First) 图片中的问号位置 JDK 1.7后有G1 GC日志日志格式 1[GC（GC类型，当前是Minor GC） (Allocation Failure) [DefNew（GC的区域，当前为新生代）: 5688K（垃圾回收前的大小）-&gt;790K（垃圾回收以后的大小）(9216K)（该区域总大小）, 0.0060899 secs] 5688K（堆在垃圾回收前的大小）-&gt;4886K（堆在垃圾回收后的大小）(19456K)（堆的总大小）, 0.0061183 secs] [Times: user=0.00（用户态消耗CPU时间） sys=0.01（内核态小时CPU时间）, real=0.00 secs（操作的实际时间）] 参考链接 大对象直接进入老年代 长期存活的对象进入老年代 Class文件结构 参考系列 类加载机制 参考链接参考章节 加载 通过一个类的全限定名来获取其定义的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口 除了可以使用系统提供的引导类加载器外，还可以使用用户自定义的类加载器。任意一个类，都需要由加载它的类加载器和这个类本身共同确定其在Java 虚拟机中的唯一性 类加载器 启动类加载器：启动类加载器无法被 java 程序直接引用，如需要，直接使用 null 代替即可 扩展类加载器 应用程序类加载器：它负责加载用户路径(ClassPath)上所指定的类库，开发者可以使用这个类加载器，如果应用程序没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器 双亲委派模型如果一个类加载器收到了类加载器的请求，它首先不会自己尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类时），子加载类才会尝试自己去加载 验证验证阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全 文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，主要是验证类的继承关系、数据类型是否符合 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。对类的方法体进行校验分析，以保证被校验类的方法在运行时不会做出危害虚拟机安全的事件 符号引用验证：发生在虚拟机将符号引用转化为直接引用的时候,对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配 这阶段进行内存分配的仅包括类变量（即被static修饰的变量），不包括实例变量 这里所说的初始值“通常情况”下是数据类型的零值 解析解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程 符号引用（Symbolic References）：即用一组符号来描述所引用的目标。它与虚拟机的内存布局无关，引用的目标不一定已经加载到内存中 直接引用（Direct References）：直接引用可以是指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。它是和虚拟机内存布局相关的，如果有了直接引用，那引用的目标必定已经在内存中存在了 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7类符号引用进行 初始化初始化是类加载过程的最后一步，此阶段才开始真正执行类中定义的Java程序代码（或者说字节码，也仅限与执行()方法）。在准备阶段，我们已经给变量付过一次系统要求的初始值（零值），而在初始化阶段，则会根据程序员的意愿给类变量和其他资源赋值。主要是通过()方法来执行的 虚拟机字节码执行引擎章节参考 Java编译期优化 解析与填充符号表过程解析步骤包含了词法分析和语法分析两个过程，首先词法分析是将源代码的字符流转变成为标记集合（token），然后语法分析是根据token序列来构造抽象语法树（一种用来描述程序代码语法结构的树状表示方式）。完成词法分析和语法分析之后，下一步是填充符号表，符号表是由一组符号地址和符号信息构成的表格，符号表中所登记的信息在编译的不同阶段都要用到（比如语义分析中符号表所登记的内容将用于语义检查和产生中间代码，目标代码生成阶段当对符号名进行地址分配时，符号表是地址分配的依据） 插入式注解处理器的注解处理过程插入式注解处理器可以看做是一组编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，那么编译器将回到解析及填充符号表的过程重新处理，直到所有的插入式注解处理器都没有再对语法树进行修改为止 语义分析与字节码生成过程语法分析之后，编译器获得了程序代码的抽象语法树表示，语法树能够表示结构正确的源程序的抽象，但是无法保证源程序是否符合逻辑，而语义分析主要是对结构上正确的源程序进行上下文有关性质的检查 标注检查标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配，等等。还有一个重要的动作称为常量折叠也在此阶段完成 数据及控制流分析数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否有返回值、是否所有的受查异常都被正确处理了等问题 解语法糖语法糖是指在计算机语言中添加某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。java中的泛型，变长参数，自动拆箱与装箱，条件编译等就属于语法糖，它们在编译阶段就被还原成简单的语法结构（比如List和List在运行期间其实是同一个类） 字节码生成此过程是javac编译过程的最后一个阶段，字节码生成阶段将之前各个步骤所生成的信息转化成字节码写到磁盘中，另外还进行少量的代码添加和转换工作 Java运行期优化 在部分商用虚拟机中，java程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块运行特别频繁，就会把这些代码认定为“热点代码”，为了提高热点代码的执行效率，在运行时，虚拟机就会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器或JIT编译器。 即时编译器并不是虚拟机必须的部分，但是即时编译器编译性能的好坏、代码优化程度的高低确是衡量一款商用虚拟机优秀与否的最关键的指标之一。 众多主流的虚拟机都同时包含解释器和JIT编译器，解释器与JIT编译器各有优势：当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行。当程序运行后，随着事件的推移，JIT编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率 会被即时编译器编译的热点代码有两类 被多次调用的方法体 被多次调用的循环体 即时编译器会以整个方法作为编译对象，将其编译成机器码。这种编译方式因为编译发生在方法执行过程之中，因此被称作栈上替换（OSR） 判断一段代码是否是热点代码的方式（热点探测）有两种 基于采样的热点探测：此方法会周期性检查各个线程的栈顶，如果发现某个或某些方法经常出现在栈顶，那么这个方法就是热点方法。此方法的缺点是很难精确地确认一个方法的热度，容易受到诸如线程阻塞等因素影响 基于计数器的热点探测：此方法会为每个方法甚至是代码块建立计数器，统计方法的执行次数，如果执行次数超过一个阀值就认为它是热点方法 默认设置下，执行引擎并不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成。当编译工作完成之后，这个方法的调用入口地址就会被系统自动改写成新的地址，下一次调用该方法时就会使用已编译的版本。也就是说，在编译器还未完成之前，执行引擎仍按照解释方式继续执行，而编译动作则在后台的编译线程中进行 优化技术一般来说即时编译器所产生的本地代码会比javac产生的字节码更优秀。即时编译器采用了一系列的技术来优化代码，比如公共子表达式消除，数组范围内检查消除，方法内联，逃逸分析等","tags":[{"name":"java","slug":"java","permalink":"http://langonggong.com/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://langonggong.com/tags/jvm/"}]}]